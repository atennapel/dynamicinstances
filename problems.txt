// 1: operation call escapes heap handler
r <- h#ref 1;
handle(h)(
  r#get ()        // will not be handled
) {
  ref v k -> ...
}

// 2: operation call escapes encapsulated instance handler
r1 <- h#ref 1;
r2 <- h#ref 2;
handle(r1)(
  r2#get ()       // will not be handled
) {
  get ...
  put ...
}

// Solutions:
// 1. umbrella/encapsulated instances cannot be fully handled
// 2. special handler for umbrella effects:
//    - umbrella handler creates the umbrella instance
//    - continuation that takes the encapsulated instance is universally quantified
r1\{hi} <= r2
hi not_in t2!r2
---------------
handle umbrella(h : Inst hi Heap)(v : forall i. Inst i Heap -> t1!r1) {
  return (v : t1) -> c : t2!r2

  ref v (k : forall ri. Inst ri State -> t2!(r2 u {ri})) ->
    new State as (si, s) in
    handle(s)(k [si] s) {
      get ...
      put ...
    }
}
OR
new Heap with v as (hi, h) in c
v : forall i. Inst i Heap -> (() -> t1!r1) -> t2!r2
c : t1!r1
result : t2!r2
hi not_in t2!t2

// TODO
// what about:
effect Heap {
  h@iref : Inst h State -> Int
  h@biref : Inst h State -> Inst h State
}
