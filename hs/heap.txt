

r1 <- h#ref 1;      -- Inst h State
runState r1 $ \().  -- Int
  r2 <- h#ref 2;
  x <- r1#get ();
  r2#get x          -- not handled!





effect State {
	get : () -> Int
	put : Int -> ()
}

effect h@Heap {
  ref : Int -> Inst h State
}

runState : forall i. Int -> Inst i State -> (() -> Int!{i}) -> Int
runState = /\i. \v ins action.
  f <- handle(action ()) {
    is#return x -> \s -> x
    is#get () k -> \s -> k s s
    is#put s' k -> \s -> k () s'
  };
  f v

runHeap : (forall h. Inst h Heap -> Int!{h}) -> Int
runHeap = \c.
  (hi, i) := new Heap;
  handle(c [hi] i) {
    ref v k ->
      r <- new hi@State with runState;
      k r
  

ref : forall hi. Int -> Inst hi heap -> (Inst h State)!{hi}
ref = /\hi. \v h -> h#ref v

program : forall hi. Inst hi Heap -> Int!{hi}
program = /\hi. \h.
  r <- h#ref 42;
  r#get ()

main : () -> Int
main = \().
  runHeap [Int] program
