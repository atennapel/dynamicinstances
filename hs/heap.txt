effect State {
	get : () -> Int
	put : Int -> ()
}

effect h@Heap {
  ref : Int -> Inst h State
}

runState : forall i. Int -> Inst i State -> (() -> Int!{i}) -> Int
runState = /\i. \v is c.
  f <- handle(c ()) {
    is#return x -> \s -> x
    is#get () k -> \s -> k s s
    is#put s' k -> \s -> k () s'
  };
  f v

runHeap : (forall h. Inst h Heap -> Int!{h}) -> Int
runHeap = \c.
  (hi, i) := new Heap;
  handle(c [hi] i) {
    ref v k ->
      r <- new hi@State with runState;
      k r
  }

program : forall hi. Inst hi Heap -> Int!{hi}
program = /\hi. \h.
  r <- h#ref 42;
  r#get ()

main : () -> Int
main = \().
  runHeap [Int] program
