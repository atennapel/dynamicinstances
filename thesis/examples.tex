\iffalse
\fi

In this chapter we will give an introduction to programming with X.
X is a modification of the algebraic effects system described in Chapter~2.1, extended with a restricted form of the dynamic instances of Chapter~2.3.
We introduce the novel concepts of X.
When create a new instance we have to give handler, this ensures that the instance is always associated with a handler.
The handle construct does not handle a single effect but can handle multiple effects at the same time.
These effects are collected under a notion of \emph{effect scope}, which is used to group instances together.
When handle is called one such effect scope is handled.
We introduce \emph{effect scope polymorphism} together with \emph{effect scope abstraction} and {effect scope application}.
These constructs allows us to write functions which are polymorphic over effect scopes.
\\\\
We start with and example explaining all the novel concepts in Section~3.1.
After we will show how mutable references can be expressed in X in Section~3.2.
Then we will how mutable vectors can be defined, followed by an implementation of a list shuffling algorithm in Section~3.3.
We end the chapter by showing how local effects can be defined in Section~3.4
\\\\
We build on the language used in Chapter~2.1.
We use a language reminiscent of Haskell with algebraic data types and pattern matching.
Type constructors and effect names are uppercase while type variables are lowercase.
The language also has parametric polymorphism over effect scopes.
%We will always explicitly show \ident{forall} for universally quantified effect scope variables.

\section{Effects, effect scopes and instances}
\label{section:basics}

\begin{figure}
\caption{Example of the novel constructs}
\begin{minted}[tabsize=2,frame=single]{haskell}
effect State {
	get : () -> Int
	put : Int -> ()
}

postInc : forall s. Inst s State -> Int!{s}
postInc [s] inst =
	x <- inst#get();
	inst#put(x + 1);
	return x

result : Int
result = handle(s' ->
	new State@s' {
		get v k -> k 0
		put v k -> k ()
		return xr -> return xr
		finally xf -> return xf
	} as inst in
	x <- postInc [s'] inst;
	return x)
-- result is 0
\end{minted}
\label{fig:example1}
\end{figure}

In Figure~\ref{fig:example1} we give an example containing all the novel constructs of X.

\subsection{Effects}

To start off we define a \ident{State} effect specialized to \ident{Int}s.
\ident{State} is meant to represent a mutable reference to a single value of type \ident{Int}.
This definition is exactly the same as the \ident{State} effect definition in Chapter~2.1, in the basic algebraic effects system.
With the \ident{effect} keyword we declare a new effect called \ident{State} with two operations: \ident{get} and \ident{put}.
For each operation we give parameter and return types. For \ident{get} we give the unit type \ident{()} as the parameter type.
As the return type we give \ident{Int}, meaning that calling the \ident{get} operation will return a integer value.
For the \ident{put} operation it is the other way around.
As the parameter type we have \ident{Int}, meaning that \ident{put} requires an integer value when called, and the return type is \ident{()}, calling \ident{put} will give back the unit value.

\subsection{Effect scopes}
In Figure~\ref{fig:example1} the function \ident{postInc} shows how an effect can actually be used.
We show the type of the function again for convenience:

\begin{minted}[tabsize=2]{haskell}
postInc : forall s. Inst s State -> Int!{s}
\end{minted}

This function takes an instance of the \ident{State} effect, called \ident{inst}, of type \ident{Inst s State}.
The type variable \ident{s} here is an \emph{effect scope variable}.
An effect scope variable can be seen as the name of a collection of instances that we call an \emph{effect scope}.
Such a scope can contain zero or more instances, where each instance can be of any effect.
A scope restricts instances in such a way that they cannot escape that scope and instances from one scope cannot be used in another.
This also means that we can never get a runtime error because of an unhandled operation call.
The type of \ident{postInc} can be read as ``For any scope \ident{s}, given a \ident{State} instance in \ident{s}, return an value of type \ident{Int} possibly by calling operations on instances in \ident{s}''.
Note that because of the \ident{forall} we universally quantify over any scope \ident{s}, this means that \ident{postInc} does not choose a specific scope but that the functions can work on any scope.
The \ident{forall} is introduced by the \ident{[s]} syntax, which introduces an effect scope variable \ident{s}.
In order to call \ident{postInc} we have to explicitly give a specific effect scope for the parameter \ident{s}.
The return type of \ident{postInc} is \ident{Int}.
The \ident{!{s}} after the return type is the \emph{effect annotation}, which shows which scopes may be used by the function.

\subsection{Effect instances and handlers}
\label{subsection:instances}
Effects can be used by calling operations.
Operations are always called on an \emph{effect instance}.
Without an instance we are unable to perform operations.
In the case of \ident{postInc} we get an instance as an argument to the function.
Operation can be called on an instance using the syntax \ident{instance\#operation(argument)}.
We write \ident{instance\#operation()} to mean \ident{instance\#operation(())}, when the unit value \ident{()} is given as the argument.
In the case of \ident{postInc} we first call the \ident{get} operation on \ident{inst}.
We get back a value of type \ident{Int}, which we name \ident{x}.
Then we call \ident{put} on \ident{inst} with the argument \ident{(x + 1)}.
Finally we return \ident{x}.

We can create a fresh instance of an effect using the \ident{new} keyword.
In Figure~\ref{fig:example1} we do this in the function \ident{callPostInc}:
\begin{minted}[tabsize=2]{haskell}
new State@s {
	get v k -> k 0
	put v k -> k ()
	return xr -> return xr
	finally xf -> return xf
} as inst in ...
\end{minted}
The construct \ident{new State@s { ... }} can be read as ``Create a fresh \ident{State} instance in the scope \ident{s}''.
Here we have to give a specific scope \ident{s} to create the instance on.
The instance can only be used within this given scope.
The newly-created instance is available in the body of the \ident{new} construct.
When creating an instance we have to give an \emph{handler}.
The handler specifies what should happen when the operations are called.
The handler is defined within curly braces and consists of a case for each operation of the effect, plus a \ident{return} case and a \ident{finally} case.
The handler given here is dummy handler which will always return \ident{0} when \ident{get} is called and which does nothing besides returning \ident{()} when \ident{put} is called.
Note that this is different from the system with dynamic instances from Chapter~2.3.
There we do not give a handler when creating instances, but handlers are a seperate construct.
This change is needed in order to ensure the instances do not escape their scope.
Our type system will make sure that the handler given when creating an instance is \emph{complete}.
Meaning that all the operation calls on the specific instance are handled.
\\\\
In each operation case, \ident{get} and \ident{put} in the above example, we have access to two arguments.
The first variable, \ident{v} above, refers to the argument given when the operation was called.
The second variable, \ident{k} above, refers to the continuation of the operation call, this is the rest of the computation, after the operation call.
By calling \ident{k} with a value we can continue the computation at the point where the operation was called, at that point the program receives the value we give to the continuation \ident{k}.
In the example above we continue with \ident{0} every time \ident{get} on the instance \ident{inst} is called, and we continue with \ident{()} (without performing any other effects) whenever \ident{put} is called.
\\\\
The \ident{return} case gets called at the end of the computation \ident{e}.
The variable \ident{xr} contains the final value of the computation, which can be transformed in the case branch.
It is not required for the computation returned from the case to have the same type as \ident{xr}, and other operations are also allowed to be called.
Finally the \ident{finally} case is wrapped around the whole computation \ident{e} after the \ident{return} computation has been performed.
The variable \ident{xf} contains the transformed value returned from the \ident{return} case.
The finally case is useful in situations where we need to perform a final transformation on the return value of a computation.
We will make use of it when define mutable references in Section~3.2.

\subsection{Handling instances}
The definition \ident{result} shows how the effects in a computation can be performed.
We show its definition here again for convenience:

\begin{minted}[tabsize=2]{haskell}
result : Int
result = handle(s' ->
	new State@s' {
		get v k -> k 0
		put v k -> k ()
		return xr -> return xr
		finally xf -> return xf
	} as inst in
	x <- postInc [s'] inst;
	return x)
\end{minted}

The \ident{handle(s' -> ...)} construct provides a new scope, which we named \ident{s'} in our case, which can be used in its body.
Inside \ident{handle} we can create and use instances in this new scope \ident{s'}.
\ident{handle} will make sure that any instances that are created on its scope will actually be created and that any operation calls on these instances will be handled.
In the case of \ident{result} we create a new \ident{State} instance on \ident{s'} using the same handler as in Section~\ref{subsection:instances}.
We name this new instance \ident{inst}.
Then we call \ident{postInc}, passing \ident{s'} and the new instance as its arguments.
Finally we return the result of \ident{postInc} as the result of the \ident{handle} construct.
Note that the type of \ident{result} does not have any effects, \ident{handle} will use the handlers defined when creating instances to perform the operations called on the instances in its scope.
That means the result of \ident{handle(s -> ...)} will not have any effects in \ident{s} (no operation calls on instances of \ident{s}).
\ident{handle} will not perform any other effects beside the ones in its own scope, any other effects (on other scopes) will be forwarded through and will remain after \ident{handle} is done.
For example:

\begin{minted}[tabsize=2]{haskell}
twoScopes : forall s''. Int!{s''}
twoScopes [s''] = handle(s' ->
	x <- f [s'];
	y <- f [s''];
	...)
\end{minted}

Here we use some function \ident{f} on two different scopes (\ident{s'} and \ident{s''}) but we only handle one of the scopes (\ident{s'}).
We can also see this in the type, \ident{s'} does not appear while \ident{s''} does. 

\newpage
\section{Mutable references}
\begin{figure}[h]
\caption{Mutable references}
\begin{minted}[tabsize=2,frame=single]{haskell}
-- create a fresh reference initialized
-- with the integer value v
ref : forall s. Int -> (Inst s State)!{s}
ref [s] v =
	new State@s {
		get () k -> \st -> k st st
		put st' k -> \st -> k () st'
		return x -> \st -> return x
		finally f -> f v
	} as x in return x

result : Int
result = handle(s' ->
	r1 <- ref [s'] 0;
	r2 <- ref [s'] 42;
	x <- r1#get();
	y <- r2#get();
	r1#put(y);
	r2#put(x)
	r1#get())
-- result is 42
\end{minted}
\label{fig:example2}
\end{figure}


Using the constructs explained in Section~\ref{section:basics} we can now implement mutable references.
We can create a new mutable reference initialized with some integer using the \ident{ref} function shown in Figure~\ref{fig:example2}.
\ident{ref} takes an effect scope and an integer and returns a new \ident{State} instance.
The handler given in \ident{ref} defines the usual semantics for a mutable reference. 
The \ident{get} operation returns the current value of the reference and \ident{put} updates the value of the reference.
We implement the operations using a technique called \emph{parameter-passing}\cite{algtutorial}.
We transform the computation to a function that takes the value of the reference.
 For \ident{get} we return a function that takes the value of the state (\ident{st}) and passes this value to the continuation, which will give us back another function that expects the state value. We give this function the same state value as we are given, since \ident{get} does not change the state.
 For \ident{put} we ignore the given state value and call the continuation with the unit value.
 Again we get another function back from the continuation, which expects the state value.
 We call this function with the argument of \ident{put} (\ident{st'}), since that is the new value of the state.
 In the case of \ident{return} we simple ignore the state value (\ident{st}) and return the final value of the computation: \ident{x}.
 We could also have chosen to return the state value instead or both the state value and the final computation value.
 Now we end up with a function that expects the initial value of the state as the parameter \ident{f} in the \ident{finally} case.
 We run the actual computation by calling this function with the \ident{v} argument of \ident{ref}.
 At the end of \ident{ref} we simply return the newly created instance as the result of the function.

\section{Mutable vectors}
\begin{minted}[tabsize=2]{haskell}
-- (linked) list of integer values
data List = Nil | Cons Int List
data Vector s = VNil | VCons (Inst s State) Vector

-- get the length of a list
length : List -> Int
length Nil = 0
length (Cons _ t) = 1 + (length t)

-- transform a list to a vector by replacing each value in the list
-- by a reference initialized with that value
toVector : forall s. List -> (Vector s)!{s}
toVector [s] Nil = VNil
toVector [s] (Cons h t) =
	h' <- newRef [s] h;
	t' <- toVector [s] t;
	return (VCons h' t')

-- transform a vector back to a list by getting the
-- current values from the references in the vector
toList : forall s. Vector s -> List!{s}
toList [s] VNil = Nil
toList [s] (VCons h t) =
	h' <- h#get();
	t' <- toList [s] t;
	return (Const h' t')

-- get the value at the index given as the first argument
-- assumes the index is within range of the vector
vget : forall s. Int -> Vector s -> Int!{s}
vget [s] 0 (VCons h _) = h#get()
vget [s] n (VCons _ t) = vget [s] (n - 1) t

-- set the value at the index given as the first argument
-- to the value given as the second argument
-- assumes the index is within range of the vector
vset : forall s. Int -> Int -> Vector s -> ()!{s}
vset [s] 0 v (VCons h _) = h#put(v)
vset [s] n v (VCons _ t) = vset [s] (n - 1) v t
\end{minted}

\section{List shuffle}
\begin{minted}[tabsize=2]{haskell}
-- random number generation effect
-- the operation `rand` gives back a random integer
-- between 0..n, where n is the argument given (exclusive)
effect Rng {
	rand : Int -> Int
}

-- shuffles a list given an instance of Rng
shuffle : forall s'. Inst s' Rng -> List -> List!{s'}
shuffle [s'] rng lst =
	handle(s ->
		let vec = toVector [s] lst;
		shuffleVector [s] [s'] rng 100 vec;
		return (toList vec))

-- shuffles a vector given an instance of Rng
-- by swapping two random elements of the vector
-- the second argument to shuffleVector is the amount of times
-- to swap elements
shuffleVector : forall s s'. Inst s' Rng -> Int -> Vector s -> ()!{s, s'}
shuffleVector [s] [s'] _ 0 vec = vec
shuffleVector [s] [s'] rng n vec =
	let len = length vec;
	i <- rng#rand(len);
	j <- rng#rand(len);
	a <- vget [s] i vec;
	b <- vget [s] j vec;
	vset [s] i b vec;
	vset [s] j a vec;
	shuffleVector [s] [s'] rng (n - 1) vec
\end{minted}

\section{Local effects}
\begin{minted}[tabsize=2]{haskell}
-- folding with early exit
effect Done {
	done : T -> ()
}

-- foldr creates a new instance of Done
-- and passes this to the reducer function
-- if done is called on the instance
-- then foldr stops and returns the value given
-- note: nested uses of foldr do not interfere because
-- new instances are created with each call
foldr : (forall s. Inst s Done -> Int -> T -> T!{s}) ->
	T -> List -> T
foldr fn initial list =
	handle(s ->
		new Done@s {
			done v k -> return v
			return x -> return x
		} as inst in
		foldrRec [s] (fn [s] inst) initial list)

-- recursive foldr implementation
foldrRec : forall s. (Int -> r -> r!{s}) ->
	r -> List -> r!{s}
foldRec fn initial Nil = initial
foldRec fn initial (Cons h t) = fn h (foldRec fn initial t)

-- does the list have any element satifying the predicate function
-- returns early if the predicate function returns True
contains : (Int -> Bool) -> List -> Bool
contains fn list =
	let result = foldr (\inst h _ ->
		if fn h then
			inst#done(True)
		else
			False
	) False list
\end{minted}

References Typed Logical Variables\cite{typedlogic}
