\iffalse
\fi

In this chapter we will give an introduction to programming with X. We will start with defining mutable references and mutable vectors. After we will show how to implement a list shuffling algorithm that internally uses mutation and we will finish with an example of locally scoped effects.
\\\\
We will use a language reminiscent of Haskell with algebraic data types and pattern matching.
Type constructors are uppercase while type variables are lowercase.
We will always explicitly show \ident{forall} for universally quantified scope variables.

\section{Mutable references}
To start off we will define a \ident{State} effect specialized to \ident{Int}s.
\begin{minted}[tabsize=2]{haskell}
-- the State effect
effect State {
	get : () -> Int
	put : Int -> ()
}
\end{minted}

This definition is exactly the same as the \ident{State} effect definition in Chapter~2.1, in the basic algebraic effects system.
With the \ident{effect} keyword we declare a new effect called \ident{State} with two operations: \ident{get} and \ident{put}.
For each operation we give parameter and return types. For \ident{get} we give the unit type \ident{()} as the parameter type, \ident{()} is the unit type, the type with exactly one value: the unit value, also written as \ident{()}. A parameter type of \ident{()} means that \ident{get} does not expect a meaningful argument. As the return type we give \ident{Int}, meaning that calling the \ident{get} operation will return a integer value. For the \ident{put} operation it is the other way around, as the parameter type we have \ident{Int}, meaning that \ident{put} requires an integer value when called, and the return type is \ident{()}, calling \ident{put} will give back the unit value. Having \ident{()} as the return type of an operation means that the operation does not return any meaningful value but calling the operation is only useful for its effect.
\\\\
Operations are always called on an \emph{effect instance}, without an instance we are unable to perform operations.
As an example consider the following post-increment function:
\begin{minted}[tabsize=2]{haskell}
postInc : forall s. Inst s State -> Int!{s}
postInc inst =
	x <- inst#get ();
	inst#put (x + 1);
	return x
\end{minted}

This function takes an instance of the \ident{State} effect, called \ident{inst}, of type \ident{Inst s State}.
The meaning of the scope variable \ident{s} will be explained later, but for now you can see it as a heap where the instance ``lives''.
Operation calls can be done on an instance using the syntax \ident{instance#operation(argument)}.
We write \ident{instance#operation()} to mean \ident{instance#operation( () )}, when the unit value \ident{()} is given as the argument.
In the case of \ident{postInc} we first retrieve the current value from the instance by calling the \ident{get} operation on \ident{inst}.
This value is named \ident{x}.
After we increment the value of the instance by calling the \ident{put} operation with \ident{(x + 1)}.
Finally we return \ident{x}, the old value of the \ident{inst}.
\\\\
We can create a fresh instance of an effect using the \ident{new} keyword, for example:
\begin{minted}[tabsize=2]{haskell}
new State@s {
	get v k -> k 0
	put v k -> k ()
	return xr -> return xr
	finally xf -> return xf
} as inst in e
\end{minted}
Here we create a new instance of the \ident{State} effect at scope \ident{s} (the meaning of which we will explain later), the newly-created instance is available in the expressions \ident{e}, as the variable \ident{inst}.
When creating an instance we have to give an \emph{handler}, the handler specifies what should happen when the operations are called.
The handler is defined within curly braces and consists of a case for each operation of the effect, plus a \ident{return} case and a \ident{finally} case.
\\\\
In each operation case, \ident{get} and \ident{put} in the above example, we have access to two arguments.
The first variable, \ident{v} above, refers to the argument given when the operation was called.
The second variable, \ident{k} above, refers to the continuation of the operation call, this is the rest of the computation, after the operation call.
By calling \ident{k} with a value we can continue the computation at the point where the operation was called, at that point the program receives the value we give to the continuation \ident{k}.
In the example above we continue with \ident{0} every time \ident{get} on the instance \ident{inst} is called, and we continue with \ident{()} (without performing any other effects) whenever \ident{put} is called.
\\\\
The \ident{return} case gets called at the end of the computation \ident{e}.
The variable \ident{xf} contains the final value of the computation, which can be transformed in the case branch.
It is not required for the computation returned from the case to have the same type as \ident{xr}, and other operations are also allowed to be called.
Finally the \ident{finally} case is wrapped around the whole computation \ident{e} after the \ident{return} computation has been performed.
The variable \ident{xf} contains the transformed value returned from the \ident{return} case.
This case may not seem that useful, but we will see it is necessary in order to define mutable references.
\\\\
Explain scopes here.
\\\\
Example of references

\begin{minted}[tabsize=2]{haskell}
-- create a fresh reference initialized with the integer value v
newRef : forall s. t -> (Inst s State)!{State@s}
newRef [s] v =
	new State@s {
		get () k -> \s -> k s s
		put s' k -> \s -> k () s'
		return x -> \s -> return x
		finally f -> f v
	} as x in return x
\end{minted}
explanation.
\\\\
Example of using references

\section{Mutable vectors}
\begin{minted}[tabsize=2]{haskell}
-- (linked) list of integer values
data List = Nil | Cons Int List

-- a mutable vector modeled by
-- a list of references in scope s
type Vector s = List (Inst s State)

-- get the length of a list
length : List -> Int
length Nil = 0
length (Cons _ t) = 1 + (length t)

-- transform a list to a vector by replacing each value in the list
-- by a reference initialized with that value
toVector : forall s. List -> (Vector s)!{State@s}
toVector [s] Nil = Nil
toVector [s] (Cons h t) =
	h' <- newRef [s] h;
	t' <- toVector [s] t;
	return (Cons h' t')

-- transform a vector back to a list by getting the
-- current values from the references in the vector
toList : forall s. Vector s -> List!{State@s}
toList [s] Nil = Nil
toList [s] (Cons h t) =
	h' <- h#get();
	t' <- toList [s] t;
	return (Const h' t')

-- get the value at the index given as the first argument
-- assumes the index is within range of the vector
vget : forall s. Int -> Vector s -> Int!{State@s}
vget [s] 0 (Cons h _) = h#get()
vget [s] n (Cons _ t) = vget [s] (n - 1) t

-- set the value at the index given as the first argument
-- to the value given as the second argument
-- assumes the index is within range of the vector
vset : forall s. Int -> Int -> Vector s -> ()!{State@s}
vset [s] 0 v (Cons h _) = h#put(v)
vset [s] n v (Cons _ t) = vset [s] (n - 1) v t
\end{minted}

\section{List shuffle}
\begin{minted}[tabsize=2]{haskell}
-- random number generation effect
-- the operation `rand` gives back a random integer
-- between 0..n, where n is the argument given (exclusive)
effect Rng {
	rand : Int -> Int
}

-- shuffles a list given an instance of Rng
shuffle : forall s'. Inst s' Rng -> List -> List!{Rng@s'}
shuffle [s'] rng lst =
	handle(s ->
		let vec = toVector [s] lst;
		shuffleVector [s] [s'] rng 100 vec;
		return (toList vec))

-- shuffles a vector given an instance of Rng
-- by swapping two random elements of the vector
-- the second argument to shuffleVector is the amount of times
-- to swap elements
shuffleVector : forall s s'. Inst s' Rng -> Int -> Vector s -> ()!{State@s, Rng@s'}
shuffleVector [s] [s'] _ 0 vec = vec
shuffleVector [s] [s'] rng n vec =
	let len = length vec;
	i <- rng#rand(len);
	j <- rng#rand(len);
	a <- vget [s] i vec;
	b <- vget [s] j vec;
	vset [s] i b vec;
	vset [s] j a vec;
	shuffleVector [s] [s'] rng (n - 1) vec
\end{minted}

\section{Local effects}
\begin{minted}[tabsize=2]{haskell}
-- folding with early exit
effect Done t {
	done : t -> ()
}

-- foldr creates a new instance of Done
-- and passes this to the reducer function
-- if done is called on the instance
-- then foldr stops and returns the value given
-- note: nested uses of foldr do not interfere because
-- new instances are created with each call
foldr : (forall s. Inst s (Done r) -> Int -> r -> r!{(Done r)@s}) ->
	r -> List -> r
foldr fn initial list =
	handle(s ->
		new Done@s {
			done v k -> return v
			return x -> return x
		} as inst in
		foldrRec [s] (fn [s] inst) initial list)

-- recursive foldr implementation
foldrRec : forall s. (Int -> r -> r!{(Done r)@s}) ->
	r -> List -> r!{(Done r)@s}
foldRec fn initial Nil = initial
foldRec fn initial (Cons h t) = fn h (foldRec fn initial t)

-- does the list have any element satifying the predicate function
-- returns early if the predicate function returns True
contains : (Int -> Bool) -> List -> Bool
contains fn list =
	let result = foldr (\inst h _ ->
		if fn h then
			inst#done(True)
		else
			False
	) False list
\end{minted}

\section{Type inference for STLC}
\begin{minted}[tabsize=2]{haskell}
data Maybe t = Nothing | Just t

effect Fail {
	fail : () -> Void
}

effect MetaVar {
	assign : Ty s -> ()
	get : () -> Maybe (Ty s)
}

data Term = Var String | Abs String Term | App Term Term
type MVar s = Inst s MetaVar
data Ty s = TVar (MVar s) | TFun Ty Ty

freshMVar : forall s. (MVar s)!{MetaVar@s}
freshMVar [s] () =
	new MetaVar@s {
		assign t k -> 	return \mty -> k () (Just t)
		get () k -> 	return \mty -> k mty mty
		return f -> f Nothing
	} as mv in return mv

pruneMVar : forall s. MVar s -> (Ty s)!{MetaVar@s}
pruneMVar [s] mv =
	mty <- mv#get();
	case mty of
		Nothing -> TVar mv
		Just t ->
			let t' = prune [s] t;
			mv#assign(t');
			return t'

prune : forall s. Ty s -> (Ty s)!{MetaVar@s}
prune [s] (TVar mv) = pruneMVar [s] mv
prune [s] (TFun a b) = TFun (prune [s] a) (prune [s] b)

unify : forall s. Inst s Fail -> Ty s -> Ty s -> ()!{MetaVar@s, Fail@s}
unify [s] fail (TVar mv) t = assignMVar [s] fail x t
unify [s] fail t (Var mv) = assignMVar [s] fail x t
unify [s] fail (TFun l1 r1) (TFun l2 r2) =
	unify [s] fail l1 l2;
	unify [s] fail r1 r2
unify [s] fail _ _ = fail#fail()

assignMVar : forall s. Inst s Fail -> MVar s -> Ty s -> ()!{MetaVar@s}
assignMVar [s] fail x (TVar y) | x == y = return ()
assignMVar [s] fail x t =
	let ty = pruneMVar [s] x;
	case ty of
		TVar mv -> mv#assign(t)
		_ -> unify [s] fail ty t

data Env s = ENil | ECons String (Ty s) (Env s)

extend : forall s. String -> Ty s -> Env s -> Env s
extend [s] x t e = ECons x t e

lookup : forall s. String -> Env s -> Maybe (Ty s)
lookup [s] x ENil = Nothing
lookup [s] x (ECons y ty _) | x == y = Just ty
lookup [s] x (ECons _ _ rest) = lookup [s] x rest

infer : forall s. Inst s Fail -> Env -> Term -> (Ty s)!{MetaVar@s, Fail@s}
infer [s] fail env (Var x) =
	case (lookup x env) of
		Just ty -> return ty
		Nothing -> fail#fail()
infer [s] fail env (Abs x b) =
	mv <- freshMVar [s];
	let env' = extend x (TVar mv) env;
	ty <- infer [s] fail env' b;
	return (TFun (TVar mv) ty)
infer [s] fail env (App a b) =
	ta <- infer [s] fail env a;
	tb <- infer [s] fail env b;
	mv <- freshMVar [s];
	unify [s] fail ta (TFun tb (TVar mv));
	return (TVar mv)

data FinalTy = FTVar Int | FTFun FinalTy FinalTy

finalizeTy : forall s. Inst s State -> Ty s -> FinalTy!{MetaVar@s, State@s}
finalizeTy [s] ref (TVar mv) =
	ty <- mv#get();
	case ty of
		Just t -> finalizeTy [s] ref t
		Nothing ->
			i <- ref#get();
			ref#put(i + 1);
			mv#assign(FTVar i);
			return (FTVar i)
finalizeTy [s] ref (TFun a b) =
	a' <- finalizeTy [s] ref a;
	b' <- finalizeTy [s] ref b;
	return (FTFun a' b')

inferTop : Env -> Term -> Maybe FinalTy
inferTop [s] env term =
	handle(s ->
		new Fail@s {
			fail () k -> return Nothing
			return x -> return x
		} as fail in
		ty <- infer [s] fail env term;
		pruned <- prune ty;
		fty <- finalizeTy pruned;
		return (Just fty))
\end{minted}
