\iffalse
\fi

In this chapter we will give an introduction to programming with X. We will start with defining mutable references and mutable vectors. After we will show how to implement a list shuffling algorithm that internally uses mutation and we will finish with an example of locally scoped effects.
\\\\
We will use a language reminiscent of Haskell with algebraic data types and pattern matching.
Type constructors are uppercase while type variables are lowercase.
We will always explicitly show \ident{forall} for universally quantified scope variables.

\section{Effects, instances and handlers}
To start off we will define a \ident{State} effect specialized to \ident{Int}s.
\begin{minted}[tabsize=2]{haskell}
-- the State effect
effect State {
	get : () -> Int
	put : Int -> ()
}
\end{minted}

This definition is exactly the same as the \ident{State} effect definition in Chapter~2.1, in the basic algebraic effects system.
With the \ident{effect} keyword we declare a new effect called \ident{State} with two operations: \ident{get} and \ident{put}.
For each operation we give parameter and return types. For \ident{get} we give the unit type \ident{()} as the parameter type, \ident{()} is the unit type, the type with exactly one value: the unit value, also written as \ident{()}. A parameter type of \ident{()} means that \ident{get} does not expect a meaningful argument. As the return type we give \ident{Int}, meaning that calling the \ident{get} operation will return a integer value. For the \ident{put} operation it is the other way around, as the parameter type we have \ident{Int}, meaning that \ident{put} requires an integer value when called, and the return type is \ident{()}, calling \ident{put} will give back the unit value. Having \ident{()} as the return type of an operation means that the operation does not return any meaningful value but calling the operation is only useful for its effect.
\\\\
Operations are always called on an \emph{effect instance}, without an instance we are unable to perform operations.
As an example consider the following post-increment function:
\begin{minted}[tabsize=2]{haskell}
postInc : forall s. Inst s State -> Int!{s}
postInc inst =
	x <- inst#get ();
	inst#put (x + 1);
	return x
\end{minted}

This function takes an instance of the \ident{State} effect, called \ident{inst}, of type \ident{Inst s State}.
The meaning of the scope variable \ident{s} will be explained later, but for now you can see it as a heap where the instance ``lives''.
Operation calls can be done on an instance using the syntax \ident{instance#operation(argument)}.
We write \ident{instance#operation()} to mean \ident{instance#operation( () )}, when the unit value \ident{()} is given as the argument.
In the case of \ident{postInc} we first retrieve the current value from the instance by calling the \ident{get} operation on \ident{inst}.
This value is named \ident{x}.
After we increment the value of the instance by calling the \ident{put} operation with \ident{(x + 1)}.
Finally we return \ident{x}, the old value of the \ident{inst}.
\newpage
We can create a fresh instance of an effect using the \ident{new} keyword, for example:
\begin{minted}[tabsize=2]{haskell}
new State@s {
	get v k -> k 0
	put v k -> k ()
	return xr -> return xr
	finally xf -> return xf
} as inst in e
\end{minted}
Here we create a new instance of the \ident{State} effect at scope \ident{s} (the meaning of which we will explain later), the newly-created instance is available in the expressions \ident{e}, as the variable \ident{inst}.
When creating an instance we have to give an \emph{handler}, the handler specifies what should happen when the operations are called.
The handler is defined within curly braces and consists of a case for each operation of the effect, plus a \ident{return} case and a \ident{finally} case.
\\\\
In each operation case, \ident{get} and \ident{put} in the above example, we have access to two arguments.
The first variable, \ident{v} above, refers to the argument given when the operation was called.
The second variable, \ident{k} above, refers to the continuation of the operation call, this is the rest of the computation, after the operation call.
By calling \ident{k} with a value we can continue the computation at the point where the operation was called, at that point the program receives the value we give to the continuation \ident{k}.
In the example above we continue with \ident{0} every time \ident{get} on the instance \ident{inst} is called, and we continue with \ident{()} (without performing any other effects) whenever \ident{put} is called.
\\\\
The \ident{return} case gets called at the end of the computation \ident{e}.
The variable \ident{xf} contains the final value of the computation, which can be transformed in the case branch.
It is not required for the computation returned from the case to have the same type as \ident{xr}, and other operations are also allowed to be called.
Finally the \ident{finally} case is wrapped around the whole computation \ident{e} after the \ident{return} computation has been performed.
The variable \ident{xf} contains the transformed value returned from the \ident{return} case.
This case may not seem that useful, but we will see it is necessary in order to define mutable references later.
\\\\
We now turn our attention to the \emph{scope} variable \ident{s} in the type of \ident{postInc} and in the instance creation example above.
A scope variable can be seen as the name of a collection of instances that we call a \emph{scope}.
Such a scope can contain zero or more instance, where each instance can be of any effect type.
A scope restricts instances in such a way that they cannot escape that scope, instances from one scope cannot be used in another.
The type of \ident{postInc} can be read as ``For any scope \ident{s}, given a \ident{State} instance in \ident{s}, return an value of type \ident{Int} possibly by calling operations on instances in \ident{s}''. Note that because of the \ident{forall} we universally quantify over any scope \ident{s}, this means that \ident{postInc} does not choose a specific scope but that the functions can work on any scope. The construct \ident{new State@s { ... }} can be read as ``Create a fresh \ident{State} instance in the scope \ident{s}''. Here we have to give a specific scope \ident{s} to create the instance on. The instance can only be used within this given scope.
\\\\
In order to call \ident{postInc} we have to give both a scope and a \ident{State} instance in that given scope:
\begin{minted}[tabsize=2]{haskell}
callPostInc : forall s. Int!{s}
callPostInc = /\s.
	new State@s {
		get v k -> k 0
		put v k -> k ()
		return xr -> return xr
		finally xf -> return xf
	} as inst in
	x <- postInc [s] inst;
	return x
\end{minted}

The program \ident{callPostInc} uses the syntax \ident{/\s. } to abstract over a scope, we call this construct \emph{scope abstraction}.
We can then create a new \ident{State} instance on this scope \ident{s}, which we call \ident{inst}.
We now have all the arguments to be able to call \ident{postInc}.
First we use the syntax \ident{postInc [s]}, called \emph{scope application}, to give the scope variable as an argument to \ident{postInc}.
We then give our instance \ident{inst} to \ident{postInc}, which typechecks since \ident{inst} is in the scope \ident{s}.
After we simply return the result of calling \ident{postInc}.
Note, again, that the type of the function is universally quantified over any scope \ident{s},
meaning that \ident{callPostInc} is a computation that returns an integer in any given scope.
\ident{callPostInc} is given this \ident{forall} type because we used the scope abstraction \ident{/\s. }.
\\\\
Now that we have a computation that works on any scope, \ident{callPostInc}, how can we actually run the computation?
To run \ident{callPostInc} we have to give it a specific scope, this can be done as follows:
\begin{minted}[tabsize=2]{haskell}
result : Int
result = handle(s' -> callPostInc [s'])
\end{minted}


\section{Mutable references}
Actual implementation of references, explain \ident{[s]} and how the implementation works.

\begin{minted}[tabsize=2]{haskell}
-- create a fresh reference initialized with the integer value v
newRef : forall s. t -> (Inst s State)!{s}
newRef [s] v =
	new State@s {
		get () k -> \s -> k s s
		put s' k -> \s -> k () s'
		return x -> \s -> return x
		finally f -> f v
	} as x in return x
\end{minted}
explanation.
\\\\
Example of using references

\section{Mutable vectors}
\begin{minted}[tabsize=2]{haskell}
-- (linked) list of integer values
data List = Nil | Cons Int List
data Vector s = VNil | VCons (Inst s State) Vector

-- get the length of a list
length : List -> Int
length Nil = 0
length (Cons _ t) = 1 + (length t)

-- transform a list to a vector by replacing each value in the list
-- by a reference initialized with that value
toVector : forall s. List -> (Vector s)!{s}
toVector [s] Nil = VNil
toVector [s] (Cons h t) =
	h' <- newRef [s] h;
	t' <- toVector [s] t;
	return (VCons h' t')

-- transform a vector back to a list by getting the
-- current values from the references in the vector
toList : forall s. Vector s -> List!{s}
toList [s] VNil = Nil
toList [s] (VCons h t) =
	h' <- h#get();
	t' <- toList [s] t;
	return (Const h' t')

-- get the value at the index given as the first argument
-- assumes the index is within range of the vector
vget : forall s. Int -> Vector s -> Int!{s}
vget [s] 0 (VCons h _) = h#get()
vget [s] n (VCons _ t) = vget [s] (n - 1) t

-- set the value at the index given as the first argument
-- to the value given as the second argument
-- assumes the index is within range of the vector
vset : forall s. Int -> Int -> Vector s -> ()!{s}
vset [s] 0 v (VCons h _) = h#put(v)
vset [s] n v (VCons _ t) = vset [s] (n - 1) v t
\end{minted}

\section{List shuffle}
\begin{minted}[tabsize=2]{haskell}
-- random number generation effect
-- the operation `rand` gives back a random integer
-- between 0..n, where n is the argument given (exclusive)
effect Rng {
	rand : Int -> Int
}

-- shuffles a list given an instance of Rng
shuffle : forall s'. Inst s' Rng -> List -> List!{s'}
shuffle [s'] rng lst =
	handle(s ->
		let vec = toVector [s] lst;
		shuffleVector [s] [s'] rng 100 vec;
		return (toList vec))

-- shuffles a vector given an instance of Rng
-- by swapping two random elements of the vector
-- the second argument to shuffleVector is the amount of times
-- to swap elements
shuffleVector : forall s s'. Inst s' Rng -> Int -> Vector s -> ()!{s, s'}
shuffleVector [s] [s'] _ 0 vec = vec
shuffleVector [s] [s'] rng n vec =
	let len = length vec;
	i <- rng#rand(len);
	j <- rng#rand(len);
	a <- vget [s] i vec;
	b <- vget [s] j vec;
	vset [s] i b vec;
	vset [s] j a vec;
	shuffleVector [s] [s'] rng (n - 1) vec
\end{minted}

\section{Local effects}
\begin{minted}[tabsize=2]{haskell}
-- folding with early exit
effect Done {
	done : T -> ()
}

-- foldr creates a new instance of Done
-- and passes this to the reducer function
-- if done is called on the instance
-- then foldr stops and returns the value given
-- note: nested uses of foldr do not interfere because
-- new instances are created with each call
foldr : (forall s. Inst s Done -> Int -> T -> T!{s}) ->
	T -> List -> T
foldr fn initial list =
	handle(s ->
		new Done@s {
			done v k -> return v
			return x -> return x
		} as inst in
		foldrRec [s] (fn [s] inst) initial list)

-- recursive foldr implementation
foldrRec : forall s. (Int -> r -> r!{s}) ->
	r -> List -> r!{s}
foldRec fn initial Nil = initial
foldRec fn initial (Cons h t) = fn h (foldRec fn initial t)

-- does the list have any element satifying the predicate function
-- returns early if the predicate function returns True
contains : (Int -> Bool) -> List -> Bool
contains fn list =
	let result = foldr (\inst h _ ->
		if fn h then
			inst#done(True)
		else
			False
	) False list
\end{minted}

References Typed Logical Variables\cite{typedlogic}
