\iffalse
In this chapter we will give an introduction to programming with X.
X is a modification of the algebraic effects system described in Chapter~2.1, extended with a restricted form of the dynamic instances of Chapter~2.3.
We introduce the novel concepts of X.
When create a new instance we have to give handler, this ensures that the instance is always associated with a handler.
The $\mathsf{runscope}$ construct can handle multiple effects at the same time.
These effects are collected under a notion of \emph{effect scope}, which is used to group instances together.
When runscope is called one such effect scope is handled.
We introduce \emph{effect scope polymorphism} together with \emph{effect scope abstraction} and {effect scope application}.
These constructs allows us to write functions which are polymorphic over effect scopes.
\fi

In Chapter~2.3 we saw how dynamic instances allow us to implement mutable references in a system with algebraic effects.
This system is untyped however, meaning that you can get runtime errors if an operation is unhandled.
This can happen if an operation is called on a dynamic instance outside of a handler.
In this chapter we introduce X, which combines algebraic effects and dynamic instances while still remaining typeable.
In order to achieve this we introduce the notion of an \emph{effect scope}.
An effect scope groups together instances.
When creating an instance we give an effect scope to create the instance in.
Every instance belongs to a specific effect scope.
Different from the system with dynamic instances from Chapter~2.3, we always have to specify a handler when creating an instance.
This to make sure every instance has a handler associated with it.
Performing effects is done with a new $\mathsf{runscope}$ construct, similar to how the $\mathsf{handle}$ construct performed effects in Chapter~2.
$\mathsf{runscope}$ creates a fresh scope and makes it available for use in a given computation.
After all the instances created on this new scope will actually be instantiated and all the operations called on these instances will be handled.
In order to allow computations to be polymorphic over effect scopes we also introduce \emph{effect scope polymorpishm} together with \emph{effect scope abstraction} and \emph{effect scope application}.
\\\\
We start with explaining all the novel concepts in Section~3.1, using the example of mutable references.
% After we will show how mutable references can be expressed in X in Section~3.2.
Then we will show how mutable vectors can be defined, followed by an implementation of a list shuffling algorithm in Section~3.2.
We end the chapter by showing how our system allows for local effects in Section~3.3.
\\\\
We build on the language used in Chapter~2.1.
We use a language reminiscent of Haskell with algebraic data types and pattern matching.
Type constructors and effect names are uppercase while type variables are lowercase.
% The language also has parametric polymorphism over effect scopes.
% We will always explicitly show \ident{forall} for universally quantified effect scope variables.

\section{Effects, effect scopes and instances}
\label{section:basics}

\begin{figure}
\caption{Example of all the novel constructs}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
effect State {
	get : () -> Int
	put : Int -> ()
}

ref : forall s. Int -> (Inst s State)!{s}
ref [s] v =
	new State@s {
		get () k -> \st -> k st st
		put st' k -> \st -> k () st'
		return x -> \st -> return x
		finally f -> f v
	} as x in return x

postInc : forall s. Inst s State -> Int!{s}
postInc [s] inst =
	x <- inst#get();
	inst#put(x + 1);
	return x

result : Int
result =
	runscope(s1 ->
		r1 <- ref [s1] 10;
		runscope(s2 ->
			r2 <- ref [s2] 20;
			x <- postInc [s2] r2;
			r1#put(x);
			return x);
		y <- r1#get ();
		return y) -- result is 20
\end{minted}
\label{fig:example1}
\end{figure}

In Figure~\ref{fig:example1} we give an example containing all the novel constructs of X.

\subsection{Effects}

To start off we define a \ident{State} effect specialized to \ident{Int}s.
\ident{State} is meant to represent a mutable reference to a single value of type \ident{Int}.
This definition is exactly the same as the \ident{State} effect definition in Chapter~2.1, in the basic algebraic effects system.
With the \ident{effect} keyword we declare a new effect called \ident{State} with two operations: \ident{get} and \ident{put}.
For each operation we give parameter and return types. For \ident{get} we give the unit type \ident{()} as the parameter type.
As the return type we give \ident{Int}, meaning that calling the \ident{get} operation will return a integer value.
For the \ident{put} operation it is the other way around.
As the parameter type we have \ident{Int}, meaning that \ident{put} requires an integer value when called, and the return type is \ident{()}, calling \ident{put} will give back the unit value.

\subsection{Effect scopes}
In Figure~\ref{fig:example1} the function \ident{postInc} shows how an effect can actually be used.
We show the type of the function again for convenience:

\begin{minted}[tabsize=2]{haskell}
postInc : forall s. Inst s State -> Int!{s}
\end{minted}

This function takes an instance of the \ident{State} effect, called \ident{inst}, of type \ident{Inst s State}.
The type variable \ident{s} here is an \emph{effect scope variable}.
An effect scope variable can be seen as the name of a collection of instances that we call an effect scope.
Such a scope can contain zero or more instances, where each instance can be of any effect.
A scope restricts instances in such a way that they cannot escape that scope and instances from one scope cannot be used in another.
This also means that we can never get a runtime error because of an unhandled operation call.
The type of \ident{postInc} can be read as ``For any scope \ident{s}, given a \ident{State} instance in \ident{s}, return a value of type \ident{Int} possibly by calling operations on instances in \ident{s}''.
Note that because of the \ident{forall} we universally quantify over any scope \ident{s}, this means that \ident{postInc} does not choose a specific scope but that the functions can work on any scope.
The \ident{forall} is introduced by the \ident{[s]} syntax, which introduces an effect scope variable \ident{s}.
In order to call \ident{postInc} we have to explicitly give a specific effect scope for the parameter \ident{s}.
The return type of \ident{postInc} is \ident{Int}.
The \ident{!{s}} after the return type is the \emph{effect annotation}, which shows which scopes may be used by the function.

\subsection{Effect instances and handlers}
\label{subsection:instances}
Effects can be used by calling operations.
Operations are always called on an effect instance.
Without an instance we are unable to perform operations.
In the case of \ident{postInc} we get an instance as an argument to the function.
Operation can be called on an instance using the syntax \ident{instance\#operation(argument)}.
We write \ident{instance\#operation()} to mean \ident{instance\#operation(())}, when the unit value \ident{()} is given as the argument.
In the case of \ident{postInc} we first call the \ident{get} operation on \ident{inst}.
We get back a value of type \ident{Int}, which we name \ident{x}.
Then we call \ident{put} on \ident{inst} with the argument \ident{(x + 1)}.
Finally we return \ident{x}.

We can create a fresh instance of an effect using the \ident{new} keyword.
In Figure~\ref{fig:example1} we do this in the function \ident{callPostInc}:
\begin{minted}[tabsize=2]{haskell}
new State@s {
	get v k -> k 0
	put v k -> k ()
	return xr -> return xr
	finally xf -> return xf
} as inst in ...
\end{minted}
The construct \ident{new State@s { ... }} can be read as ``Create a fresh \ident{State} instance in the scope \ident{s}''.
Here we have to give a specific scope \ident{s} to create the instance on.
The instance can only be used within this given scope.
The newly-created instance is available in the body of the \ident{new} construct.
When creating an instance we have to give a \emph{handler}.
The handler specifies what should happen when the operations are called.
The handler is defined within curly braces and consists of a case for each operation of the effect, plus a \ident{return} case and a \ident{finally} case.
The handler given here is dummy handler which will always return \ident{0} when \ident{get} is called and which does nothing besides returning \ident{()} when \ident{put} is called.
Note that this is different from the system with dynamic instances from Chapter~2.3.
There we do not give a handler when creating instances, but handlers are a separate construct.
This change is needed in order to ensure the instances do not escape their scope.
Our type system will make sure that the handler given when creating an instance is \emph{complete}.
Meaning that all the operation calls on the specific instance are handled.
\\\\
In each operation case, \ident{get} and \ident{put} in the above example, we have access to two arguments.
The first variable, \ident{v} above, refers to the argument given when the operation was called.
The second variable, \ident{k} above, refers to the continuation of the operation call, this is the rest of the computation, after the operation call.
By calling \ident{k} with a value we can continue the computation at the point where the operation was called, at that point the program receives the value we give to the continuation \ident{k}.
In the example above we continue with \ident{0} every time \ident{get} on the instance \ident{inst} is called, and we continue with \ident{()} (without performing any other effects) whenever \ident{put} is called.
\\\\
The \ident{return} case gets called at the end of the computation \ident{e}.
The variable \ident{xr} contains the final value of the computation, which can be transformed in the case branch.
It is not required for the computation returned from the case to have the same type as \ident{xr}, and other operations are also allowed to be called.
Finally the \ident{finally} case is wrapped around the whole computation \ident{e} after the \ident{return} computation has been performed.
The variable \ident{xf} contains the transformed value returned from the \ident{return} case.
The finally case is useful in situations where we need to perform a final transformation on the return value of a computation.
We will make use of it when define mutable references in Section~3.2.

\subsection{Handling instances}
The definition \ident{result} shows how the effects in a computation can be performed.
We show its definition here again for convenience:

\begin{minted}[tabsize=2]{haskell}
result : Int
result = runscope(s' ->
	new State@s' {
		get v k -> k 0
		put v k -> k ()
		return xr -> return xr
		finally xf -> return xf
	} as inst in
	x <- postInc [s'] inst;
	return x)
\end{minted}

The \ident{runscope(s' -> ...)} construct provides a new scope, which we named \ident{s'} in our case, which can be used in its body.
Inside \ident{runscope} we can create and use instances in this new scope \ident{s'}.
\ident{runscope} will make sure that any instances that are created on its scope will actually be created and that any operation calls on these instances will be handled.
In the case of \ident{result} we create a new \ident{State} instance on \ident{s'} using the same handler as in Section~\ref{subsection:instances}.
We name this new instance \ident{inst}.
Then we call \ident{postInc}, passing \ident{s'} and the new instance as its arguments.
Finally we return the result of \ident{postInc} as the result of the \ident{handle} construct.
\\\\
Note that the type of \ident{result} does not have any effects, \ident{runscope} will use the handlers defined when creating instances to perform the operations called on the instances in its scope.
That means the result of \ident{runscope(s -> ...)} will not have any effects in \ident{s} (no operation calls on instances of \ident{s}).
\ident{runscope} will not perform any other effects beside the ones in its own scope, any other effects (on other scopes) will be forwarded through and will remain after \ident{runscope} is done.
For example:

\begin{minted}[tabsize=2]{haskell}
twoScopes : forall s''. Int!{s''}
twoScopes [s''] = runscope(s' ->
	x <- f [s'];
	y <- f [s''];
	...)
\end{minted}

Here we use some function \ident{f} on two different scopes (\ident{s'} and \ident{s''}) but we only handle one of the scopes (\ident{s'}).
We can also see this in the type, \ident{s'} does not appear while \ident{s''} does. 

\iffalse
\section{Mutable references}
\begin{figure}[h]
\caption{Mutable references}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
-- create a fresh reference initialized
-- with the integer value v
ref : forall s. Int -> (Inst s State)!{s}
ref [s] v =
	new State@s {
		get () k -> \st -> k st st
		put st' k -> \st -> k () st'
		return x -> \st -> return x
		finally f -> f v
	} as x in return x

result : Int
result = handle(s' ->
	r1 <- ref [s'] 0;
	r2 <- ref [s'] 42;
	x <- r1#get();
	y <- r2#get();
	r1#put(y);
	r2#put(x)
	r1#get())
-- result is 42
\end{minted}
\label{fig:references}
\end{figure}

Using the constructs explained in Section~\ref{section:basics} we can now implement mutable references.
We can create a new mutable reference initialized with some integer using the \ident{ref} function shown in Figure~\ref{fig:references}.
\ident{ref} takes an effect scope and an integer and returns a new \ident{State} instance.
The handler given in \ident{ref} defines the usual semantics for a mutable reference. 
The \ident{get} operation returns the current value of the reference and \ident{put} updates the value of the reference.
We implement the operations using a technique called \emph{parameter-passing}\cite{algtutorial}.
We transform the computation to a function that takes the value of the reference.
 For \ident{get} we return a function that takes the value of the state (\ident{st}) and passes this value to the continuation, which will give us back another function that expects the state value. We give this function the same state value as we are given, since \ident{get} does not change the state.
 For \ident{put} we ignore the given state value and call the continuation with the unit value.
 Again we get another function back from the continuation, which expects the state value.
 We call this function with the argument of \ident{put} (\ident{st'}), since that is the new value of the state.
 In the case of \ident{return} we simple ignore the state value (\ident{st}) and return the final value of the computation: \ident{x}.
 We could also have chosen to return the state value instead or both the state value and the final computation value.
 Now we end up with a function that expects the initial value of the state as the parameter \ident{f} in the \ident{finally} case.
 We run the actual computation by calling this function with the \ident{v} argument of \ident{ref}.
 At the end of \ident{ref} we simply return the newly created instance as the result of the function.
\\\\
\ident{result} shows how \ident{ref} can be used.
Inside \ident{result} we first create two mutable references, \ident{r1} and \ident{r2}, initialized with \ident{0} and \ident{42} respectively.
Then we retrieve the values from \ident{r1} and \ident{r2} and store these in the variables \ident{x} and \ident{y}.
We then put the value of \ident{r2} in \ident{r1} and the value of \ident{r1} in \ident{r2}.
Finally we return the current value of \ident{r1}, which will be \ident{42}.
The whole computation is wrapped in \ident{runscope(s' ->} to actually perform the effects, resulting in \ident{42} without any remaining effects.
\\\\
Using \ident{ref} we can fully emulate multiple mutable references.
We have the added guarantee that the references will not escape their effect scope, they will not escape their corresponding \ident{runscope}.
Adding parametric polymorphism to the effects to give \ident{State t} for any type \ident{t} will enable us to emulate references of any type.
With references of different types coexisting.
This is very similar to how the ST monad works in Haskell~\cite{runst}.
Using mutable references have interesting applications such as meta variables in type inference algorithms and typed logic variables~\cite{typedlogic}.
\fi

\section{Mutable vectors}
\begin{figure}[h]
\caption{Mutable vectors}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
-- list of mutable references
data Vector s = VNil | VCons (Inst s State) Vector

-- get the length of a vector
vlength : forall s. Vector s -> Int
vlength VNil = 0
vlength (VCons _ tail) = 1 + (vlength tail)

-- get the value at the index given as the first argument
-- assumes the index is within range of the vector
vget : forall s. Int -> Vector s -> Int!{s}
vget [s] 0 (VCons h _) = h#get()
vget [s] n (VCons _ t) = vget [s] (n - 1) t

-- set the value at the index given as the first argument
-- to the value given as the second argument
-- assumes the index is within range of the vector
vset : forall s. Int -> Int -> Vector s -> ()!{s}
vset [s] 0 v (VCons h _) = h#put(v)
vset [s] n v (VCons _ t) = vset [s] (n - 1) v t
\end{minted}
\label{fig:vectors}
\end{figure}

In the previous section we have defined mutable references.
We will now build on them to define mutable vectors.
In Figure~\ref{fig:vectors} we define the \ident{Vector} datatype.
\ident{Vector} is a linked list of \ident{State} instances and is indexed by the scope of instances: \ident{s}.
We define two functions on \ident{Vector}, \ident{vget} and \ident{vset}.
With \ident{vget} we can retrieve a value from a vector by giving an index.
We assume the index is within the range of the vector.
With \ident{vset} we can set an element of a vector by giving an index and a value.
Again we assume the index is within the range of the vector.
In order to allow these functions to work for any vector we have to introduce an effect scope variable \ident{s} again.
We define both functions by recursion on the index.
\\\\
As an example application we will write a shuffling algorithm for vectors.
This simple algorithm will shuffle a vector by randomly swapping two random elements of the vector and repeating this some amount of times.
In Figure~\ref{fig:shuffle} we show the algorithm.
First we define an effect \ident{Rng} in order to abstract out the generation random numbers.
\ident{Rng} has a single operation \ident{rand} which returns a random integer between \ident{0} and \ident{n} given an integer \ident{n}.
We define a function \ident{vlength} to get the length of the vector.
\\\\
We then define the actually shuffling function \ident{shuffleVector}.
This function takes two scope variables, \ident{s} and \ident{s'}, for the vector and \ident{Rng} instance respectively.
As arguments we take an instance of \ident{Rng}, in order to generate random numbers, an integer, for the amount of times to shuffle, and the vector we want to shuffle.
By taking a seperate scope for the \ident{Rng} instance we are more flexible when handling the computation.
We can handle the effects on the vector while leaving the \ident{Rng} effects to be handled higher up.
\\\\
\ident{shuffleVector} proceeds as follows.
If the amount of times we want to shuffle is \ident{0} we stop and return the vector.
If not then we first get the length of the vector.
Then we generate two random numbers, \ident{i} and \ident{j}, between \ident{0} and this length.
These two numbers will be the two elements we will swap.
We then get the current values at these indeces.
And we swap the values at these indeces in the vector.
We then recurse, subtracting the amount of times to shuffle by one.

\begin{figure}[H]
\caption{Vector shuffling}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
-- random number generation effect
-- the operation `rand` gives back a random integer
-- between 0..n, where n is the argument given (exclusive)
effect Rng {
	rand : Int -> Int
}

-- shuffles a vector given an instance of Rng
-- by swapping two random elements of the vector
-- the second argument to shuffleVector is the amount of times
-- to swap elements
shuffleVector : forall s s'. Inst s' Rng -> Int
	-> Vector s -> ()!{s, s'}
shuffleVector [s] [s'] _ 0 vec = vec
shuffleVector [s] [s'] rng n vec =
	let len = vlength vec;
	i <- rng#rand(len);
	j <- rng#rand(len);
	a <- vget [s] i vec;
	b <- vget [s] j vec;
	vset [s] i b vec;
	vset [s] j a vec;
	shuffleVector [s] [s'] rng (n - 1) vec
\end{minted}
\label{fig:shuffle}
\end{figure}

Using \ident{shuffleVector} we can implement a function to shuffle a list in Figure~\ref{fig:listshuffle}.
We first define the usual \ident{List} datatype, with \ident{Nil} and \ident{Cons} cases.
Then we define two functions \ident{toVector} and \ident{toList} to convert between lists and vectors.
\ident{toVector} simply recurses on the list and creates fresh variables for each element of the list, initialized with the value of the element.
\ident{toList} converts a vector to a list by getting the current values of each reference in the vector.
The function \ident{shuffle} implements the actual shuffling.
It takes an effect scope, a \ident{Rng} instance \ident{rng} in this scope and a list \ident{lst}.
We first convert the list to a mutable vector.
Then we use \ident{shuffleVector} to shuffle the vector 100 times, passing \ident{rng} for generating the random numbers.
Finally we convert the vector back to a list and return this result.
We wrap this computation in \ident{runscope} to handle the effects of the mutable vector.
The use of mutable vectors is not leaked outside of the function, from the type and behaviour of \ident{shuffleVector} we are unable to find out if mutable vectors are used.
We say that the use of the \ident{State} effect is completely \emph{encapsulated}.
The type system ensures that \ident{runscope} actually does encapsulate all effects in its scope.
Note that we do not handle the scope of \ident{rng}, we leave the \ident{Rng} to be handled higher up by the caller of \ident{shuffle}.

\begin{figure}[h]
\caption{List shuffling}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
-- (linked) list of integer values
data List = Nil | Cons Int List

-- transform a list to a vector by replacing each value
-- in the list by a reference initialized with that value
toVector : forall s. List -> (Vector s)!{s}
toVector [s] Nil = VNil
toVector [s] (Cons h t) =
	h' <- ref [s] h;
	t' <- toVector [s] t;
	return (VCons h' t')

-- transform a vector back to a list by getting the
-- current values from the references in the vector
toList : forall s. Vector s -> List!{s}
toList [s] VNil = Nil
toList [s] (VCons h t) =
	h' <- h#get();
	t' <- toList [s] t;
	return (Const h' t')

-- shuffles a list given an instance of Rng
-- by converting it to a vector
-- and shuffling 100 times
shuffle : forall s'. Inst s' Rng -> List -> List!{s'}
shuffle [s'] rng lst =
	runscope(s ->
		let vec = toVector [s] lst;
		shuffleVector [s] [s'] rng 100 vec;
		return (toList vec))
\end{minted}
\label{fig:listshuffle}
\end{figure}

\section{Local effects}
When writing higher-order functions it's important that effects used in the function definition does not interfere with the function given as an argument.
This means we want to have \emph{local effects} in those functions.
Effects which do not leak outside of the functions and which do not interfere with any other effects used.
Using effect instances we can generate effects which are local and unique.
\\\\
In Figure~\ref{fig:localeffects} we 

\begin{figure}[h]
\caption{Folding with early exit}
\begin{minted}[tabsize=2,frame=single,linenos]{haskell}
-- folding with early exit
effect Done {
	done : Bool -> ()
}

-- foldr creates a new instance of Done
-- and passes this to the reducer function
-- if done is called on the instance
-- then foldr stops and returns the value given
-- note: nested uses of foldr do not interfere because
-- new instances are created with each call
foldr : (forall s. Inst s Done -> Int -> Bool -> Bool!{s}) ->
	Bool -> List -> Bool
foldr fn initial list =
	runscope(s ->
		new Done@s {
			done v k -> return v
			return x -> return x
		} as inst in
		foldrRec [s] (fn [s] inst) initial list)

-- recursive foldr implementation
foldrRec : forall s. (Int -> Bool -> Bool!{s}) ->
	Bool -> List -> Bool!{s}
foldRec fn initial Nil = initial
foldRec fn initial (Cons h t) = fn h (foldRec fn initial t)

-- does the list have any element satifying
-- the predicate function
-- returns early if the predicate function returns True
contains : (Int -> Bool) -> List -> Bool
contains fn list =
	let result = foldr (\inst h _ ->
		if fn h then
			inst#done(True)
		else
			False
	) False list
\end{minted}
\label{fig:localeffects}
\end{figure}
