{
% types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\thandler[2]{#1 \Rightarrow #2}
\newcommand\tforall[3]{\forall(#1:#2) . #3}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}
\newcommand\texists[3]{\exists(#1:#2) . #3}
\newcommand\texistss[2]{\exists \overrightarrow{#1} . #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[3]{\Lambda(#1:#2) . #3}
\newcommand\vabs[2]{\lambda #1 . #2}
\newcommand\vappt[2]{#1 \; [ #2 ]}
\newcommand\vhandler[1]{\textit{handler} \; \{#1\}}
\newcommand\vhandleri[2]{\textit{handler} ( #1 ) \; \{#2\}}
\newcommand\vhandlerc[0]{\vhandler{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}
\newcommand\vhandlerci[1]{\vhandleri{#1}{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\textit{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cdo[3]{#1 \leftarrow #2 ; #3}
\newcommand\cop[4]{#1(#2 ; #3 . #4)}
\newcommand\copi[5]{#1 \# #2(#3 ; #4 . #5)}
\newcommand\chandle[2]{\textit{with} \; #1 \; \textit{handle} \; #2}
\newcommand\cnew[1]{\textit{new} \; #1}
\newcommand\cunpack[4]{(#1, #2) \leftarrow #3 ; #4}

In this chapter we will show the basics of algebraic effects and handlers. We will start with the simply-typed lambda calculus and add algebraic effects and instances to it. We end with dynamic instances and show why a type system for them is difficult to implement.

\section{Fine-grained simply-typed lambda calculus}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Why fine-grained
	\begin{itemize}
		\item effects require precise order of evaluation
		\item fine-grain is explicit on order of evaluation
		\item evaluation only happens in computations
	\end{itemize}
	\item difference between values and computations
	\item subsume call-by-value and call-by-name (by using thunks)
\end{itemize}

\subsection{Syntax}
\begin{align*}
	\val \Coloneqq	&													\tag{values} \\
									& x, y, z, k							\tag{variables} \\
									& \vunit									\tag{unit value} \\
									& \vabs{x}{\comp}					\tag{abstraction} \\
	\comp \Coloneqq&													\tag{computations} \\
									& \creturn{\val}					\tag{return value as computation} \\
									& \capp{\val}{\val}				\tag{application} \\
									& \cdo{x}{\comp}{\comp}		\tag{sequencing} \\
\end{align*}

\subsection{Semantics}
\[\frac{
}{
	\capp{(\vabs{x}{\comp})}{\val} \rightsquigarrow \comp[x := \val]
}\]

\[\frac{
}{
	\cdo{x}{\creturn{\val}}{\comp} \rightsquigarrow \comp[x := \val]
}\]

\[\frac{
	\comp_1 \rightsquigarrow \comp_1'
}{
	\cdo{x}{\comp_1}{\comp_2} \rightsquigarrow \cdo{x}{\comp_1'}{\comp_2}
}\]

\subsection{Type system}
value types and computation types\\
\begin{align*}
	\ty \Coloneqq 	& 												\tag{value types} \\
									& \tunit									\tag{unit type} \\
									& \tarr{\ty}{\cty}				\tag{type of functions} \\
	\cty \Coloneqq 	& 												\tag{computation types} \\
									& \ty											\tag{value type} \\
\end{align*}

\[\frac{
	\Gamma[x] = \ty
}{
	\Gamma \vdash x : \ty
}\]

\[\frac{
}{
	\Gamma \vdash \vunit : \tunit
}\]

\[\frac{
	\Gamma, x : \ty_1 \vdash \comp : \ty_2
}{
	\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\ty_2}
}\]

\[\frac{
	\Gamma \vdash \val : \ty
}{
	\Gamma \vdash \creturn{\val} : \ty
}\]

\[\frac{
	\begin{array}{l}
	\Gamma \vdash \val_1 : \tarr{\ty_1}{\ty_2}\\
	\Gamma \vdash \val_2 : \ty_1
	\end{array}
}{
	\Gamma \vdash \capp{\val_1}{\val_2} : \ty_2
}\]

\[\frac{
	\begin{array}{l}
	\Gamma \vdash \comp_1 : \ty_1\\
	\Gamma, x : \ty_1 \vdash \comp_2 : \ty_2
	\end{array}
}{
	\Gamma \vdash \cdo{x}{\comp_1}{\comp_2} : \ty_2
}\]

\subsection{Examples}
Show explicit order of evaluation.
Same application with different orders of evaluation.\\
$\capp{\capp{f}{x}}{y}$ translated to fine-grained:\\
Left-to-right call-by-value:\\
$\cdo{x'}{x}{\cdo{y'}{y}{\cdo{g}{\capp{f}{x'}}{\capp{g}{y'}}}} $\\
Right-to-left call-by-value:\\
$\cdo{y'}{y}{\cdo{x'}{x}{\cdo{g}{\capp{f}{x'}}{\capp{g}{y'}}}} $\\
Left-to-right call-by-value, apply f before evaluating y:\\
$\cdo{x'}{x}{\cdo{g}{\capp{f}{x'}}{\cdo{y'}{y}{\capp{g}{y'}}}} $\\
Call-by-name:\\
$\cdo{g}{\capp{f}{(\vabs{\_}{x})}}{\capp{g}{(\vabs{\_}{y})}}$

\newpage
\section{Algebraic effects}

\subsection{Intro}
Explain:
\begin{itemize}
	\item What are algebraic effects and handlers
	\item Why algebraic effects
	\begin{itemize}
		\item easy to use
		\item can express often used monads
		\item composable
		\item always commuting
		\item modular (split between computations and handlers)
	\end{itemize}
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type system}

\subsection{Examples}
Show flip (non-determinism) and state examples.

\newpage
\section{Static instances}

\textit{Should I even mention static instances?}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show problems with wanting to use multiple state instances
	\item What are static instances
	\item Show that static instances partially solve the problem
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type system}

\subsection{Examples}
Show state with multiple static instances (references).

\newpage
\section{Dynamic instances (untyped)}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show that static instances require pre-defining all instances on the top-level.
	\item Static instances not sufficient to implement references.
	\item Show that dynamic instances are required to truly implement references.
	\item Show more uses of dynamic instances (file system stuff, local exceptions)
	\item No type system yet.
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Examples}
Show untyped examples.
\begin{itemize}
	\item Local exceptions
	\item ML-style references
\end{itemize}

\subsection{Type system (discussion, problems)}
Show difficulty of implementing a type system for this.
}