{
% types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\thandler[2]{#1 \Rightarrow #2}
\newcommand\tforall[3]{\forall(#1:#2) . #3}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}
\newcommand\texists[3]{\exists(#1:#2) . #3}
\newcommand\texistss[2]{\exists \overrightarrow{#1} . #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[3]{\Lambda(#1:#2) . #3}
\newcommand\vabs[2]{\lambda #1 . #2}
\newcommand\vappt[2]{#1 \; [ #2 ]}
\newcommand\vhandler[1]{\textit{handler} \; \{#1\}}
\newcommand\vhandleri[2]{\textit{handler} ( #1 ) \; \{#2\}}
\newcommand\vhandlerc[0]{\vhandler{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}
\newcommand\vhandlerci[1]{\vhandleri{#1}{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cdo[3]{#1 \leftarrow #2 ; #3}
\newcommand\cop[4]{#1(#2 ; #3 . #4)}
\newcommand\copi[5]{#1 \# #2(#3 ; #4 . #5)}
\newcommand\chandle[2]{\textit{with} \; #1 \; \textit{handle} \; #2}
\newcommand\cnew[1]{\textit{new} \; #1}
\newcommand\cunpack[4]{(#1, #2) \leftarrow #3 ; #4}

In this chapter we will show the basics of algebraic effects and handlers. We will start with the simply-typed lambda calculus and add algebraic effects and instances to it. We end with dynamic instances and show why a type system for them is difficult to implement.

\section{Fine-grained simply-typed lambda calculus}

As our base language we will take the fine-grained (call-by-value) simply-typed lambda calculus \cite{fg-stlc}.
This system is a version of the simply-typed lambda calculus where the order of evaluation is made explicit in the syntax.
Furthermore there is a syntactic distinction between values and computation.
In an effect-full system such as effect handlers it is useful to have a clear order of evaluation since different orderings of effects can have different results.

%\subsection{Syntax}

\begin{figure}
\caption{Syntax of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{10 cm}
\begin{align*}
	\val \Coloneqq	&													\tag{values} \\
									& x, y, z, k							\tag{variables} \\
									& \vunit									\tag{unit value} \\
									& \vabs{x}{\comp}					\tag{abstraction} \\
	\comp \Coloneqq&													\tag{computations} \\
									& \creturn{\val}					\tag{return value as computation} \\
									& \capp{\val}{\val}				\tag{application} \\
									& \cdo{x}{\comp}{\comp}		\tag{sequencing} \\
\end{align*}
\label{fig:syntax-stlc}
\end{minipage}
}
\end{figure}

The terms are shown in Figure \ref{fig:syntax-stlc}.
The terms are split in to values and computations.
Values denote data which does not do any computation, while the computations are terms that may perform effects.

\textbf{Values} We have $x$, $y$, $z$, $k$ ranging over variables, where we will use $k$ to denote continuations later on.
We also have $\vunit$ as our only base value. Lastly $\vabs{x}{\comp}$ is an lambda abstraction, where the body of the function is a computation.
\\\\
\textbf{Computations} For computations we have $\creturn{\val}$ for the computation that simply returns a value without performing any effects. We have function application $\capp{\val}{\val}$, where both the function and argument have to be values. Sequencing computations is done with $\cdo{x}{\comp}{\comp}$.

%\subsection{Semantics}

\begin{figure}
\caption{Semantics of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{11 cm}
\[\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \rightsquigarrow \comp[x := \val]
}\quad(\textsc{STLC-S-App})\]

\[\inferrule{
}{
	(\cdo{x}{\creturn{\val}}{\comp}) \rightsquigarrow \comp[x := \val]
}\quad(\textsc{STLC-S-SeqReturn})\]

\[\inferrule{
	\comp_1 \rightsquigarrow \comp_1'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \rightsquigarrow (\cdo{x}{\comp_1'}{\comp_2})
}\quad(\textsc{STLC-S-Seq})\]
\label{fig:semantics-stlc}
\end{minipage}
}
\end{figure}

The small-step operation semantics are shown in Figure \ref{fig:semantics-stlc}.
The relation $\rightsquigarrow$ is defined on computations, where the $\comp \rightsquigarrow \comp'$ means $\comp$ reduces to $\comp'$ in one step.
These rules are a fine-grained approach to the standard reduction rules of the simply-typed lambda calculus.
In \textsc{STLC-S-App} we apply a lambda abstraction to a value argument, by substituting the value for the variable $x$ in the body of the abstraction.
In \textsc{STLC-S-SeqReturn} we sequence a computation that just returns a value in another computation by substituting the value for the variable $x$ in the computation.
Lastly, in \textsc{STLC-S-Seq} we can reduce a sequence of two computations, $\comp_1$ and $\comp_2$ by reducing the first, $\comp_1$.

%\subsection{Type system}

\begin{figure}
\caption{Types of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
	\ty \Coloneqq 	& 												\tag{value types} \\
									& \tunit									\tag{unit type} \\
									& \tarr{\ty}{\cty}				\tag{type of functions} \\
	\cty \Coloneqq 	& 												\tag{computation types} \\
									& \ty											\tag{value type} \\
\end{align*}
\label{fig:types-stlc}
\end{minipage}
}
\end{figure}

Next we give the types in Figure \ref{fig:types-stlc}.
Similar to the terms we split the types in to value and computation types.
Values are typed by value types and computation are typed by computation types.
A value type is either the unit type or a function type with a value type as argument type and a computation type as return type.\\
For the simply-typed lambda calculus a computation type is simply a value type, when we add algebraic effects computation types will become more meaningful by recording the effects a computation may use.

\begin{figure}
\caption{Typing rules of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{14 cm}
$$\inferrule{
	\Gamma[x] = \ty
}{
	\Gamma \vdash x : \ty
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
}{
	\Gamma \vdash \vunit : \tunit
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \ty_2
}{
	\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\ty_2}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Gamma \vdash \val : \ty
}{
	\Gamma \vdash \creturn{\val} : \ty
}$$

$$\inferrule{
	\Gamma \vdash \val_1 : \tarr{\ty_1}{\ty_2}\\
	\Gamma \vdash \val_2 : \ty_1
}{
	\Gamma \vdash \capp{\val_1}{\val_2} : \ty_2
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Gamma \vdash \comp_1 : \ty_1\\
	\Gamma, x : \ty_1 \vdash \comp_2 : \ty_2
}{
	\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \ty_2
}$$
\label{fig:typing-stlc}
\end{minipage}
}
\end{figure}

Finally we give the typing rules in Figure \ref{fig:typing-stlc}.
We have a typing judgments for values $\Gamma \vdash \val : \ty$ and a typing judgment for computations $\Gamma \vdash \comp : \cty$.
In both these judgments the context $\Gamma$ assign (value types) to variables.\\
The rules for variables, unit, abstractions and applications are the standard typing rules of the simply-typed lambda calculus.
For $\creturn{\val}$ we simply check the type of $\val$.
For the sequencing of two computations $\comp_1$ and $\comp_2$ we first check the type of $\comp_1$ and then check $\comp_2$ with the type of $\comp_1$ added to the context.

% \subsection{Examples}

To show the explicit order of evaluation we will translate the following program from the simply-typed lambda calculus to its fine-grained version:\\
$\capp{\capp{f}{x}}{y}$\\
Here we have a choice of whether to first evaluate $x$ of $y$ and whether to evaluate $(\capp{f}{x})$ before evaluating $y$.
In the fine-grained system this choice is made explicit by the sequencing of computations.
As such we can write down three variants for the above program, each having a different evaluation order.
In the presence of effects all three may have different results.

$x$ before $y$, $y$ before $(\capp{f}{x})$: \\\indent
$\cdo{x'}{x}{\cdo{y'}{y}{\cdo{g}{(\capp{f}{x'})}{(\capp{g}{y'})}}} $\\
$y$ before $x$, $y$ before $(\capp{f}{x})$:\\\indent
$\cdo{y'}{y}{\cdo{x'}{x}{\cdo{g}{(\capp{f}{x'})}{(\capp{g}{y'})}}} $\\
$x$ before $y$, $y$ before $(\capp{f}{x})$:\\\indent
$\cdo{x'}{x}{\cdo{g}{(\capp{f}{x'})}{\cdo{y'}{y}{(\capp{g}{y'})}}} $\\

\newpage
\section{Algebraic effects}

\subsection{Intro}
Explain:
\begin{itemize}
	\item What are algebraic effects and handlers
	\item Why algebraic effects
	\begin{itemize}
		\item easy to use
		\item can express often used monads
		\item composable
		\item always commuting
		\item modular (split between computations and handlers)
	\end{itemize}
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type system}

\subsection{Examples}
Show flip (non-determinism) and state examples.

\newpage
\section{Static instances}

\textit{Should I even mention static instances?}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show problems with wanting to use multiple state instances
	\item What are static instances
	\item Show that static instances partially solve the problem
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Type system}

\subsection{Examples}
Show state with multiple static instances (references).

\newpage
\section{Dynamic instances (untyped)}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show that static instances require pre-defining all instances on the top-level.
	\item Static instances not sufficient to implement references.
	\item Show that dynamic instances are required to truly implement references.
	\item Show more uses of dynamic instances (file system stuff, local exceptions)
	\item No type system yet.
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Examples}
Show untyped examples.
\begin{itemize}
	\item Local exceptions
	\item ML-style references
\end{itemize}

\subsection{Type system (discussion, problems)}
Show difficulty of implementing a type system for this.
}