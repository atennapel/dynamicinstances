{
\newcommand\ident[1]{\mintinline{haskell}{#1}}

Algebraic effects and handlers is a structured way to introduce side-effects to a programming language.
The basic idea is that side-effects can be described by sets of operations, called the interface of the effect.
Similar to exceptions, where exceptions can be thrown and caught.
Operations can be called and ``caught'' by handlers.
Different from exceptions however the handler also has access to a continuation which can be used to continue the computation at the point where the operation was called.
\\\\
In this chapter we will introduce Algebraic effects and handlers through examples.
Starting with simple algebraic effects and handlers (\cref{section:background-algeff}). After we will continue with static instances (\cref{section:background-staticinst}) and ending with dynamic instances (\cref{section:background-dynamicinst}). The examples are written in an hypothetical functional programming language with algebraic effects and handlers with syntax similar to the Haskell programming language.

\section{Algebraic effects and handlers} \label{section:background-algeff}
We will start with the familiar exceptions. We define an \ident{Exc} effect interface with a single operation \ident{throw}.

\begin{minted}[tabsize=2]{haskell}
effect Exc {
	throw : String -> Void
}
\end{minted}

For each operation in an effect definition we specify a parameter type (on the left of the arrow) and a return type (on the right of the arrow). In the case of \ident{throw} the parameter type is a \ident{String} (an error message) and the return type is \ident{Void}, a type without any inhabitants.
\\\\
We can now write functions that use the \ident{Exc} effect.
For example the following function \ident{safeDiv} which will throw an error if the right argument is $0$.
We assume here that \ident{Void} is equal to any type.

\begin{minted}[tabsize=2]{haskell}
safeDiv : Int -> Int -> Int!{Exc}
safeDiv a b =
	if b == 0 then
		throw "division by zero!"
	else
		return a / b
\end{minted}

We can call this function like any other function, but no computation will actually be performed.
The effect will remain abstract, we still need to give them a semantics.

\begin{minted}[tabsize=2]{haskell}
result : Int!{Exc}
result = 10 / 0
\end{minted}

In order to actually ``run'' the effect we will need to handle the operations of that effect.
For example, for \ident{Exc} we can write a handler that returns $0$ as a default value if an exception is thrown.

\begin{minted}[tabsize=2]{haskell}
result : Int
result = handle {
	throw err k -> return 0
	return v -> return v
} (10 / 0) -- results in 0
\end{minted}

For each operation we write a corresponding case in the handler, where we have access to the argument given at operation call and a continuation, which expects a value of the return type of the operation.
There is also a case for values \ident{return}, which gets as an argument the final value of a computation and has the opportunity to modify this value or to do some final computation.
In this case we simply ignore the continuation and exit the computation early with a $0$, we also return any values without modification.
\\\\
We can give multiple ways of handling the same effect.
For example we can also handle the \ident{Exc} effect by capturing the failure or success in a sum type \ident{Either}.

\begin{minted}[tabsize=2]{haskell}
data Either a b = Left a | Right b

result : Either String Int
result = handle {
	throw err k -> return (Left err)
	return v -> return (Right v)
} (10 / 0) -- results in (Left "division by zero!")
\end{minted}

Here we return early with \ident{Left err} if an error is thrown, otherwise we wrap the resulting value using the \ident{Right} constructor.
\\\\
Another effect we might be interested in is non-determinism.
To model this we define the \ident{Flip} effect interface which has a single operation \ident{flip}, which returns a boolean when called with the unit value.

\begin{minted}[tabsize=2]{haskell}
effect Flip {
	flip : () -> Bool
}
\end{minted}

Using the \ident{flip} operation and if-expression we can write non-deterministic computations that can be seen as computation trees where \ident{flip} branches the tree off in to two subtrees.
The following program \ident{choose123} non-deterministically returns either a $1$, $2$ or $3$.

\begin{minted}[tabsize=2]{haskell}
choose123 : () -> Bool!{Flip}
choose123 () =
	b1 <- flip ();
	if b1 then
		return 1
	else
		b2 <- flip ();
		if b2 then
			return 2
		else
			return 3
\end{minted}

Here the syntax \ident{(x <- c1; c2)} sequences the computations \ident{c1} and \ident{c2} by first performing \ident{c1} and then performing \ident{c2}, where the return value of \ident{c1} can accessed in \ident{x}.
\\\\
Again \ident{choose123} does not actually perform any computation when called, because we have yet to give it a semantics.
We could always return \ident{True} when a \ident{flip} operation is called, in the case of \ident{choose123} this will result in the first branch being picked returning $1$ as the answer.

\begin{minted}[tabsize=2]{haskell}
result : Int
result = handle {
	flip () k -> k True
	return v -> return v
} (choose123 ()) -- returns 1
\end{minted}

Another handler could try all branches returning the greatest integer of all possibilities.

\begin{minted}[tabsize=2]{haskell}
maxresult : Int
maxresult = handle {
	flip () k ->
		vtrue <- k True;
		vfalse <- k False;
		return (max vtrue vfalse)
	return v -> return v
} (choose123 ()) -- returns 3
\end{minted}

Here we first call the continuation \ident{k} with \ident{True} and then with \ident{False}.
The we return the maximum between those results.
\\\\
We could even collect the values from all branches by returning a list.
\begin{minted}[tabsize=2]{haskell}
allvalues : List Int
allvalues = handle {
	flip () k ->
		vtrue <- k True;
		vfalse <- k False;
		return vtrue ++ vfalse
	return v -> return [v]
} (choose123 ()) -- returns [1, 2, 3]
\end{minted}

Again we call the continuation \ident{k} twice, but we append the two results instead.
For the \ident{return} base case we simply wrap the value in a singleton list.
\\\\
Algebraic effects have the nice property that they combine easily.
For example by combining the \ident{Exc} and \ident{Flip} we can implement backtracking, where the choose the first non-failing branch from a computation. For example we can write a function which returns all even sums of the numbers $1$ to $3$ by reusing \ident{choose123}.

\begin{minted}[tabsize=2]{haskell}
evensums123 : Int!{Flip, Exc}
evensums123 () =
	n1 <- choose123 ();
	n2 <- choose123 ();
	sum <- return (n1 + n2);
	if sum % 2 == 0 then
		return sum
	else
		throw "not even!"
\end{minted}

We implement backtracking in \ident{backtrack} by handling both the \ident{flip} and \ident{throw} operations. For \ident{flip} and the \ident{return} case we do the same as in \ident{allvalues}, calling the continuation \ident{k} with both \ident{True} and \ident{False} and appending the results together. For \ident{throw} we ignore the error message and continuation and exit early with the empty list, this means that branches that results in a failure will not actually return any values.

\begin{minted}[tabsize=2]{haskell}
backtrack : List Int
backtrack () = handle {
	flip () k ->
		vtrue <- k True;
		vfalse <- k False;
		return vtrue ++ vfalse
	throw msg k -> return []
	return v -> return [v]
} (evensums123 ()) -- returns [2, 4, 4, 6]
\end{minted}

We can also handle the effects independently of each other. For example we could implement a partial version of \ident{backtrack} that only handles the \ident{Flip} effect. Any operation that is not in the handler is just passed through.

\begin{minted}[tabsize=2]{haskell}
partlybacktrack : (List Int)!{Exc}
partlybacktrack () = handle {
	flip () k ->
		vtrue <- k True;
		vfalse <- k False;
		return vtrue ++ vfalse
	return v -> return [v]
} (evensums123 ())
\end{minted}

Now we can factor out the \ident{throw} handler into its own function.

\begin{minted}[tabsize=2]{haskell}
fullbacktrack : List Int
fullbacktrack () = handle {
	throw msg k -> return []
	return v -> return v
} (partlybacktrack ()) -- returns [2, 4, 4, 6]
\end{minted}

Algebraic effects always commute, meaning the effects can be handled in any order.
In the backtracking example the order of the handlers does not actually matter, but in general different orders could have different results.
\\\\
Lastly we introduce the \ident{State} effect, which allows us to implement local mutable state.
We restrict ourselves to a state that consists of a single integer value, but in a language with parametric polymorphism a more general state effect could be written.

\begin{minted}[tabsize=2]{haskell}
effect State {
	get : () -> Int
	put : Int -> ()
}
\end{minted}

Our state effect has two operations, \ident{get} and \ident{put}.
The \ident{get} operation allows us to retrieve a value from the state and with the \ident{put} operation we can change the value in the state.
\\\\
We can now implement the familiar ``post increment'' operation as seen in the C programming language.
This function retrieves the current value of the state, increments it by $1$ and returns the previously retrieved value.

\begin{minted}[tabsize=2]{haskell}
postInc : () -> Int!{State}
postInc () =
	x <- get ();
	put (x + 1);
	return x
\end{minted}

To implement the semantics of the \ident{State} effect we use parameter-passing similar to how the State monad is implemented in Haskell. We will abstract the implementation of the state handler in a function \ident{runState}.

\begin{minted}[tabsize=2]{haskell}
runState : (() -> Int!{State}) -> (Int -> (Int, Int))
runState comp = handle {
	get () k -> return (\s -> (f <- k s; return f s))
	put v k -> return (\s -> (f <- k (); return f v))
	return v -> return (\s -> return (s, v))
} (comp ())
\end{minted}

\ident{runState} takes as it's only argument a computation that returns an integer and may use the \ident{State} effect.
To delay the computation we take it as a function from unit.
\ident{runState} returns a function that takes the initial value of the state and returns a tuple of the final state and the return value of the computation.
Let us take a look at the \ident{return} case first, here we return a function that takes a state value and returns a tuple of this state and the return value.
For the \ident{get} case we return a function that takes a state value and runs the continuation \ident{k} with this value, giving access to the state at the point where the \ident{get} operation was called. From this continuation we get back another function, which we call with the current state, continuing the computation without changing the state.
The \ident{put} case is similar to the \ident{get} but we call the continuation with the unit value and we continue the computation by calling \ident{f} with the value giving with the \ident{put} operation call.
\\\\
Using state now is as simple as calling \ident{runState}.

\begin{minted}[tabsize=2]{haskell}
stateResult : () -> (Int, Int)
stateResult () =
	f <- runState postInc; -- returns a function taking the initial state
	f 42 -- post-increments 42 returning (43, 42)
\end{minted}

Using the state effect we can implement imperative algorithms such as summing a range of numbers.
We first implement a recursive function \ident{sumRangeRec} which uses \ident{State} to keep a running sum.
After we define \ident{sumRange} which calls \ident{sumRangeRec} and runs the \ident{State} effect with $0$ as the initial value.

\begin{minted}[tabsize=2]{haskell}
sumRangeRec : Int -> Int -> Int!{State}
sumRangeRec a b =
	if a > b then
		(_, result) <- get ();
		return result
	else
		x <- get ();
		put (x + a);
		sumRangeRec (a + 1) b
		
sumRange : Int -> Int -> Int
sumRange a b =
	f <- runState (\() -> sumRangeRec a b);
	f 0 -- initial sum value is 0
\end{minted}

\section{Static instances} \label{section:background-staticinst}

% global state references

\section{Dynamic instances} \label{section:background-dynamicinst}

% full mutable references



}