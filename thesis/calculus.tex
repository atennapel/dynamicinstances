{

\def\msquare{\mathord{\scalerel*{\Box}{gX}}}

% effects
\newcommand\Eff[0]{E}
\newcommand\eff[0]{\varepsilon}
\newcommand\Op[1]{O^{#1}}
\newcommand\op[0]{op}
\newcommand\inst[0]{\iota}

\newcommand\pty[1]{\ty^1_{#1}}
\newcommand\rty[1]{\ty^2_{#1}}

\newcommand\Loc[0]{L}
\newcommand\loc[0]{l}

% value types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tinst[2]{\mathsf{Inst} \; #1 \; #2}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\tforall[2]{\forall #1 . #2}
\newcommand\texists[2]{\exists #1 . #2}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[2]{\Lambda #1 . #2}
\newcommand\vabs[2]{\lambda #1 . #2}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cappt[2]{#1 \; [ #2 ]}
\newcommand\cpack[2]{\mathsf{pack} \; #1 \; \mathsf{in} \; #2}
\newcommand\cunpack[4]{\mathsf{unpack} \; #1 \; \mathsf{as} \; ( #2, #3 ) ;\; #4}
\newcommand\cdo[3]{#1 \leftarrow #2 ;\; #3}
\newcommand\cop[3]{#1 \# #2(#3)}
\newcommand\cfresh[2]{\mathsf{fresh} \; #1 ;\; #2}
\newcommand\cnew[5]{\mathsf{new} \; #1 @ #2 \; \{ #3 \} \; \mathsf{as} \; #4 \;\mathsf{in}\; #5}
\newcommand\chandle[1]{\mathsf{handle} ( #1 )}
\newcommand\chandlen[2]{\mathsf{handle} ( #1 \rightarrow #2 )}
\newcommand\chandlec[2]{\mathsf{handle}^{#1} ( #2 )}
\newcommand\chandlei[3]{\mathsf{handle}^{#1} \{ #2 \} ( #3 )}

% handlers
\newcommand\handler[0]{h}
\newcommand\hop[5]{#1 \; #2 \; #3 \rightarrow #4 ; #5}
\newcommand\hreturn[2]{\mathsf{return} \; #1 \rightarrow #2}
\newcommand\hfinally[2]{\mathsf{finally} \; #1 \rightarrow #2}

% misc
\newcommand\subty[2]{#1 <: #2}
\newcommand\sep[0]{\;;\;}
\newcommand\sss[4]{#1 \; | \; #2 \rightsquigarrow #3 \; | \; #4}

% locations modelled by some countably infnite set.
% mathpartir
% explicit free variables fn FIV

% add substitution to type application
% more brackets in semantics

In this chapter we give a formal account of X.
We give the syntax, typing rules and a small-step operation semantics.
We end the chapter with a type soundness theorem.
The system builds on the formal system with algebraic effects, handlers and static instances of Chapter~4.3.
We add constructs to handle effect scope polymorphism.
We also add a construct to dynamically create new instances.
Finally we add constructs to handle effect scopes.
\\\\
In Section~\ref{sec:syntax} we give the syntax of the terms and types of X.
In Section~\ref{sec:subtyping} we give subtyping rules for the types.
In Section~\ref{sec:wellformedness} we give well-formedness rules for the types.
In Section~\ref{sec:typingrules} we give the typing rules.
In Section~\ref{sec:semantics} we give a small-step operation semantics for X.
Finally in Section~\ref{sec:theorems} we give a type-soundness theorem.

\section{Syntax}
\label{sec:syntax}
Just like in the formal systems of algebraic effects of Chapter~4.2 and Chapter~4.3
we assume there is set of effect names $\mathsf{EffName}$ with $\Eff \subseteq \mathsf{EffName}$.
For example $\Eff = \{ \mathsf{Flip}, \mathsf{State}, \mathsf{Exc}, ... \}$.
Each effect $\eff$ has a non-empty set of operation names $\Op{\eff}$.
For example $\Op{\mathsf{Flip}} = \{\mathsf{flip}\}$ and $\Op{\mathsf{State}} = \{\mathsf{get}, \mathsf{put}\}$.
Every operation name only corresponds to a single effect.
Each operation $\op$ has a parameter type $\pty{\op}$ and a return type $\rty{\op}$.
We have effect scope variables $s$ modeled by some countable infinite set.
And we have locations $l$ also modeled by some countable infinite set.
Annotations $r$ are sets of effect scope variables like $\{ s_1, ..., s_n \}$.
\\
\begin{figure}
\caption{Syntax}
\centering
\fbox{
\begin{minipage}{14 cm}
\begin{align*}
	s \Coloneqq	& s_{var} \;|\; s_{loc} \\
	\ty \Coloneqq 	& \tinst{s}{\eff} \;|\; \tarr{\ty}{\cty} \;|\; \tforall{s_{var}}{\cty} \\
	\cty \Coloneqq 	& \aty{\ty}{r} \\
	\val \Coloneqq	&																		\tag{values} \\
									& x, y, z, k												\tag{variables} \\
									& \vinst{s, \loc}										\tag{instance values (for semantics)} \\
									& \vabs{x}{\comp}										\tag{abstraction} \\
									& \vabst{s_{var}}{\comp}						\tag{scope abstraction} \\
	\comp \Coloneqq	&																		\tag{computations} \\
									& \creturn{\val}										\tag{return value as computation} \\
									& \capp{\val}{\val}									\tag{application} \\
									& \cappt{\val}{s}										\tag{scope application} \\
									& \cdo{x}{\comp}{\comp}							\tag{sequencing} \\
									& \cop{\val}{\op}{\val}							\tag{operation call} \\
									& \cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}		\tag{instance creation} \\
									& \chandlen{s_{var}}{\comp}										\tag{handle scoped computation} \\
									& \chandlec{s_{loc}}{\comp}								\tag{handle computation (for semantics)} \\
									& \chandlei{\loc}{\handler}{\comp}	\tag{handle instance (for semantics)} \\
	\handler \Coloneqq 		&															\tag{handlers} \\
									& \hop{\op}{x}{k}{\comp}{\handler}	\tag{operation case} \\
									& \hreturn{x}{\comp}								\tag{return/finally case} \\
\end{align*}
\label{fig:syntax-calc}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Environments}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
	\Gamma \Coloneqq 	& \cdot \;|\; \Gamma, x : \ty \\
	\Delta \Coloneqq 	& \cdot \;|\; \Delta, s_{var} \\
	\Sigma \Coloneqq  	& \cdot \;|\; \Sigma, s_{loc} \;|\; \Sigma, l := (s_{loc}, \eff) \\
\end{align*}
\label{fig:contexts}
\end{minipage}
}
\end{figure}

\textbf{Environments}
Before looking at the different judgments, we will introduce the three environments used.
The syntax for the environment are shown in figure \ref{fig:contexts}.
\begin{itemize}
\item $\Gamma$ is the typing enviroment which assigns variables $x$ to value types $\ty$.
\item $\Delta$ is the effect scope variable environment which keeps track of the scope variables $s_{var}$ that are in use.
\item $\Sigma$ is the dynamic environment which keeps track of scope location $s_{loc}$ and instance locations $l$. Instance locations are assigned a tuple of a scope location and an effect $(s_{loc}, \eff)$. $\Sigma$ is used in both the typing rules and the operational semantics.
\end{itemize}

\textbf{Judgments}
There are three kinds of judgments: subtyping, well-formedness and typing.
\\\\
The subtyping judgments are used to weaken the effect annotation of a computation type.
Weakening the effect annotation is sometimes necessary in order to type a program.
For example when typing the sequencing of two computations $\cdo{x}{\comp_1}{\comp_2}$, if the two computations do not agree on the effects then subtyping can be used to weaken both the computations such that the effect annotations agree.
There is a subtyping judgment for both the value types $\ty$ and the computation types $\cty$ these mutually depend on one another:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\subty{\ty}{\ty'}$ holds when the value type $\ty$ is a subtype of $\ty'$.
\item $\subty{\cty}{\cty'}$ holds when the computation type $\cty$ is a subtype of $\cty'$.
\end{itemize}

The well-formedness judgments check that scopes used in the types are valid under the scope variable and dynamic environments.
There are three judgments of this kind:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Sigma \vdash s$ checks that the scope $s$ is either in $\Delta$ if it is a scope variable or else in $\Sigma$ if it is a scope location.
\item $\Delta;\Sigma \vdash \ty$ checks that all the scopes in the value type $\ty$ are valid under the environments $\Delta$ and $\Sigma$.
\item $\Delta;\Sigma \vdash \cty$ checks that all the scopes in the computation type $\cty$ are valid under the environments $\Delta$ and $\Sigma$.
\end{itemize}

Lastly there are three typing judgments:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Sigma;\Gamma \vdash \val : \ty$ checks that the value $\val$ has the value type $\ty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash \comp : \cty$ checks that the computation $\comp$ has the computation type $\cty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash^{\ty} h : \cty$ checks that the handler $h$ transform a return value of type $\ty$ to the computation type $\cty$.
\end{itemize}

\section{Subtyping}
\label{sec:subtyping}
\begin{figure}
\caption{Subtyping}
\centering
\fbox{
\begin{minipage}{14 cm}
$$\inferrule{
}{
	\subty{ \tinst{s}{\eff} }{ \tinst{s}{\eff} } 
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\subty{\ty_2}{\ty_1} \\
	\subty{\cty_1}{\cty_2} \\
}{
	\subty{ \tarr{\ty_1}{\cty_1} }{ \tarr{\ty_2}{\cty_2} }
}
\hspace{3em}
\mprset{vskip=0 ex}
$$
$$
\inferrule{
	\subty{ \cty_1 }{ \cty_2 }
}{
	\subty{ \tforall{s_{var}}{\cty_1} }{ \tforall{s_{var}}{\cty_2} }
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\subty{ \ty_1 }{ \ty_2 } \\
	r_1 \subseteq r_2
}{
	\subty{ \aty{\ty_1}{r_1} }{ \aty{\ty_2}{r_2} }
}$$
\label{fig:subtyping-calc}
\end{minipage}
}
\end{figure}

\section{Well-formedness}
\label{sec:wellformedness}
\begin{figure}
\caption{Well-formedness}
\centering
\fbox{
\begin{minipage}{14 cm}
$$
\inferrule{
	s_{var} \in \Delta
}{
	\Delta;\Sigma \vdash s_{var}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	s_{loc} \in \Sigma
}{
	\Delta;\Sigma \vdash s_{loc}
}
$$
$$\inferrule{
	\Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \tinst{s}{\eff}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma \vdash \ty \\
	\Delta;\Sigma \vdash \cty \\
}{
	\Delta;\Sigma \vdash \tarr{\ty}{\cty}
}
\hspace{3em}
\mprset{vskip=0 ex}
$$
$$
\inferrule{
	\Delta,s_{var};\Sigma \vdash \cty 
}{
	\Delta;\Sigma \vdash \tforall{s_{var}}{\cty}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma \vdash \ty \\
	\forall (\eff@s \in r) \Rightarrow \Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \aty{\ty}{r}
}$$
\label{fig:wf-calc}
\end{minipage}
}
\end{figure}

\section{Typing rules}
\label{sec:typingrules}
\begin{figure}
\caption{Value typing rules}
\centering
\fbox{
\begin{minipage}{14 cm}
$$\inferrule{
	\Gamma[x] = \ty
}{
	\Delta;\Sigma;\Gamma \vdash x : \ty
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Sigma(\loc) = (s_{loc}, \eff)
}{
	\Delta;\Sigma;\Gamma \vdash \vinst{\loc} : \tinst{s_{loc}}{\eff}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma;\Gamma, x : \ty \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty}{\cty}
}
$$
$$
\inferrule{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabst{s_{var}}{\comp} : \tforall{s_{var}}{\cty}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_1 \\
	\Delta;\Sigma \vdash \ty_2 \\
	\subty{\ty_1}{\ty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_2
}
$$
\label{fig:val-typing-calc}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Computation typing rules}
\centering
\fbox{
\begin{minipage}{14 cm}
$$\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val : \ty
}{
	\Delta;\Sigma;\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tarr{\ty}{\cty} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \ty \\
}{
	\Delta;\Sigma;\Gamma \vdash \capp{\val_1}{\val_2} : \cty
}
$$
$$
\inferrule{
	\Delta;\Sigma \vdash s \\
	\Delta;\Sigma;\Gamma \vdash \val : \tforall{s'_{var}}{\cty}
}{
	\Delta;\Sigma;\Gamma \vdash \cappt{\val}{s} : \cty[s'_{var} := s]
}
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \comp_1 : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma,x:\ty_1 \vdash \comp_2 : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tinst{s}{\eff} \\
	\op \in \Op{\eff} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \pty{\op} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cop{\val_1}{\op}{\val_2} : \aty{\rty{\op}}{\{\eff@s\}}
}
$$
$$
\inferrule{
	\Delta;\Sigma \vdash s \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma,x:\tinst{s}{\eff} \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	\eff@s \in r \\
	\Delta;\Sigma;\Gamma,y : \ty_2 \vdash \comp' : \aty{\ty_3}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp} : \aty{\ty_3}{r}
}
$$
$$
\inferrule{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{var} \notin \ty \\
	r' = \{ \eff@s' \;|\; \eff@s' \in r \wedge s' \neq s_{var} \}
}{
	\Delta;\Sigma;\Gamma \vdash \chandlen{s_{var}}{\comp} : \aty{\ty}{r'}
}
$$
$$
\inferrule{
	s_{loc} \in \Sigma \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{loc} \notin \ty \\
	r' = \{ \eff@s' \;|\; \eff@s' \in r \wedge s' \neq s_{loc} \}
}{
	\Delta;\Sigma;\Gamma \vdash \chandlec{s_{loc}}{\comp} : \aty{\ty}{r'}
}
$$
$$
\inferrule{
	\Sigma(\loc) = (s_{loc}, \eff) \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty_1}{r} \\
	\eff@s_{loc} \in r
}{
	\Delta;\Sigma;\Gamma \vdash \chandlei{\loc}{\handler}{\comp} : \aty{\ty_2}{r}
}
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_1 \\
	\Delta;\Sigma \vdash \cty_2 \\
	\subty{\cty_1}{\cty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_2
}
$$
\label{fig:comp-typing-calc}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Handler typing rules}
\centering
\fbox{
\begin{minipage}{14 cm}
$$
\inferrule{
	\Delta;\Sigma;\Gamma,x:\pty{\op},k:\tarr{\rty{\op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hop{\op}{x}{k}{\comp}{\handler}) : \aty{\ty_2}{r}
}
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma,x : \ty_1 \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}
$$
\label{fig:handler-typing-calc}
\end{minipage}
}
\end{figure}

\section{Semantics}
\label{sec:semantics}
\begin{figure}
\caption{Semantics}
\centering
\fbox{
\begin{minipage}{17 cm}
$$
\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
}{
	\cappt{(\vabst{s}{\comp})}{s'} \;|\; \Sigma \rightsquigarrow \comp[s := s'] \;|\; \Sigma
}
$$
$$
\inferrule{
	\comp_1 ; \Sigma \rightsquigarrow \comp'_1 ; \Sigma'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \;|\; \Sigma \rightsquigarrow (\cdo{x}{\comp'_1}{\comp_2}) \;|\; \Sigma'
}
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
}{
	(\cdo{x}{(\creturn{\val})}{\comp}) \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	(\cdo{y}{(\cdo{x}{\comp_1}{\comp_2})}{\comp_3} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\comp_1}{\cdo{y}{\comp_2}{\comp_3}}) \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	(\cdo{x}{(\cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{\comp_1})}{\comp_2}) \;|\; \Sigma \rightsquigarrow \\
	 \cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{(\cdo{x}{\comp_1}{\comp_2})} \;|\; \Sigma
}
$$
$$
\inferrule{
	s_{loc} \notin \Sigma
}{
	\chandlen{s_{var}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp[s_{var} := s_{loc}]} \;|\; \Sigma,s_{loc}
}
$$
\label{fig:semantics1-calc}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Semantics of new handlers}
\centering
\fbox{
\begin{minipage}{17 cm}
$$
\inferrule{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlec{s_{loc}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp'} \;|\; \Sigma'
}
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\creturn{\val} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow
	\cop{\val_1}{\op}{\val_2} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\comp}} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\chandlec{s_{loc}}{\comp}}) \;|\; \Sigma
}
$$
$$
\inferrule{
	s_{loc} \neq s'_{loc}
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\chandlec{s_{loc}}{\comp}} \;|\; \Sigma
}
$$
$$
\inferrule{
	\loc \notin \mathsf{Dom}(\Sigma)
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s_{loc}}{\handler; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\chandlec{s_{loc}}{\cdo{y}{\chandlei{\loc}{\handler}{\comp[x := \vinst{\loc}]}}{\comp'}} \;|\; \Sigma,\loc := (s_{loc}, \eff)
}
$$
\label{fig:semantics2-calc}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Semantics of instance handlers}
\centering
\fbox{
\begin{minipage}{17 cm}
$$
\inferrule{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlei{\loc}{\handler}{\comp} \;|\; \Sigma \rightsquigarrow \chandlei{\loc}{\handler}{\comp'} \;|\; \Sigma'
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler}{\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\chandlei{\loc}{\handler}{\comp}} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\creturn{x}}} \;|\; \Sigma
}
$$
$$
\inferrule{
	\loc \neq \loc'
}{
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\chandlei{\loc}{\handler}{{\comp}}}) \;|\; \Sigma
}
$$
$$
\inferrule{
	\handler[\op] = (x, k, \comp_{\op})
}{
	\chandlei{\loc}{\handler}{\cdo{y}{\cop{\vinst{\loc}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow 
	\comp_{\op}[x := \val, k := (\vabs{y}{\chandlei{\loc}{\handler}{\comp}})] \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler; \hreturn{x_r}{\comp_r}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\comp_r[x_r := \val] \;|\; \Sigma
}
$$
\label{fig:semantics3-calc}
\end{minipage}
}
\end{figure}

\section{Type soundness}
\label{sec:theorems}


}