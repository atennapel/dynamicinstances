{

\def\msquare{\mathord{\scalerel*{\Box}{gX}}}

% effects
\newcommand\Eff[0]{E}
\newcommand\eff[0]{\varepsilon}
\newcommand\Op[1]{O^{#1}}
\newcommand\op[0]{op}
\newcommand\inst[0]{\iota}

\newcommand\pty[1]{\ty^1_{#1}}
\newcommand\rty[1]{\ty^2_{#1}}

\newcommand\Loc[0]{L}
\newcommand\loc[0]{l}

% value types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tinst[2]{\mathsf{Inst} \; #1 \; #2}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\tforall[2]{\forall #1 . #2}
\newcommand\texists[2]{\exists #1 . #2}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[2]{\Lambda #1 . #2}
\newcommand\vabs[2]{\lambda #1 . #2}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cappt[2]{#1 \; [ #2 ]}
\newcommand\cpack[2]{\mathsf{pack} \; #1 \; \mathsf{in} \; #2}
\newcommand\cunpack[4]{\mathsf{unpack} \; #1 \; \mathsf{as} \; ( #2, #3 ) ;\; #4}
\newcommand\cdo[3]{#1 \leftarrow #2 ;\; #3}
\newcommand\cop[3]{#1 \# #2(#3)}
\newcommand\cfresh[2]{\mathsf{fresh} \; #1 ;\; #2}
\newcommand\cnew[5]{\mathsf{new} \; #1 @ #2 \; \{ #3 \} \; \mathsf{as} \; #4 \;\mathsf{in}\; #5}
\newcommand\chandle[1]{\mathsf{runscope} ( #1 )}
\newcommand\chandlen[2]{\mathsf{runscope} ( #1 \rightarrow #2 )}
\newcommand\chandlec[2]{\mathsf{runscope}^{#1} ( #2 )}
\newcommand\chandlei[3]{\mathsf{runinst}^{#1} \{ #2 \} ( #3 )}

% handlers
\newcommand\handler[0]{h}
\newcommand\hop[5]{#1 \; #2 \; #3 \rightarrow #4 ; #5}
\newcommand\hreturn[2]{\mathsf{return} \; #1 \rightarrow #2}
\newcommand\hfinally[2]{\mathsf{finally} \; #1 \rightarrow #2}

% misc
\newcommand\subty[2]{#1 <: #2}
\newcommand\sep[0]{\;;\;}
\newcommand\sss[4]{#1 \; | \; #2 \rightsquigarrow #3 \; | \; #4}

\newenvironment{lines}{}{}

% locations modelled by some countably infnite set.
% mathpartir
% explicit free variables fn FIV

% add substitution to type application
% more brackets in semantics

In this chapter we give a formal account of X.
We give the syntax, typing rules and a small-step operation semantics.
We end the chapter with a type soundness theorem.
The system builds on the formal system with algebraic effects, handlers and static instances of Chapter~4.3.
We add constructs to handle effect scope polymorphism, to create new instances, and to handle effect scopes, as informally described in Chapter~3.
\\\\
In Section~\ref{sec:syntax} we give the syntax of the terms and types of X.
In Section~\ref{sec:contexts} we give the environments and judgments used in the typing rules and semantics.
In Section~\ref{sec:subtyping} we give subtyping rules for the types.
In Section~\ref{sec:wellformedness} we give well-formedness rules for the types.
In Section~\ref{sec:typingrules} we give the typing rules.
In Section~\ref{sec:semantics} we give a small-step operation semantics for X.
Finally in Section~\ref{sec:theorems} we give a type-soundness theorem.

\section{Syntax}
\label{sec:syntax}
Just like in the formal systems of algebraic effects of Chapter~4.2 and Chapter~4.3
we assume there is set of effect names $\mathsf{EffName}$ with $\Eff \subseteq \mathsf{EffName}$.
For example $\Eff = \{ \mathsf{Flip}, \mathsf{State}, \mathsf{Exc}, ... \}$.
There is also a set of operation names $\mathsf{O}$.
Each effect $\eff \in \Eff$ has a non-empty set of operation names $\Op{\eff} \in O$.
For example $\Op{\mathsf{Flip}} = \{\mathsf{flip}\}$ and $\Op{\mathsf{State}} = \{\mathsf{get}, \mathsf{put}\}$.
Every operation name only corresponds to a single effect.
Each operation $\op$ has a parameter type $\pty{\op}$ and a return type $\rty{\op}$.

\begin{figure}
\caption{Syntax}
\centering
\fbox{
\begin{minipage}{10 cm}
\begin{align*}
	s \Coloneqq		&\; s_{var} \;|\; s_{loc} \\
	\ty \Coloneqq 		&\; \tinst{s}{\eff} \;|\; \tarr{\ty}{\cty} \;|\; \tforall{s_{var}}{\cty} \\
	\cty \Coloneqq 		&\; \aty{\ty}{r} \\
	\val \Coloneqq		&\; x, y, z, k \;|\; \vinst{\loc} \;|\; \vabs{x}{\comp} \;|\; \vabst{s_{var}}{\comp} \\
	\comp \Coloneqq	&\; \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \;|\; \cop{\val}{\op}{\val} \;|\; \cappt{\val}{s} \\
					&\;|\; \cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}	\\
					&\;|\; \chandlen{s_{var}}{\comp}							\\
					&\;|\; \chandlec{s_{loc}}{\comp}							\\
					&\;|\; \chandlei{\loc}{\handler}{\comp}						\\
	\handler \Coloneqq	&\; \hop{\op}{x}{k}{\comp}{\handler} \;|\; \hreturn{x}{\comp}
\end{align*}
\label{fig:syntax-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:syntax-calc} we show the syntax of the types and terms of X.
An effect scope $s$ is either a scope variable $s_{var}$ or a scope location $s_{loc}$.
Effect scope variables $s_{var}$ and effects scope locations $s_{loc}$ are both modeled by countable infinite sets.
\\\\
Like in the systems in Chapter~4 terms and types are both split between values and computations, and value types and computation types.
Values are typed by value types and computations are typed by computation types.
\\\\
Value types $\ty$ are either an instance type $\tinst{s}{\eff}$, indexed by an effect scope $s$ and an effect $\eff$.
Or a function type $\tarr{\ty}{\cty}$ where the parameter type is a value type and the return type is a computation type.
Or an universally quantified computation type $\tforall{s_{var}}{\cty}$, where the domain of quantification are effect scopes.
\\\\
A computation type $\cty$ is always an annotated value type of the form $\aty{\ty}{r}$.
Annotations $r$ are sets of effect scopes $\{ s_1, ..., s_n \}$.
\\\\
Values are either variables $x$, $k$, where we always use $k$ do denote variables that refer to continuations.
Or instances $\vinst{\loc}$, indexed by some instance location $\loc$, which are modeled by some countable infinite set.
Instances would not appear in the surface language, but are introduced by the semantics.
Or lambda abstractions $\vabs{x}{\comp}$, where the body is a computation.
Or effect scope abstractions $\vabst{s_{var}}{\comp}$, where we abstract over a computation $\comp$, with the domain of the quantification being effect scopes.
\\\\
As usual, for computations we have $\creturn{\val}$, to lift a value $\val$ in to a computation.
We have application $\capp{\val}{\val}$ and sequencing $\cdo{x}{\comp}{\comp}$.
We have operation calls $\cop{\val}{\op}{\val}$.
The new constructs are as follows.
We have effect scope application $\cappt{\val}{s}$.
We can create new instances with $\cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}$, where $\handler$ is a handler.
We can handle computations with $\chandlen{s_{var}}{\comp}$.
Finally we have two more constructs which would not appear in the surface language, but are introduced by the semantics.
Effect scope handlers $\chandlec{s_{loc}}{\comp}$ handle a specific scope $s_{loc}$ in the computation $\comp$.
Instance handlers $\chandlei{\loc}{\handler}{\comp}$ handle the operations of a single instance of the location $\loc$ in the computation $\comp$.
\\\\
Finally we have handlers $\handler$ which are lists of operation cases ending with a return case.
Operation cases are of the form $\hop{\op}{x}{k}{\comp}{\handler}$, where $\handler$ is the rest of the handler.
Return cases are of the form $\hreturn{x}{\comp}$.

\section{Environments and judgments}
\label{sec:contexts}
We will now give the environment and judgments used in the typing rules and semantics.

\begin{figure}[h]
\caption{Environments}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
	\Gamma \Coloneqq 	& \cdot \;|\; \Gamma, x : \ty \\
	\Delta \Coloneqq 	& \cdot \;|\; \Delta, s_{var} \\
	\Sigma \Coloneqq  	& \cdot \;|\; \Sigma, s_{loc} \;|\; \Sigma, l := (s_{loc}, \eff)
\end{align*}
\label{fig:contexts}
\end{minipage}
}
\end{figure}

\paragraph{Environments}
The syntax for the environments is shown in Figure~\ref{fig:contexts}.
As usual we have $\Gamma$, like in the systems of Chapter~4.
$\Delta$ is introduced to handle the effect scope polymorphism.
$\Sigma$ is introduced to handle the fresh generation of scope and instance locations.

\begin{itemize}
\item $\Gamma$ is the typing enviroment which assigns variables $x$ to value types $\ty$.
\item $\Delta$ is the effect scope variable environment which keeps track of the scope variables $s_{var}$ that are in use.
\item $\Sigma$ is the dynamic environment which keeps track of scope location $s_{loc}$ and instance locations $l$. Instance locations are assigned a tuple of a scope location and an effect $(s_{loc}, \eff)$. $\Sigma$ is used in both the typing rules and the operational semantics.
We do not need a separate environment for the semantics because instances are not assigned dynamic values like references are.
$\Sigma$ enables us to type instances in the typing rules, and to generate fresh scope and instance locations in the semantics.
Because there is a dependence of instance locations on scope locations we also introduce a well-formedness judgment for $\Sigma$.
\end{itemize}

\paragraph{Judgments}
There are four kinds of judgments: subtyping (Section~\ref{sec:subtyping}), well-formedness (Section~\ref{
sec:wellformedness}) and typing (Section~\ref{sec:typingrules}).
\\\\
The subtyping judgments are used to weaken the effect annotation of a computation type.
Weakening the effect annotation is sometimes necessary in order to type a program.
For example when typing the sequencing of two computations $\cdo{x}{\comp_1}{\comp_2}$, if the two computations do not agree on the effects then subtyping can be used to weaken both the computations such that the effect annotations agree.
There is a subtyping judgment for both the value types $\ty$ and the computation types $\cty$ these mutually depend on one another:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\subty{\ty}{\ty'}$ holds when the value type $\ty$ is a subtype of $\ty'$.
\item $\subty{\cty}{\cty'}$ holds when the computation type $\cty$ is a subtype of $\cty'$.
\end{itemize}

We have a well-formedness judgment $\vdash \Sigma$ which makes sure instance locations in $\Sigma$ do not depend on an non-existant scope locations and that locations are unique.
The well-formedness judgments for types assert that scopes used in the types are valid under the scope variable and dynamic environments.
The well-formedness judgments have the following form:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\vdash \Sigma$ asserts that all instance locations in $\Sigma$ refer to valid scope locations and that all locations are unique.
\item $\Delta;\Sigma \vdash s$ asserts that the scope $s$ is either in $\Delta$ if it is a scope variable or else in $\Sigma$ if it is a scope location.
\item $\Delta;\Sigma \vdash \ty$ asserts that all the scopes in the value type $\ty$ are valid under the environments $\Delta$ and $\Sigma$.
\item $\Delta;\Sigma \vdash \cty$ asserts that all the scopes in the computation type $\cty$ are valid under the environments $\Delta$ and $\Sigma$. This judgment is only used in the theorems at the end of the Chapter.
\end{itemize}

Lastly there are three typing judgments:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Sigma;\Gamma \vdash \val : \ty$ asserts that the value $\val$ has the value type $\ty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash \comp : \cty$ asserts that the computation $\comp$ has the computation type $\cty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash^{\ty} h : \cty$ asserts that the handler $h$ transform a return value of type $\ty$ to the computation type $\cty$.
\end{itemize}

\section{Subtyping}
\label{sec:subtyping}
\begin{figure}[h]
\caption{Subtyping}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{Sub-Inst}{
}{
	\subty{ \tinst{s}{\eff} }{ \tinst{s}{\eff} } 
}
\and
\inferH{Sub-Arr}{
	\subty{\ty_2}{\ty_1} \\
	\subty{\cty_1}{\cty_2} \\
}{
	\subty{ \tarr{\ty_1}{\cty_1} }{ \tarr{\ty_2}{\cty_2} }
}
\and
\inferH{Sub-Forall}{
	\subty{ \cty_1 }{ \cty_2 }
}{
	\subty{ \tforall{s_{var}}{\cty_1} }{ \tforall{s_{var}}{\cty_2} }
}
\and
\inferH{Sub-Annot}{
	\subty{ \ty_1 }{ \ty_2 } \\
	r_1 \subseteq r_2
}{
	\subty{ \aty{\ty_1}{r_1} }{ \aty{\ty_2}{r_2} }
}
\end{mathpar}
\label{fig:subtyping-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:subtyping-calc} we give the subtyping rules for both the value and the computation types.
The subtyping checks that that the effects mentioned in the type on the right are the same or more general than the type on the left.
An instance type $\tinst{s}{\eff}$ is a subtype of another instance type if they are structurally equal, shown in the rule \textsc{Sub-Inst}.
Function types $\tarr{\ty}{\cty}$ are compared by subtyping the parameter types contravariantly and subtyping the return types covariantly, shown in the rule \textsc{Sub-Arr}.
Universally quantified types $\tforall{s_{var}}{\cty}$ are structurally recursed upon, given they the quantified variables are equal (\textsc{Sub-Forall}).
Lastly annotated types $\aty{\ty}{r}$ are compared by comparing the value types and checking that the annotation on the left type is a subtype of the annotation on the right type (\textsc{Sub-Annot}).

\section{Well-formedness}
\label{sec:wellformedness}

\begin{figure}[h]
\caption{Well-formedness for $\Sigma$}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{WFS-Empty}{
}{
	\vdash \cdot
}
\and
\inferH{WFS-ScopeLoc}{
	\vdash \Sigma \\
	s_{loc} \notin \Sigma
}{
	\vdash \Sigma, s_{loc}
}
\and
\inferH{WFS-InstanceLoc}{
	\vdash \Sigma \\
	l \notin \Sigma \\
	s_{loc} \in \Sigma
}{
	\vdash \Sigma, l := (s_{loc}, \eff)
}
\end{mathpar}
\label{fig:wf-sigma}
\end{minipage}
}
\end{figure}

\begin{figure}[h]
\caption{Well-formedness for types}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{WF-SVar}{
	s_{var} \in \Delta
}{
	\Delta;\Sigma \vdash s_{var}
}
\and
\inferH{WF-SLoc}{
	s_{loc} \in \Sigma
}{
	\Delta;\Sigma \vdash s_{loc}
}
\and
\inferH{WF-Inst}{
	\Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \tinst{s}{\eff}
}
\and
\inferH{WF-Arr}{
	\Delta;\Sigma \vdash \ty \\
	\Delta;\Sigma \vdash \cty \\
}{
	\Delta;\Sigma \vdash \tarr{\ty}{\cty}
}
\and
\inferH{WF-Forall}{
	\Delta,s_{var};\Sigma \vdash \cty 
}{
	\Delta;\Sigma \vdash \tforall{s_{var}}{\cty}
}
\and
\inferH{WF-Annot}{
	\Delta;\Sigma \vdash \ty \\
	\forall (s \in r) \Rightarrow \Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \aty{\ty}{r}
}
\end{mathpar}
\label{fig:wf-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:wf-sigma} we give the well-formedness rules for $\Sigma$.
If $\Sigma$ is empty then it is well-formed (\textsc{WFS-Empty}).
For scope locations $s_{loc}$ we check that the rest of $\Sigma$ is well-formed and that $s_{loc}$ does not occur in it, meaning that $s_{loc}$ is unique (\textsc{WFS-ScopeLoc}).
For instance locations $l$ we also first check that the rest of $\Sigma$ is well-formed.
Then we check that $l$ does not occur in $\Sigma$.
Lastly we check that the scope location $s_{loc}$ used by $l$ is defined in $\Sigma$.
\\\\
In Figure~\ref{fig:wf-calc} we give the well-formedness rules for the value and computation types.
Well-formedness asserts that the effect scopes in the type are accounted for in the environments.
The rules \textsc{WF-SVar} and \textsc{WF-SLoc} assert that the effect scope variables $s_{var}$ and locations $s_{loc}$ are valid by checking that they are contained in the scope and dynamic environments respectively.
For instance types we check that the mentioned effect scope is valid (\textsc{WF-Inst}).
For function types $\tarr{\ty}{\cty}$ we check that both the paramter and return type is valid.
For universally quantified types $\tforall{s_{var}}{\cty}$ we check that the computation type $\cty$ is valid, after adding the variable $s_{var}$ to the environment.
Lastly for annotated types $\aty{\ty}{r}$ we first check that that the value type $\ty$ is valid.
Then we check that each effect scope in the annotation $r$ is valid.

\section{Typing rules}
\label{sec:typingrules}

\begin{figure}[h]
\caption{Value typing rules}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{T-Var}{
	\Gamma[x] = \ty
}{
	\Delta;\Sigma;\Gamma \vdash x : \ty
}
\and
\inferH{T-Inst}{
	\Sigma(\loc) = (s_{loc}, \eff)
}{
	\Delta;\Sigma;\Gamma \vdash \vinst{\loc} : \tinst{s_{loc}}{\eff}
}
\and
\inferH{T-Abs}{
	\Delta;\Sigma;\Gamma, x : \ty \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty}{\cty}
}
\and
\inferH{T-TAbs}{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabst{s_{var}}{\comp} : \tforall{s_{var}}{\cty}
}
\and
\inferH{T-SubVal}{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_1 \\
	\Delta;\Sigma \vdash \ty_2 \\
	\subty{\ty_1}{\ty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_2
}
\end{mathpar}
\label{fig:val-typing-calc}
\end{minipage}
}
\end{figure}

The typing rules for the values are given in Figure~\ref{fig:val-typing-calc}.
The rules \textsc{T-Var}, \textsc{T-Abs} and \textsc{T-SubVal} are practically unchanged from the corresponding rules in the algebraic effects type system from Chapter~4.2.
Instances $\vinst{l}$ are assigned instance types, with the scope location and effect looked up in the dynamic environment $\Sigma$ using the location $l$ (\textsc{T-Inst}).
Similar to abstractions, effect scope abstractions are assigned a universally quantified type $\tforall{s_{var}}{\cty}$, by typing the body with $\cty$ after adding $s_{var}$ to the scope environment $\Delta$ (\textsc{T-TAbs}).
\\\\
The typing rule for the computations are given in Figure~\ref{fig:comp-typing-calc}.
The rules \textsc{T-Return}, \textsc{T-App}, \textsc{T-Seq} and \textsc{T-SubComp} are practically unchanged from the corresponding rules in the algebraic effects type system from Chapter~4.2.
\\\\
The rule for effect scope application (\textsc{T-TApp}) asserts that, in the application $\cappt{\val}{s}$, the scope $s$ is well-formed.
Then we check that $\val$ is a universally quantified type $\tforall{s'}{\cty}$.
Finally we substitute the given scope $s$ for the quantified variable $s'$ in $\cty$.
\\\\
For operation calls (\textsc{T-Op}) $\cop{\val_1}{op}{\val_2}$ we first check that the type of $\val_1$ is an instance type $\tinst{s}{\eff}$.
We then check that the operation $op$ is an operation of the effect of the instance $\eff$ ($op \in \Op{\eff}$).
Lastly we check that the given value $\val_2$ matches the parameter type of the operation $op$ ($\pty{op}$).
The type given to the operation call is the return type of the operation $\rty{op}$ with the scope of the instance, $s$, in the annotation.

\begin{figure}[H]
\caption{Computation typing rules}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{T-Return}{
	\Delta;\Sigma;\Gamma \vdash \val : \ty
}{
	\Delta;\Sigma;\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}
\and
\inferH{T-App}{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tarr{\ty}{\cty} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \ty \\
}{
	\Delta;\Sigma;\Gamma \vdash \capp{\val_1}{\val_2} : \cty
}
\and
\inferH{T-TApp}{
	\Delta;\Sigma \vdash s \\
	\Delta;\Sigma;\Gamma \vdash \val : \tforall{s'_{var}}{\cty}
}{
	\Delta;\Sigma;\Gamma \vdash \cappt{\val}{s} : \cty[s'_{var} := s]
}
\and
\inferH{T-Seq}{
	\Delta;\Sigma;\Gamma \vdash \comp_1 : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma,x:\ty_1 \vdash \comp_2 : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}
\and
\inferH{T-Op}{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tinst{s}{\eff} \\
	\op \in \Op{\eff} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \pty{\op} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cop{\val_1}{\op}{\val_2} : \aty{\rty{\op}}{\{s\}}
}
\and
\inferH{T-New}{
	\Delta;\Sigma \vdash s \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma,x:\tinst{s}{\eff} \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	s \in r \\
	\Delta;\Sigma;\Gamma,y : \ty_2 \vdash \comp' : \aty{\ty_3}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp} : \aty{\ty_3}{r}
}
\and
\inferH{T-Handle}{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{var} \notin \ty
}{
	\Delta;\Sigma;\Gamma \vdash \chandlen{s_{var}}{\comp} : \aty{\ty}{(r \setminus \{ s_{var} \})}
}
\and
\inferH{T-HandleScope}{
	s_{loc} \in \Sigma \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{loc} \notin \ty
}{
	\Delta;\Sigma;\Gamma \vdash \chandlec{s_{loc}}{\comp} : \aty{\ty}{(r \setminus \{ s_{loc} \})}
}
\and
\inferH{T-HandleInst}{
	\Sigma(\loc) = (s_{loc}, \eff) \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	% s_{loc} \in r
}{
	\Delta;\Sigma;\Gamma \vdash \chandlei{\loc}{\handler}{\comp} : \aty{\ty_2}{r}
}
\and
\inferH{T-SubComp}{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_1 \\
	\Delta;\Sigma \vdash \cty_2 \\
	\subty{\cty_1}{\cty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_2
}
\end{mathpar}
\label{fig:comp-typing-calc}
\end{minipage}
}
\end{figure}

The rule \textsc{T-New} types the creation of new instance: $\cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp}$.
We are creating a new instance $x$ of effect $\eff$ in the effect scope $s$.
First we check that the given effect scope $s$ is valid.
Then we check that the operations in the handler $h$ are exactly the operations of the effect of the new instance $\eff$.
This means it is not valid to either omit operations or to have operations of other effects in the handler.
This way we can ensure that every operation is accounted for.
We then typecheck the computation $\comp$ with the new instance added the to the environment as $x$, with the type $\aty{\ty_1}{r}$.
Then we typecheck the handler $h$, passing the type $\ty_1$ of $\comp$ to the handler typing judgement.
The handler can transform the return type $\ty_1$ to another type $\ty_2$, but note that the effects annotation $r$ has to be the same.
We check that the scope $s$ is contained in $r$.
The reason for this is because the creation of an instance in $s$ is also an effect and so we have to account for this effect in the annotation by adding $s$ to $r$.
Lastly we check the $\mathsf{finally}$ case.
We add $\ty_2$ to the environment as $y$ and typecheck the computation $\comp'$ as $\aty{\ty_3}{r}$.
The $\mathsf{finally}$ case is allowed to transform the return type of the handler $\ty_2$ to another type $\ty_3$.
Finally the type of the whole instance creation is $\aty{\ty_3}{r}$.
Where $\ty_3$ is the final type of the $\mathsf{finally}$ case and $r$ is the effects from $\comp$, the handler $h$ and the $\mathsf{finally}$ case.
\\\\
The rule \textsc{T-Handle} types handling computations: $\chandlen{s_{var}}{\comp}$.
We typecheck the body $\comp$ with the effect scope variable $s_{var}$ added to the scope environment.
Then we check that the effects do not escape their scope by checking that that $s_{var}$ is not contained in the return type $\ty$.
We then type the whole computation as $\aty{\ty}{(r \setminus \{ s_{var} \})}$.
Knowing that $s_{var}$ does not escape we can safely remove it from the effect annotation.
\\\\
The rule \textsc{T-HandleScope} deals with the handling of a specific scope $s_{loc}$ and is very similar to the previous rule \textsc{T-Handle}.
Instead of the effect scope \emph{variable} $s_{var}$ we now deal with an effect scope \emph{location} $s_{loc}$.
We have to check that the location actually exists, by checking that it is contained in the dynamic environment $\Sigma$.
We can then proceed like in \textsc{T-Handle}, checking that $s_{loc}$ does not escape.
\\\\
\textsc{T-HandleInst} typechecks the handling of an instance at location $l$ using a handler $h$.
First we check that the $location$ is contained in the dynamic environment $\Sigma$
We retrieve the scope location $s_{loc}$ and effect $\eff$ of the instance from $\Sigma$.
We check that the operations in the handler match the operations of the effect.
We then typecheck the computation $\comp$ and the handler $h$ like in \textsc{T-New}.

\begin{figure}[h]
\caption{Handler typing rules}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{T-HandlerOp}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	\Delta;\Sigma;\Gamma,x:\pty{\op},k:\tarr{\rty{\op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hop{\op}{x}{k}{\comp}{\handler}) : \aty{\ty_2}{r}
}
\and
\inferH{T-HandlerReturn}{
	\Delta;\Sigma;\Gamma,x : \ty_1 \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}
\end{mathpar}
\label{fig:handler-typing-calc}
\end{minipage}
}
\end{figure}

Finally we discuss the typing rules for the handlers, given in Figure~\ref{fig:handler-typing-calc}.
\textsc{T-HandlerReturn} types the $\mathsf{return}$ case of a handler.
We typecheck the body $\comp$ after adding the variable $x$ with type $\ty_1$ to the environment.
The type $\ty_1$ is passed with the handler typing judgement in the typing rules \textsc{T-New} and \textsc{T-HandleInst}.
It is the return type of the computation we are handling.
The computation $\comp$ can transform this type to another type $\ty_2$ with some effect annotation $r$, which is the return type of the $\mathsf{return}$ case.
\\\\
The rule \textsc{T-HandlerOp} shows the typing of an operation case.
We first typecheck the rest of handler $h$, passing along the return type $\ty_1$ of the computation we are handling.
We typecheck the rest of the handler as $\aty{\ty_2}{r}$, this is the return type of the whole handler.
Then we typecheck the body of the operation case $\comp$.
We add the operation call argument $x$ with the parameter type $\pty{op}$ of the operation to the environment.
We also add the continuation $k$ to the environment.
This is a function from the return type $\rty{op}$ of the operation, to the return type of the whole handler $\aty{\ty_2}{r}$.
We check that the body of the case $\comp$ returns a computation of the same type.

\section{Semantics}
\label{sec:semantics}

Finally we give a small-step operational semantics for X.
\\\\
The judgment $\comp_1 \;|\; \Sigma_1 \rightsquigarrow \comp_2 \;|\; \Sigma_2$ takes a step from the computation $\comp_1$ to $\comp_2$ in the dynamic environment $\Sigma_1$.
$\Sigma_1$ might be updated with new effect scope locations or instance locations resulting in $\Sigma_2$.
$\Sigma$ will always be monotically extended by $\rightsquigarrow$.

\begin{figure}[h]
\caption{Semantics}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{S-App}{
}{
	\capp{(\vabs{x}{\comp})}{\val} \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}
\and
\inferH{S-TApp}{
}{
	\cappt{(\vabst{s_{var}}{\comp})}{s'} \;|\; \Sigma \rightsquigarrow \comp[s_{var} := s'] \;|\; \Sigma
}
\and
\inferH{S-Seq}{
	\comp_1 ; \Sigma \rightsquigarrow \comp'_1 ; \Sigma'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \;|\; \Sigma \rightsquigarrow (\cdo{x}{\comp'_1}{\comp_2}) \;|\; \Sigma'
}
\and
\inferH{S-SeqReturn}{
}{
	(\cdo{x}{(\creturn{\val})}{\comp}) \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}
\and
\inferH{S-Flatten}{
}{
	(\cdo{y}{(\cdo{x}{\comp_1}{\comp_2})}{\comp_3} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\comp_1}{\cdo{y}{\comp_2}{\comp_3}}) \;|\; \Sigma
}
\and
\inferH{S-LiftNew}{
}{
	(\cdo{x}{(\cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{\comp_1})}{\comp_2}) \;|\; \Sigma \rightsquigarrow \\
	 \cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{(\cdo{x}{\comp_1}{\comp_2})} \;|\; \Sigma
}
\and
\inferH{S-FreshScope}{
	s_{loc} \notin \Sigma
}{
	\chandlen{s_{var}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp[s_{var} := s_{loc}]} \;|\; \Sigma,s_{loc}
}
\end{mathpar}
\label{fig:semantics1-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:semantics1-calc} we give the semantics for every construct except the effect scope and instance handlers.
The rules \textsc{S-App}, \textsc{S-Seq}, \textsc{S-SeqReturn} and \textsc{S-Flatten} are the same as the corresponding rules in the
algebraic effects system of Chapter~4.2.
The rule \textsc{S-TApp} handles an effect scope application similarly to a normal application, by substituting the effect scope $s'$ for the scope variable $s_{var}$ of the scope abstraction.
\textsc{S-LiftNew} lifts the creation of an instance out and over sequencing.
By repeatedly applying this rule we can bubble up the instance creation until we hit an effect scope handler
The rule \textsc{S-FreshScope} creates a fresh scope location with which to handle instances.
A fresh scope location $s_{loc}$ is created and added to the environment $\Sigma$.
This new scope location is substituted in the body $\comp$.
We wrap the computation with an effect scope handler for new scope location $s_{loc}$.
\\\\
In Figure~\ref{fig:semantics2-calc} we give the semantics for the effect scope handlers.
An effect scope handler for a specific effect scope location will create fresh instances when a $\mathsf{new}$ construct is encountered (\textsc{S-HandleScopeNew}).
An instance handler with the handler of the $\mathsf{new}$ construct is wrapped around the computation and the $\mathsf{finally}$ case is wrapped around that.
The newly created location $l$ is added to the dynamic environment together with the scope location and the effect.
If a $\mathsf{new}$ is encountered with a different effect scope we skip it and nest the scope handler inside (\textsc{T-HandleScopeNewSkip}).
Using the rule \textsc{S-HandleScopeCong} to reduce a computation inside a scope handler.
We can remove a scope handler if we encounter either a return or operation call (\textsc{S-HandleScopeReturn} and \textsc{S-HandleScopeOp}).
Effect scope handlers can be pushed inside sequencing, lifting an operation call over it (\textsc{S-HandleScopeSeqOp}).
\\\\
Lastly in Figure~\ref{fig:semantics3-calc} we give the semantics for the instance handlers.
Instance handlers handle operation calls on instances with the same location as the handler.
To be able to handle operation calls with one rule we first have to transform operation calls that are not being sequenced to the sequencing form (\textsc{S-HandleInstOpPrepare}).
When an operation call is encountered on an instance with the same location as the instance handler, the operation is handled (\textsc{S-HandleInstOp}).
The operation is looked up in the handler $h$ and the computation $c_{op}$ in the operation case is performed.
If a $\mathsf{return}$ is encountered the computation $c_r$ in the $\mathsf{return}$ case is performed (\textsc{S-HandleInstReturn}).
Operation calls on instances with a different location $l'$ are skipped, nesting the instance handler inside (\textsc{S-HandleInstOpSkip}).
Similarly $\mathsf{new}$ calls are also skipped, again nesting the instance handler inside (\textsc{S-HandleInstNew}).
Lastly, computations inside instance handlers can be reduced further (\textsc{S-HandleInstCong}).

\begin{figure}[H]
\caption{Semantics of effect scope handlers}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{S-HandleScopeCong}{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlec{s_{loc}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp'} \;|\; \Sigma'
}
\and
\inferH{S-HandleScopeReturn}{
}{
	\chandlec{s_{loc}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\creturn{\val} \;|\; \Sigma
}
\and
\inferH{S-HandleScopeOp}{
}{
	\chandlec{s_{loc}}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow
	\cop{\val_1}{\op}{\val_2} \;|\; \Sigma
}
\and
\inferH{S-HandleScopeSeqOp}{
}{
	\chandlec{s_{loc}}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	(\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\chandlec{s_{loc}}{\comp}}) \;|\; \Sigma
}
\and
\inferH{S-HandleScopeNewSkip}{
	s_{loc} \neq s'_{loc}
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\chandlec{s_{loc}}{\comp}} \;|\; \Sigma
}
\and
\inferH{S-HandleScopeNew}{
	\loc \notin \mathsf{Dom}(\Sigma)
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s_{loc}}{\handler; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\chandlec{s_{loc}}{\cdo{y}{\chandlei{\loc}{\handler}{\comp[x := \vinst{\loc}]}}{\comp'}} \;|\; \Sigma,\loc := (s_{loc}, \eff)
}
\end{mathpar}
\label{fig:semantics2-calc}
\end{minipage}
}
\end{figure}

\begin{figure}[H]
\caption{Semantics of instance handlers}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{S-HandleInstCong}{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlei{\loc}{\handler}{\comp} \;|\; \Sigma \rightsquigarrow \chandlei{\loc}{\handler}{\comp'} \;|\; \Sigma'
}
\and
\inferH{S-HandleInstNew}{
}{
	\chandlei{\loc}{\handler}{\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\chandlei{\loc}{\handler}{\comp}} \;|\; \Sigma
}
\and
\inferH{S-HandleInstOpPrepare}{
}{
	\chandlei{\loc}{\handler}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow\\
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\creturn{x}}} \;|\; \Sigma
}
\and
\inferH{S-HandleInstOpSkip}{
	\loc \neq \loc'
}{
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow\\
	(\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\chandlei{\loc}{\handler}{{\comp}}}) \;|\; \Sigma
}
\and
\inferH{S-HandleInstOp}{
	\handler[\op] = (x, k, \comp_{\op})
}{
	\chandlei{\loc}{\handler}{\cdo{y}{\cop{\vinst{\loc}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow\\
	\comp_{\op}[x := \val, k := (\vabs{y}{\chandlei{\loc}{\handler}{\comp}})] \;|\; \Sigma
}
\and
\inferH{S-HandleInstReturn}{
}{
	\chandlei{\loc}{\handler; \hreturn{x_r}{\comp_r}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\comp_r[x_r := \val] \;|\; \Sigma
}
\end{mathpar}
\label{fig:semantics3-calc}
\end{minipage}
}
\end{figure}

% TODO: add example derivation

\section{Type soundness}
\label{sec:theorems}

It is important for our system to be type safe.
The operational semantics can get stuck if operations are unhandled.

\begin{theorem}[Type soundness]
\[
	\mathsf{if}\;
		(\cdot;\cdot;\cdot \vdash \comp : \aty{\ty}{\varnothing})
		\;\land\;
		(\comp \;|\; \cdot \rightsquigarrow^* \comp' \;|\; \Sigma)
	\;\mathsf{then}\;
		\mathsf{value}(\comp')
		\;\lor\;
		(\exists \comp'' \; \Sigma'.\; \comp' \;|\; \Sigma \rightsquigarrow \comp'' \;|\; \Sigma')
\]
\end{theorem}

The type soundness theorem states that if a computation typechecks with no effects in the annotation and we take some amount of steps, then either the computation is a value or we can take another step.
This means that if a computation typechecks with no effects then we cannot get stuck on an operation call.

\begin{lemma}[Progress]
\[
	\mathsf{if}\;
		\cdot;\Sigma;\cdot \vdash \comp : \aty{\ty}{\varnothing}
	\;\mathsf{then}\;
		\mathsf{value}(\comp)
		\lor
		(\exists \comp' \; \Sigma'.\; \comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma')
\]
\end{lemma}

\begin{lemma}[$\Sigma$ weakening]
\[
	\mathsf{if}\;
		(\Delta;\Sigma;\Gamma \vdash \comp : \cty)
		\;\land\;
		\vdash \Sigma'
		\;\land\;
		\Sigma \subseteq \Sigma'
	\;\mathsf{then}\;
		\Delta;\Sigma';\Gamma \vdash \comp : \cty
\]
\end{lemma}

\begin{lemma}[Semantics does valid monotonic extension]
\[
	\mathsf{if}\;
		(\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma')
		\;\land\;
		\vdash \Sigma
	\;\mathsf{then}\;
		\vdash \Sigma'
		\;\land\;
		\Sigma \subseteq \Sigma'
\]
\end{lemma}

\begin{lemma}[Preservation]
\[
	\mathsf{if}\;
		(\Delta;\Sigma;\Gamma \vdash \comp : \cty)
		\;\land\;
		(\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma')
	\;\mathsf{then}\;
		\Delta;\Sigma';\Gamma \vdash \comp' : \cty
\]
\end{lemma}

}
