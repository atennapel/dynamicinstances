{

\def\msquare{\mathord{\scalerel*{\Box}{gX}}}

% effects
\newcommand\Eff[0]{E}
\newcommand\eff[0]{\varepsilon}
\newcommand\Op[1]{O^{#1}}
\newcommand\op[0]{op}
\newcommand\inst[0]{\iota}

\newcommand\pty[1]{\ty^1_{#1}}
\newcommand\rty[1]{\ty^2_{#1}}

\newcommand\Loc[0]{L}
\newcommand\loc[0]{l}

% value types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tinst[2]{\mathsf{Inst} \; #1 \; #2}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\tforall[2]{\forall #1 . #2}
\newcommand\texists[2]{\exists #1 . #2}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[2]{\Lambda #1 . #2}
\newcommand\vabs[2]{\lambda #1 . #2}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cappt[2]{#1 \; [ #2 ]}
\newcommand\cpack[2]{\mathsf{pack} \; #1 \; \mathsf{in} \; #2}
\newcommand\cunpack[4]{\mathsf{unpack} \; #1 \; \mathsf{as} \; ( #2, #3 ) ;\; #4}
\newcommand\cdo[3]{#1 \leftarrow #2 ;\; #3}
\newcommand\cop[3]{#1 \# #2(#3)}
\newcommand\cfresh[2]{\mathsf{fresh} \; #1 ;\; #2}
\newcommand\cnew[5]{\mathsf{new} \; #1 @ #2 \; \{ #3 \} \; \mathsf{as} \; #4 \;\mathsf{in}\; #5}
\newcommand\chandle[1]{\mathsf{handle} ( #1 )}
\newcommand\chandlen[2]{\mathsf{handle} ( #1 \rightarrow #2 )}
\newcommand\chandlec[2]{\mathsf{handle}^{#1} ( #2 )}
\newcommand\chandlei[3]{\mathsf{handle}^{#1} \{ #2 \} ( #3 )}

% handlers
\newcommand\handler[0]{h}
\newcommand\hop[5]{#1 \; #2 \; #3 \rightarrow #4 ; #5}
\newcommand\hreturn[2]{\mathsf{return} \; #1 \rightarrow #2}
\newcommand\hfinally[2]{\mathsf{finally} \; #1 \rightarrow #2}

% misc
\newcommand\subty[2]{#1 <: #2}
\newcommand\sep[0]{\;;\;}
\newcommand\sss[4]{#1 \; | \; #2 \rightsquigarrow #3 \; | \; #4}

% locations modelled by some countably infnite set.
% mathpartir
% explicit free variables fn FIV

% add substitution to type application
% more brackets in semantics

In this chapter we give a formal account of X.
We give the syntax, typing rules and a small-step operation semantics.
We end the chapter with a type soundness theorem.
The system builds on the formal system with algebraic effects, handlers and static instances of Chapter~4.3.
We add constructs to handle effect scope polymorphism.
We also add a construct to dynamically create new instances.
Finally we add constructs to handle effect scopes.
\\\\
In Section~\ref{sec:syntax} we give the syntax of the terms and types of X.
In Section~\ref{sec:contexts} we give the environments and judgments used in the typing rules and semantics.
In Section~\ref{sec:subtyping} we give subtyping rules for the types.
In Section~\ref{sec:wellformedness} we give well-formedness rules for the types.
In Section~\ref{sec:typingrules} we give the typing rules.
In Section~\ref{sec:semantics} we give a small-step operation semantics for X.
Finally in Section~\ref{sec:theorems} we give a type-soundness theorem.

\section{Syntax}
\label{sec:syntax}
Just like in the formal systems of algebraic effects of Chapter~4.2 and Chapter~4.3
we assume there is set of effect names $\mathsf{EffName}$ with $\Eff \subseteq \mathsf{EffName}$.
For example $\Eff = \{ \mathsf{Flip}, \mathsf{State}, \mathsf{Exc}, ... \}$.
Each effect $\eff$ has a non-empty set of operation names $\Op{\eff}$.
For example $\Op{\mathsf{Flip}} = \{\mathsf{flip}\}$ and $\Op{\mathsf{State}} = \{\mathsf{get}, \mathsf{put}\}$.
Every operation name only corresponds to a single effect.
Each operation $\op$ has a parameter type $\pty{\op}$ and a return type $\rty{\op}$.
Locations $\loc$ are modeled by some countable infinite set.

\begin{figure}
\caption{Syntax}
\centering
\fbox{
\begin{minipage}{10 cm}
\begin{align*}
	s \Coloneqq		&\; s_{var} \;|\; s_{loc} \\
	\ty \Coloneqq 		&\; \tinst{s}{\eff} \;|\; \tarr{\ty}{\cty} \;|\; \tforall{s_{var}}{\cty} \\
	\cty \Coloneqq 		&\; \aty{\ty}{r} \\
	\val \Coloneqq		&\; x, y, z, k \;|\; \vinst{\loc} \;|\; \vabs{x}{\comp} \;|\; \vabst{s_{var}}{\comp} \\
	\comp \Coloneqq	&\; \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \;|\; \cop{\val}{\op}{\val} \;|\; \cappt{\val}{s} \\
					&\;|\; \cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}	\\
					&\;|\; \chandlen{s_{var}}{\comp}							\\
					&\;|\; \chandlec{s_{loc}}{\comp}							\\
					&\;|\; \chandlei{\loc}{\handler}{\comp}						\\
	\handler \Coloneqq	&\; \hop{\op}{x}{k}{\comp}{\handler} \;|\; \hreturn{x}{\comp} 	\\
\end{align*}
\label{fig:syntax-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:syntax-calc} we show the syntax of the types and terms of X.
An effect scope $s$ is either a scope variable $s_{var}$ or a scope location $s_{loc}$.
Effect scope variables $s_{var}$ and effects scope locations $s_{loc}$ are both modeled by countable infinite sets.
\\\\
Like in the systems in Chapter~4 terms and types are both split between values and computations, and value types and computation types.
Values are typed by value types and computations are typed by computation types.
\\\\
Value types $\ty$ are either an instance type $\tinst{s}{\eff}$, indexed by an effect scope $s$ and an effect $\eff$.
Or a function type $\tarr{\ty}{\cty}$ where the paramter type is a value type and the return type is a computation type.
Or an universally quantified computation type $\tforall{s_{var}}{\cty}$, where the domain of quantification are effect scopes.
\\\\
A computation type $\cty$ is always an annotated value type of the form $\aty{\ty}{r}$.
Annotations $r$ are sets of effect scopes $\{ s_1, ..., s_n \}$.
\\\\
Values are either variables $x$, $k$, where we always use $k$ do denote variables that refer to continuations.
Or instances $\vinst{\loc}$, indexed by some location $\loc$.
Instances would not appear in the surface language, but are introduced by the semantics.
Or lambda abstractions $\vabs{x}{\comp}$, where the body is a computation.
Or effect scope abstractions $\vabst{s_{var}}{\comp}$, where we abstract over a computation $\comp$, with the domain of the quantification being effect scopes.
\\\\
For computations we have $\creturn{\val}$, to lift a value $\val$ in to a computation.
We have application $\capp{\val}{\val}$ and sequencing $\cdo{x}{\comp}{\comp}$.
We have operation calls $\cop{\val}{\op}{\val}$.
The new constructs are as follows.
We have effect scope application $\cappt{\val}{s}$.
We can create new instances with $\cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}$, where $\handler$ is a handler.
We can handle computations with $\chandlen{s_{var}}{\comp}$.
Finally we have two more constructs which would not appear in the surface language, but are introduced by the semantics.
Effect scope handlers $\chandlec{s_{loc}}{\comp}$ handle a specific scope $s_{loc}$ in the computation $\comp$.
Instance handlers $\chandlei{\loc}{\handler}{\comp}$ handle the operations of a single instance of the location $\loc$ in the computation $\comp$.
\\\\
Finally we have handlers $\handler$ which are lists of operation cases ending with a return case.
Operation cases are of the form $\hop{\op}{x}{k}{\comp}{\handler}$, where $\handler$ is the rest of the handler.
Return cases are of the form $\hreturn{x}{\comp}$.

\section{Environments and judgments}
\label{sec:contexts}

\begin{figure}[h]
\caption{Environments}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
	\Gamma \Coloneqq 	& \cdot \;|\; \Gamma, x : \ty \\
	\Delta \Coloneqq 	& \cdot \;|\; \Delta, s_{var} \\
	\Sigma \Coloneqq  	& \cdot \;|\; \Sigma, s_{loc} \;|\; \Sigma, l := (s_{loc}, \eff) \\
\end{align*}
\label{fig:contexts}
\end{minipage}
}
\end{figure}

\textbf{Environments}
Before looking at the different judgments, we will introduce the three environments used.
The syntax for the environment are shown in figure \ref{fig:contexts}.
\begin{itemize}
\item $\Gamma$ is the typing enviroment which assigns variables $x$ to value types $\ty$.
\item $\Delta$ is the effect scope variable environment which keeps track of the scope variables $s_{var}$ that are in use.
\item $\Sigma$ is the dynamic environment which keeps track of scope location $s_{loc}$ and instance locations $l$. Instance locations are assigned a tuple of a scope location and an effect $(s_{loc}, \eff)$. $\Sigma$ is used in both the typing rules and the operational semantics.
\end{itemize}

\textbf{Judgments}
There are three kinds of judgments: subtyping, well-formedness and typing.
\\\\
The subtyping judgments are used to weaken the effect annotation of a computation type.
Weakening the effect annotation is sometimes necessary in order to type a program.
For example when typing the sequencing of two computations $\cdo{x}{\comp_1}{\comp_2}$, if the two computations do not agree on the effects then subtyping can be used to weaken both the computations such that the effect annotations agree.
There is a subtyping judgment for both the value types $\ty$ and the computation types $\cty$ these mutually depend on one another:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\subty{\ty}{\ty'}$ holds when the value type $\ty$ is a subtype of $\ty'$.
\item $\subty{\cty}{\cty'}$ holds when the computation type $\cty$ is a subtype of $\cty'$.
\end{itemize}

The well-formedness judgments check that scopes used in the types are valid under the scope variable and dynamic environments.
There are three judgments of this kind:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Sigma \vdash s$ checks that the scope $s$ is either in $\Delta$ if it is a scope variable or else in $\Sigma$ if it is a scope location.
\item $\Delta;\Sigma \vdash \ty$ checks that all the scopes in the value type $\ty$ are valid under the environments $\Delta$ and $\Sigma$.
\item $\Delta;\Sigma \vdash \cty$ checks that all the scopes in the computation type $\cty$ are valid under the environments $\Delta$ and $\Sigma$.
\end{itemize}

Lastly there are three typing judgments:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Sigma;\Gamma \vdash \val : \ty$ checks that the value $\val$ has the value type $\ty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash \comp : \cty$ checks that the computation $\comp$ has the computation type $\cty$ under the $\Delta$, $\Sigma$ and $\Gamma$ environments.
\item $\Delta;\Sigma;\Gamma \vdash^{\ty} h : \cty$ checks that the handler $h$ transform a return value of type $\ty$ to the computation type $\cty$.
\end{itemize}

\section{Subtyping}
\label{sec:subtyping}

\begin{figure}[h]
\caption{Subtyping}
\centering
\fbox{
\begin{minipage}{14 cm}
\[
\inferrule{
}{
	\subty{ \tinst{s}{\eff} }{ \tinst{s}{\eff} } 
}\quad(\footnotesize\textsc{Sub-Inst})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\subty{\ty_2}{\ty_1} \\
	\subty{\cty_1}{\cty_2} \\
}{
	\subty{ \tarr{\ty_1}{\cty_1} }{ \tarr{\ty_2}{\cty_2} }
}\quad(\footnotesize\textsc{Sub-Arr})
\hspace{3em}
\mprset{vskip=0 ex}
\]
\[
\inferrule{
	\subty{ \cty_1 }{ \cty_2 }
}{
	\subty{ \tforall{s_{var}}{\cty_1} }{ \tforall{s_{var}}{\cty_2} }
}\quad(\footnotesize\textsc{Sub-Forall})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\subty{ \ty_1 }{ \ty_2 } \\
	r_1 \subseteq r_2
}{
	\subty{ \aty{\ty_1}{r_1} }{ \aty{\ty_2}{r_2} }
}\quad(\footnotesize\textsc{Sub-Annot})
\]
\label{fig:subtyping-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:subtyping-calc} we give the subtyping rules for both the value and the computation types.
The subtyping checks that that the effects mentioned in the type on the right are the same or more general than the type on the left.
An instance type $\tinst{s}{\eff}$ is a subtype of another instance type if they are structurally equal, shown in the rule \textsc{Sub-Inst}.
Function types $\tarr{\ty}{\cty}$ are compared by subtyping the parameter types contravariantly and subtyping the return types covariantly, shown in the rule \textsc{Sub-Arr}.
Universally quantified types $\tforall{s_{var}}{\cty}$ are structurally recursed upon, given they the quantified variables are equal (\textsc{Sub-Forall}).
Lastly annotated types $\aty{\ty}{r}$ are compared by comparing the value types and checking that the annotation on the left type is a subtype of the annotation on the right type (\textsc{Sub-Annot}).

\section{Well-formedness}
\label{sec:wellformedness}

\begin{figure}[h]
\caption{Well-formedness}
\centering
\fbox{
\begin{minipage}{15 cm}
$$
\inferrule{
	s_{var} \in \Delta
}{
	\Delta;\Sigma \vdash s_{var}
}\quad(\footnotesize\textsc{WF-SVar})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	s_{loc} \in \Sigma
}{
	\Delta;\Sigma \vdash s_{loc}
}\quad(\footnotesize\textsc{WF-SLoc})
$$
$$\inferrule{
	\Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \tinst{s}{\eff}
}\quad(\footnotesize\textsc{WF-Inst})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma \vdash \ty \\
	\Delta;\Sigma \vdash \cty \\
}{
	\Delta;\Sigma \vdash \tarr{\ty}{\cty}
}\quad(\footnotesize\textsc{WF-Arr})
\hspace{3em}
\mprset{vskip=0 ex}
$$
$$
\inferrule{
	\Delta,s_{var};\Sigma \vdash \cty 
}{
	\Delta;\Sigma \vdash \tforall{s_{var}}{\cty}
}\quad(\footnotesize\textsc{WF-Forall})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta;\Sigma \vdash \ty \\
	\forall (s \in r) \Rightarrow \Delta;\Sigma \vdash s \\
}{
	\Delta;\Sigma \vdash \aty{\ty}{r}
}\quad(\footnotesize\textsc{WF-Annot})
$$
\label{fig:wf-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:wf-calc} we give the well-formedness rules for the value and computation types.
Well-formedness checks that the effect scopes in the type are accounted for in the environments.
The rules \textsc{WF-SVar} and \textsc{WF-SLoc} check that the effect scope variables $s_{var}$ and locations $s_{loc}$ are valid by checking that they are contained in the scope and dynamic environments respectively.
For instance types we check that the mentioned effect scope is valid (\textsc{WF-Inst}).
For function types $\tarr{\ty}{\cty}$ we check that both the paramter and return type is valid.
For universally quantified types $\tforall{s_{var}}{\cty}$ we check that the computation type $\cty$ is valid, after adding the variable $s_{var}$ to the environment.
Lastly for annotated types $\aty{\ty}{r}$ we first check that that the value type $\ty$ is valid.
Then we check that each effect scope in the annotation $r$ is valid.

\section{Typing rules}
\label{sec:typingrules}

\begin{figure}[h]
\caption{Value typing rules}
\centering
\fbox{
\begin{minipage}{14 cm}
$$\inferrule{
	\Gamma[x] = \ty
}{
	\Delta;\Sigma;\Gamma \vdash x : \ty
}\quad(\footnotesize\textsc{T-Var})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Sigma(\loc) = (s_{loc}, \eff)
}{
	\Delta;\Sigma;\Gamma \vdash \vinst{\loc} : \tinst{s_{loc}}{\eff}
}\quad(\footnotesize\textsc{T-Inst})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma, x : \ty \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty}{\cty}
}\quad(\footnotesize\textsc{T-Abs})
\hspace{3em}
\mprset{vskip=0 ex}
\inferrule{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \cty
}{
	\Delta;\Sigma;\Gamma \vdash \vabst{s_{var}}{\comp} : \tforall{s_{var}}{\cty}
}\quad(\footnotesize\textsc{T-TAbs})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_1 \\
	\Delta;\Sigma \vdash \ty_2 \\
	\subty{\ty_1}{\ty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \val : \ty_2
}\quad(\footnotesize\textsc{T-SubVal})
$$
\label{fig:val-typing-calc}
\end{minipage}
}
\end{figure}

The typing rules for the values are given in Figure~\ref{fig:val-typing-calc}.
The rules \textsc{T-Var}, \textsc{T-Abs} and \textsc{T-SubVal} are practically unchanged from the corresponding rules in the algebraic effects type system from Chapter~4.2.
Instances $\vinst{l}$ are assigned instance types, with the scope location and effect looked up in the dynamic environment $\Sigma$ using the location $l$ (\textsc{T-Inst}).
Similar to abstractions, effect scope abstractions are assigned a universally quantified type $\tforall{s_{var}}{\cty}$, by typing the body with $\cty$ after adding $s_{var}$ to the scope environment $\Delta$ (\textsc{T-TAbs}).

\begin{figure}[H]
\caption{Computation typing rules}
\centering
\fbox{
\begin{minipage}{12.2 cm}
$$\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val : \ty
}{
	\Delta;\Sigma;\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}\quad(\footnotesize\textsc{T-Return})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tarr{\ty}{\cty} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \ty \\
}{
	\Delta;\Sigma;\Gamma \vdash \capp{\val_1}{\val_2} : \cty
}\quad(\footnotesize\textsc{T-App})
$$
$$
\inferrule{
	\Delta;\Sigma \vdash s \\
	\Delta;\Sigma;\Gamma \vdash \val : \tforall{s'_{var}}{\cty}
}{
	\Delta;\Sigma;\Gamma \vdash \cappt{\val}{s} : \cty[s'_{var} := s]
}\quad(\footnotesize\textsc{T-TApp})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \comp_1 : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma,x:\ty_1 \vdash \comp_2 : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{T-Seq})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \val_1 : \tinst{s}{\eff} \\
	\op \in \Op{\eff} \\
	\Delta;\Sigma;\Gamma \vdash \val_2 : \pty{\op} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cop{\val_1}{\op}{\val_2} : \aty{\rty{\op}}{\{s\}}
}\quad(\footnotesize\textsc{T-Op})
$$
$$
\inferrule{
	\Delta;\Sigma \vdash s \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma,x:\tinst{s}{\eff} \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	s \in r \\
	\Delta;\Sigma;\Gamma,y : \ty_2 \vdash \comp' : \aty{\ty_3}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash \cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp} : \aty{\ty_3}{r}
}\quad(\footnotesize\textsc{T-New})
$$
$$
\inferrule{
	\Delta,s_{var};\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{var} \notin \ty
}{
	\Delta;\Sigma;\Gamma \vdash \chandlen{s_{var}}{\comp} : \aty{\ty}{(r \setminus \{ s_{var} \})}
}\quad(\footnotesize\textsc{T-Handle})
$$
$$
\inferrule{
	s_{loc} \in \Sigma \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{loc} \notin \ty
}{
	\Delta;\Sigma;\Gamma \vdash \chandlec{s_{loc}}{\comp} : \aty{\ty}{(r \setminus \{ s_{loc} \})}
}\quad(\footnotesize\textsc{T-HandleScope})
$$
$$
\inferrule{
	\Sigma(\loc) = (s_{loc}, \eff) \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Sigma;\Gamma \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	% s_{loc} \in r
}{
	\Delta;\Sigma;\Gamma \vdash \chandlei{\loc}{\handler}{\comp} : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{T-HandleInst})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_1 \\
	\Delta;\Sigma \vdash \cty_2 \\
	\subty{\cty_1}{\cty_2}
}{
	\Delta;\Sigma;\Gamma \vdash \comp : \cty_2
}\quad(\footnotesize\textsc{T-SubComp})
$$
\label{fig:comp-typing-calc}
\end{minipage}
}
\end{figure}

The typing rule for the computations are given in Figure~\ref{fig:comp-typing-calc}.
The rules \textsc{T-Return}, \textsc{T-App}, \textsc{T-Seq} and \textsc{T-SubComp} are practically unchanged from the corresponding rules in the algebraic effects type system from Chapter~4.2.
\\\\
The rule for effect scope application (\textsc{T-TApp}) checks that, in the application $\cappt{\val}{s}$, the scope $s$ is well-formed.
Then we check that $\val$ is a universally quantified type $\tforall{s'}{\cty}$.
Finally we substitute the given scope $s$ for the quantified variable $s'$ in $\cty$.
\\\\
For operation calls (\textsc{T-Op}) $\cop{\val_1}{op}{\val_2}$ we first check that the type of $\val_1$ is an instance type $\tinst{s}{\eff}$.
We then check that the operation $op$ is an operation of the effect of the instance $\eff$ ($op \in \Op{\eff}$).
Lastly we check that the given value $\val_2$ matches the parameter type of the operation $op$ ($\pty{op}$).
The type given to the operation call is the return type of the operation $\rty{op}$ with the scope of the instance, $s$, in the annotation.
\\\\
The rule \textsc{T-New} types the creation of new instance: $\cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp}$.
We are creating a new instance $x$ of effect $\eff$ in the effect scope $s$.
First we check that the given effect scope $s$ is valid.
Then we check that the operations in the handler $h$ are exactly the operations of the effect of the new instance $\eff$.
This means it is not valid to either omit operations or to have operations of other effects in the handler.
This way we can ensure that every operation is accounted for.
We then typecheck the computation $\comp$ with the new instance added the to the environment as $x$, with the type $\aty{\ty_1}{r}$.
Then we typecheck the handler $h$, passing the type $\ty_1$ of $\comp$ to the handler typing judgement.
The handler can transform the return type $\ty_1$ to another type $\ty_2$, but note that the effects annotation $r$ has to be the same.
We check that the scope $s$ is contained in $r$.
The reason for this is because the creation of an instance in $s$ is also an effect and so we have to account for this effect in the annotation by adding $s$ to $r$.
Lastly we check the $\mathsf{finally}$ case.
We add $\ty_2$ to the environment as $y$ and typecheck the computation $\comp'$ as $\aty{\ty_3}{r}$.
The $\mathsf{finally}$ case is allowed to transform the return type of the handler $\ty_2$ to another type $\ty_3$.
Finally the type of the whole instance creation is $\aty{\ty_3}{r}$.
Where $\ty_3$ is the final type of the $\mathsf{finally}$ case and $r$ is the effects from $\comp$, the handler $h$ and the $\mathsf{finally}$ case.
\\\\
The rule \textsc{T-Handle} types handling computations: $\chandlen{s_{var}}{\comp}$.
We typecheck the body $\comp$ with the effect scope variable $s_{var}$ added to the scope environment.
Then we check that the effects do not escape their scope by checking that that $s_{var}$ is not contained in the return type $\ty$.
We then type the whole computation as $\aty{\ty}{(r \setminus \{ s_{var} \})}$.
Knowing that $s_{var}$ does not escape we can safely remove it from the effect annotation.
\\\\
The rule \textsc{T-HandleScope} deals with the handling of a specific scope $s_{loc}$ and is very similar to the previous rule \textsc{T-Handle}.
Instead of the effect scope \emph{variable} $s_{var}$ we now deal with an effect scope \emph{location} $s_{loc}$.
We have to check that the location actually exists, by checking that it is contained in the dynamic environment $\Sigma$.
We can then proceed like in \textsc{T-Handle}, checking that $s_{loc}$ does not escape.
\\\\
\textsc{T-HandleInst} typechecks the handling of an instance at location $l$ using a handler $h$.
First we check that the $location$ is contained in the dynamic environment $\Sigma$
We retrieve the scope location $s_{loc}$ and effect $\eff$ of the instance from $\Sigma$.
We check that the operations in the handler match the operations of the effect.
We then typecheck the computation $\comp$ and the handler $h$ like in \textsc{T-New}.

\begin{figure}[h]
\caption{Handler typing rules}
\centering
\fbox{
\begin{minipage}{16 cm}
$$
\inferrule{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	\Delta;\Sigma;\Gamma,x:\pty{\op},k:\tarr{\rty{\op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hop{\op}{x}{k}{\comp}{\handler}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{T-HandlerOp})
$$
$$
\inferrule{
	\Delta;\Sigma;\Gamma,x : \ty_1 \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Sigma;\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{T-HandlerReturn})
$$
\label{fig:handler-typing-calc}
\end{minipage}
}
\end{figure}

Finally we discuss the typing rules for the handlers, given in Figure~\ref{fig:handler-typing-calc}.
\textsc{T-HandlerReturn} types the $\mathsf{return}$ case of a handler.
We typecheck the body $\comp$ after adding the variable $x$ with type $\ty_1$ to the environment.
The type $\ty_1$ is passed with the handler typing judgement in the typing rules \textsc{T-New} and \textsc{T-HandleInst}.
It is the return type of the computation we are handling.
The computation $\comp$ can transform this type to another type $\ty_2$ with some effect annotation $r$, which is the return type of the $\mathsf{return}$ case.
\\\\
The rule \textsc{T-HandlerOp} shows the typing of an operation case.
We first typecheck the rest of handler $h$, passing along the return type $\ty_1$ of the computation we are handling.
We typecheck the rest of the handler as $\aty{\ty_2}{r}$, this is the return type of the whole handler.
Then we typecheck the body of the operation case $\comp$.
We add the operation call argument $x$ with the parameter type $\pty{op}$ of the operation to the environment.
We also add the continuation $k$ to the environment.
This is a function from the return type $\rty{op}$ of the operation, to the return type of the whole handler $\aty{\ty_2}{r}$.
We check that the body of the case $\comp$ returns a computation of the same type.

\section{Semantics}
\label{sec:semantics}

Finally we give a small-step operational semantics for X.
\\\\
The rule $\comp_1 \;|\; \Sigma_1 \rightsquigarrow \comp_2 \;|\; \Sigma_2$ takes a step from the computation $\comp_1$ to $\comp_2$ in the dynamic environment $\Sigma_1$.
$\Sigma_1$ might be updated with new effect scope locations or instance locations resulting in $\Sigma_2$.

\begin{figure}[h]
\caption{Semantics}
\centering
\fbox{
\begin{minipage}{15 cm}
$$
\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}\quad(\footnotesize\textsc{S-App})
$$
$$
\inferrule{
}{
	\cappt{(\vabst{s_{var}}{\comp})}{s'} \;|\; \Sigma \rightsquigarrow \comp[s_{var} := s'] \;|\; \Sigma
}\quad(\footnotesize\textsc{S-TApp})
$$
$$
\inferrule{
	\comp_1 ; \Sigma \rightsquigarrow \comp'_1 ; \Sigma'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \;|\; \Sigma \rightsquigarrow (\cdo{x}{\comp'_1}{\comp_2}) \;|\; \Sigma'
}\quad(\footnotesize\textsc{S-Seq})
$$
$$
\inferrule{
}{
	(\cdo{x}{(\creturn{\val})}{\comp}) \;|\; \Sigma \rightsquigarrow \comp[x := \val] \;|\; \Sigma
}\quad(\footnotesize\textsc{S-SeqReturn})
$$
$$
\inferrule{
}{
	(\cdo{y}{(\cdo{x}{\comp_1}{\comp_2})}{\comp_3} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\comp_1}{\cdo{y}{\comp_2}{\comp_3}}) \;|\; \Sigma
}\quad(\footnotesize\textsc{S-Flatten})
$$
$$
\inferrule{
}{
	(\cdo{x}{(\cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{\comp_1})}{\comp_2}) \;|\; \Sigma \rightsquigarrow \\
	 \cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{(\cdo{x}{\comp_1}{\comp_2})} \;|\; \Sigma
}\quad(\footnotesize\textsc{S-LiftNew})
$$
$$
\inferrule{
	s_{loc} \notin \Sigma
}{
	\chandlen{s_{var}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp[s_{var} := s_{loc}]} \;|\; \Sigma,s_{loc}
}\quad(\footnotesize\textsc{S-FreshScope})
$$
\label{fig:semantics1-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:semantics1-calc} we give the semantics for every construct except the effect scope and instance handlers.
The rules \textsc{S-App}, \textsc{S-Seq}, \textsc{S-SeqReturn} and \textsc{S-Flatten} are the same as the corresponding rules in the
algebraic effects system of Chapter~4.2.
The rule \textsc{S-TApp} handles an effect scope application similarly to a normal application, by substituting the effect scope $s'$ for the scope variable $s_{var}$ of the scope abstraction.
\textsc{S-LiftNew} lifts the creation of an instance out and over sequencing.
By repeatedly applying this rule we can bubble up the instance creation until we hit an effect scope handler
The rule \textsc{S-FreshScope} creates a fresh scope location with which to handle instances.
A fresh scope location $s_{loc}$ is created and added to the environment $\Sigma$.
This new scope location is substituted in the body $\comp$.
We wrap the computation with an effect scope handler for new scope location $s_{loc}$.

\begin{figure}[h]
\caption{Semantics of effect scope handlers}
\centering
\fbox{
\begin{minipage}{17 cm}
$$
\inferrule{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlec{s_{loc}}{\comp} \;|\; \Sigma \rightsquigarrow \chandlec{s_{loc}}{\comp'} \;|\; \Sigma'
}\quad(\footnotesize\textsc{S-FreshScope})
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\creturn{\val} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow
	\cop{\val_1}{\op}{\val_2} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlec{s_{loc}}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\comp}} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\chandlec{s_{loc}}{\comp}}) \;|\; \Sigma
}
$$
$$
\inferrule{
	s_{loc} \neq s'_{loc}
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\chandlec{s_{loc}}{\comp}} \;|\; \Sigma
}
$$
$$
\inferrule{
	\loc \notin \mathsf{Dom}(\Sigma)
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s_{loc}}{\handler; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\chandlec{s_{loc}}{\cdo{y}{\chandlei{\loc}{\handler}{\comp[x := \vinst{\loc}]}}{\comp'}} \;|\; \Sigma,\loc := (s_{loc}, \eff)
}
$$
\label{fig:semantics2-calc}
\end{minipage}
}
\end{figure}

In Figure~\ref{fig:semantics2-calc} we give the semantics for the effect scope handlers.

\begin{figure}[h]
\caption{Semantics of instance handlers}
\centering
\fbox{
\begin{minipage}{17 cm}
$$
\inferrule{
	\comp \;|\; \Sigma \rightsquigarrow \comp' \;|\; \Sigma'
}{
	\chandlei{\loc}{\handler}{\comp} \;|\; \Sigma \rightsquigarrow \chandlei{\loc}{\handler}{\comp'} \;|\; \Sigma'
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler}{\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\comp}} \;|\; \Sigma \rightsquigarrow \\
	\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\chandlei{\loc}{\handler}{\comp}} \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler}{\cop{\val_1}{\op}{\val_2}} \;|\; \Sigma \rightsquigarrow
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\creturn{x}}} \;|\; \Sigma
}
$$
$$
\inferrule{
	\loc \neq \loc'
}{
	\chandlei{\loc}{\handler}{\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow
	(\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\chandlei{\loc}{\handler}{{\comp}}}) \;|\; \Sigma
}
$$
$$
\inferrule{
	\handler[\op] = (x, k, \comp_{\op})
}{
	\chandlei{\loc}{\handler}{\cdo{y}{\cop{\vinst{\loc}}{\op}{\val}}{\comp}} \;|\; \Sigma \rightsquigarrow 
	\comp_{\op}[x := \val, k := (\vabs{y}{\chandlei{\loc}{\handler}{\comp}})] \;|\; \Sigma
}
$$
$$
\inferrule{
}{
	\chandlei{\loc}{\handler; \hreturn{x_r}{\comp_r}}{\creturn{\val}} \;|\; \Sigma \rightsquigarrow
	\comp_r[x_r := \val] \;|\; \Sigma
}
$$
\label{fig:semantics3-calc}
\end{minipage}
}
\end{figure}

Lastly in Figure~\ref{fig:semantics3-calc} we give the semantics for the instance handlers.

\section{Type soundness}
\label{sec:theorems}

blablablabla.


}