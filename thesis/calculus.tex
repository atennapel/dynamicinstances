{
\newcommand\dynpart[1]{\colorbox{lightgray}{$#1$}}
\def\msquare{\mathord{\scalerel*{\Box}{gX}}}

% effects
\newcommand\Eff[0]{E}
\newcommand\eff[0]{\varepsilon}
\newcommand\Op[1]{O^{#1}}
\newcommand\op[0]{op}
\newcommand\inst[0]{\iota}

\newcommand\pty[1]{\ty^1_{#1}}
\newcommand\rty[1]{\ty^2_{#1}}

\newcommand\Loc[0]{L}
\newcommand\loc[0]{l}

% value types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tinst[2]{\mathsf{Inst} \; #1 \; #2}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\tforall[2]{\forall #1 . #2}
\newcommand\texists[2]{\exists #1 . #2}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[1]{\mathsf{inst}(#1)}
\newcommand\vabst[2]{\Lambda #1 . #2}
\newcommand\vabs[2]{\lambda #1 . #2}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cappt[2]{#1 \; [ #2 ]}
\newcommand\cpack[2]{\mathsf{pack} \; #1 \; \mathsf{in} \; #2}
\newcommand\cunpack[4]{\mathsf{unpack} \; #1 \; \mathsf{as} \; ( #2, #3 ) ;\; #4}
\newcommand\cdo[3]{#1 \leftarrow #2 ;\; #3}
\newcommand\cop[3]{#1 \# #2(#3)}
\newcommand\cfresh[2]{\mathsf{fresh} \; #1 ;\; #2}
\newcommand\cnew[5]{\mathsf{new} \; #1 @ #2 \; \{ #3 \} \; \mathsf{as} \; #4 \;\mathsf{in}\; #5}
\newcommand\chandle[1]{\mathsf{runscope} ( #1 )}
\newcommand\chandlen[2]{\mathsf{runscope} ( #1 \rightarrow #2 )}
\newcommand\chandlec[2]{\mathsf{runscope}^{#1} ( #2 )}
\newcommand\chandlei[4]{\mathsf{runinst}^{#1}_{#2} \{ #3 \} ( #4 )}

% handlers
\newcommand\handler[0]{h}
\newcommand\hop[5]{#1 \; #2 \; #3 \rightarrow #4 ; #5}
\newcommand\hreturn[2]{\mathsf{return} \; #1 \rightarrow #2}
\newcommand\hfinally[2]{\mathsf{finally} \; #1 \rightarrow #2}

% misc
\newcommand\subty[2]{#1 <: #2}
\newcommand\sep[0]{\;;\;}
\newcommand\sss[4]{#1 \; | \; #2 \rightsquigarrow #3 \; | \; #4}

\newenvironment{lines}{}{}

\newcommand\opsem[1]{\underset{#1}{\rightsquigarrow}}

% locations modelled by some countably infnite set.
% mathpartir
% explicit free variables fn FIV

% add substitution to type application
% more brackets in semantics

\chapter{\label{chap:langtheory}Semantics and types of \lang{}}

In this chapter we give a formal account of \lang{}.
We give the syntax, typing rules and a small-step operation semantics.
We end the chapter with a discussion on the difficulties of proving type safety for \lang{}.
The system builds on the formal system with algebraic effects, handlers and static instances of \cref{sec:theory-staticinst}.
We add constructs to handle effect scope polymorphism, to create new instances, and to handle effect scopes, as informally described in \cref{chap:langintro}.
\\\\
In \cref{sec:syntax} we give the syntax of the terms and types of \lang{}.
In \cref{sec:contexts} we give the environments and judgments used in the typing rules and semantics.
In \cref{sec:subtyping} we give subtyping rules for the types.
In \cref{sec:wellformedness} we give well-formedness rules for the types.
In \cref{sec:typingrules} we give the typing rules.
In \cref{sec:semantics} we give a small-step operation semantics for \lang{}.
Finally in \cref{sec:typesafety} we discuss the problems we encountered when trying to prove type safety.

\section{Syntax}
\label{sec:syntax}
Just like in the formal systems of algebraic effects of \cref{sec:theory-algeff} and \cref{sec:theory-staticinst}
we assume there is set of effect names $\mathsf{EffName}$ with $\Eff \subseteq \mathsf{EffName}$.
For example $\Eff = \{ \mathsf{Flip}, \mathsf{State}, \mathsf{Exc}, ... \}$.
There is also a set of operation names $\mathsf{O}$.
Each effect $\eff \in \Eff$ has a non-empty set of operation names $\Op{\eff} \in O$.
For example $\Op{\mathsf{Flip}} = \{\mathsf{flip}\}$ and $\Op{\mathsf{State}} = \{\mathsf{get}, \mathsf{put}\}$.
Every operation name only corresponds to a single effect.
Each operation $\op$ has a parameter type $\pty{\op}$ and a return type $\rty{\op}$.
\\\\

\begin{figure}
\caption{Syntax}
\centering
\fbox{
\begin{minipage}{10 cm}
\begin{align*}
	s \Coloneqq		&\; s_{var} \;|\; \dynpart{s_{loc}} \\
	\ty \Coloneqq 		&\; \tinst{s}{\eff} \;|\; \tarr{\ty}{\cty} \;|\; \tforall{s_{var}}{\cty} \\
	\cty \Coloneqq 		&\; \aty{\ty}{r} \\
	\val \Coloneqq		&\; x, y, z, k \;|\; \dynpart{\vinst{\loc}} \;|\; \vabs{x}{\comp} \;|\; \vabst{s_{var}}{\comp} \\
	\comp \Coloneqq	&\; \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \;|\; \cop{\val}{\op}{\val} \;|\; \cappt{\val}{s} \\
					&\;|\; \cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}	\\
					&\;|\; \chandlen{s_{var}}{\comp}							\\
					&\;|\; \dynpart{\chandlec{s_{loc}}{\comp}}							\\
					&\;|\; \dynpart{\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp}}						\\
	\handler \Coloneqq	&\; \hop{\op}{x}{k}{\comp}{\handler} \;|\; \hreturn{x}{\comp}
\end{align*}
\label{fig:syntax-calc}
\end{minipage}
}
\end{figure}

In \cref{fig:syntax-calc} we show the syntax of the types and terms of \lang{}.
We introduce some intermediate forms which are introduced by the semantics but do not appear in the source language.
We color these forms with a gray background.
\\\\
An effect scope $s$ is either a scope variable $s_{var}$ or a scope location $s_{loc}$.
Effect scope variables $s_{var}$ and effects scope locations $s_{loc}$ are both modeled by countable infinite sets.
\\\\
Like in the systems in \cref{chap:algtheory} terms and types are both split between values and computations, and value types and computation types.
Values are typed by value types and computations are typed by computation types.
\\\\
Value types $\ty$ are either an instance type $\tinst{s}{\eff}$, indexed by an effect scope $s$ and an effect $\eff$;
or a function type $\tarr{\ty}{\cty}$ where the parameter type is a value type and the return type is a computation type;
or a universally quantified computation type $\tforall{s_{var}}{\cty}$, where the domain of quantification are effect scopes.
\\\\
A computation type $\cty$ is always an annotated value type of the form $\aty{\ty}{r}$.
Annotations $r$ are sets of effect scopes $\{ s_1, ..., s_n \}$.
\\\\
Values are either variables $x$, $k$, where we always use $k$ do denote variables that refer to continuations;
or instances $\vinst{\loc}$, indexed by some instance location $\loc$, which are modeled by some countable infinite set.
Instances would not appear in the surface language, but are introduced by the semantics.
Values can also be lambda abstractions $\vabs{x}{\comp}$, where the body is a computation;
or effect scope abstractions $\vabst{s_{var}}{\comp}$, where we abstract over a computation $\comp$, with the domain of the quantification being effect scopes.
\\\\
As usual, for computations we have $\creturn{\val}$, to lift a value $\val$ in to a computation.
We have application $\capp{\val}{\val}$ and sequencing $\cdo{x}{\comp}{\comp}$.
We have operation calls $\cop{\val}{\op}{\val}$.
The new constructs are as follows.
We have effect scope application $\cappt{\val}{s}$.
We can create new instances with $\cnew{\eff}{s}{\handler ; \hfinally{x}{\comp}}{x}{\comp}$, where $\handler$ is a handler.
We can handle computations with $\chandlen{s_{var}}{\comp}$.
Finally we have two more intermediate constructs which would not appear in the surface language, but are introduced by the semantics.
Effect scope handlers $\chandlec{s_{loc}}{\comp}$ handle a specific scope $s_{loc}$ in the computation $\comp$.
Instance handlers $\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp}$ handle the operations of a single instance of the location $\loc$ in the computation $\comp$, we also keep track of the associated scope location $s_{loc}$ and effect $\eff$.
We will discuss these in \cref{sec:semantics}.
\\\\
Finally we have handlers $\handler$ which are lists of operation cases ending with a return case.
Operation cases are of the form $\hop{\op}{x}{k}{\comp}{\handler}$, where $\handler$ is the rest of the handler.
Return cases are of the form $\hreturn{x}{\comp}$.

\section{Environments and judgments}
\label{sec:contexts}
We will now give the environment and judgments used in the typing rules and semantics.

\begin{figure}[h]
\caption{Environments}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
	\Gamma \Coloneqq 	& \cdot \;|\; \Gamma, x : \ty \\
	\Delta \Coloneqq 	& \cdot \;|\; \Delta, s_{var} \;|\; \Delta, s_{loc} \;|\; \Delta, l := (s_{loc}, \eff) \\
	\sigma \Coloneqq  	& \cdot \;|\; \sigma, s_{loc} \;|\; \sigma, l
\end{align*}
\label{fig:contexts}
\end{minipage}
}
\end{figure}

\paragraph{Environments}
The syntax for the environments is shown in \cref{fig:contexts}.

\begin{itemize}
\item $\Gamma$ is the \emph{typing enviroment}, which assigns variables $x$ to value types $\ty$.
\item $\Delta$ is the \emph{static environment}, which keeps track of the scope variables $s_{var}$, scope locations $s_{loc}$, and instance locations $l$ that are in use. For instance locations we also keep track of the associated scope location $s_{loc}$ and effect $\eff$. Because instance locations depend on scope locations we introduce a well-formedness judgment for $\Delta$ in \cref{sec:wellformedness};
\item $\sigma$ is the \emph{dynamic environment}, which keeps track of scope location $s_{loc}$ and instance locations $l$. The dynamic environment is used to generate fresh scope and instance locations. This environment is only used by the semantics.
\end{itemize}

\paragraph{Judgments}
There are four kinds of judgments: subtyping (\cref{sec:subtyping}), well-formedness (\cref{sec:wellformedness}) and typing judgments (\cref{sec:typingrules}).
\\\\
The subtyping judgments are used to weaken the effect annotation of a computation type.
Weakening the effect annotation is sometimes necessary in order to type a program.
For example when typing the sequencing of two computations $\cdo{x}{\comp_1}{\comp_2}$, if the two computations do not agree on the effects then subtyping can be used to weaken both the computations such that the effect annotations agree.
There is a subtyping judgment for both the value types $\ty$ and the computation types $\cty$ these mutually depend on one another:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\subty{\ty}{\ty'}$ holds when the value type $\ty$ is a subtype of $\ty'$.
\item $\subty{\cty}{\cty'}$ holds when the computation type $\cty$ is a subtype of $\cty'$.
\end{itemize}

We have a well-formedness judgments for the static environment $\Delta$, scopes $s$, and value and computation types $\ty$ and $\cty$.
The well-formedness judgments have the following forms:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\vdash \Delta$ asserts that all instance locations in $\Delta$ refer to valid scope locations and that all scope variables and scope and instance locations are unique.
\item $\Delta \vdash s$ asserts that the scope $s$ exists in $\Delta$.
\item $\Delta \vdash \ty$ asserts that all the scopes in the value type $\ty$ are valid under $\Delta$.
\item $\Delta \vdash \cty$ asserts that all the scopes in the computation type $\cty$ are valid under $\Delta$.
\end{itemize}

Lastly, there are three typing judgments:
\begin{itemize}
\setlength\itemsep{0.5em}
\item $\Delta;\Gamma \vdash \val : \ty$ asserts that the value $\val$ has the value type $\ty$ under the $\Delta$ and $\Gamma$ environments.
\item $\Delta;\Gamma \vdash \comp : \cty$ asserts that the computation $\comp$ has the computation type $\cty$ under the $\Delta$ and $\Gamma$ environments.
\item $\Delta;\Gamma \vdash^{\ty} h : \cty$ asserts that the handler $h$ transform a return value of type $\ty$ to the computation type $\cty$.
\end{itemize}

\section{Subtyping}
\label{sec:subtyping}
\begin{figure}[h]
\caption{Subtyping}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{Sub-Inst}{
}{
	\subty{ \tinst{s}{\eff} }{ \tinst{s}{\eff} } 
}
\and
\inferH{Sub-Arr}{
	\subty{\ty_2}{\ty_1} \\
	\subty{\cty_1}{\cty_2} \\
}{
	\subty{ \tarr{\ty_1}{\cty_1} }{ \tarr{\ty_2}{\cty_2} }
}
\and
\inferH{Sub-Forall}{
	\subty{ \cty_1 }{ \cty_2 }
}{
	\subty{ \tforall{s_{var}}{\cty_1} }{ \tforall{s_{var}}{\cty_2} }
}
\and
\inferH{Sub-Annot}{
	\subty{ \ty_1 }{ \ty_2 } \\
	r_1 \subseteq r_2
}{
	\subty{ \aty{\ty_1}{r_1} }{ \aty{\ty_2}{r_2} }
}
\end{mathpar}
\label{fig:subtyping-calc}
\end{minipage}
}
\end{figure}

In \cref{fig:subtyping-calc} we give the subtyping rules for both the value and the computation types.
The subtyping checks that that the effects mentioned in the type on the right are the same or more general than the type on the left.
An instance type $\tinst{s}{\eff}$ is a subtype of another instance type if they are structurally equal, shown in the rule \textsc{Sub-Inst}.
Function types $\tarr{\ty}{\cty}$ are compared by subtyping the parameter types contravariantly and subtyping the return types covariantly, shown in the rule \textsc{Sub-Arr}.
Universally quantified types $\tforall{s_{var}}{\cty}$ are structurally recursed upon, given they the quantified variables are equal (\textsc{Sub-Forall}).
Lastly, annotated types $\aty{\ty}{r}$ are compared by comparing the value types and checking that the annotation on the left type is a subtype of the annotation on the right type (\textsc{Sub-Annot}).

\section{Well-formedness}
\label{sec:wellformedness}

\begin{figure}[h]
\caption{Well-formedness for $\Delta$}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{WFS-Empty}{
}{
	\vdash \cdot
}
\and
\inferH{WFS-ScopeVar}{
	\vdash \Delta \\
	s_{var} \notin \Delta
}{
	\vdash \Delta, s_{var}
}
\and
\inferH{WFS-ScopeLoc}{
	\vdash \Delta \\
	s_{loc} \notin \Delta
}{
	\vdash \Delta, s_{loc}
}
\and
\inferH{WFS-InstanceLoc}{
	\vdash \Delta \\
	l \notin \Delta \\
	s_{loc} \in \Delta
}{
	\vdash \Delta, l := (s_{loc}, \eff)
}
\end{mathpar}
\label{fig:wf-delta}
\end{minipage}
}
\end{figure}

\begin{figure}[h]
\caption{Well-formedness for scopes and types}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{WF-SVar}{
	\vdash \Delta \\
	s_{var} \in \Delta
}{
	\Delta \vdash s_{var}
}
\and
\inferH{WF-SLoc}{
	\vdash \Delta \\
	s_{loc} \in \Delta
}{
	\Delta \vdash s_{loc}
}
\and
\inferH{WF-Inst}{
	\Delta \vdash s \\
}{
	\Delta \vdash \tinst{s}{\eff}
}
\and
\inferH{WF-Arr}{
	\Delta \vdash \ty \\
	\Delta \vdash \cty \\
}{
	\Delta \vdash \tarr{\ty}{\cty}
}
\and
\inferH{WF-Forall}{
	\Delta,s_{var} \vdash \cty 
}{
	\Delta \vdash \tforall{s_{var}}{\cty}
}
\and
\inferH{WF-Annot}{
	\Delta \vdash \ty \\
	\forall (s \in r) \Rightarrow \Delta \vdash s \\
}{
	\Delta \vdash \aty{\ty}{r}
}
\end{mathpar}
\label{fig:wf-calc}
\end{minipage}
}
\end{figure}

In \cref{fig:wf-delta} we give the well-formedness rules for the static environment $\Delta$.
If $\Delta$ is empty then it is well-formed (\textsc{WFS-Empty}).
For scope locations $s_{loc}$ we check that the rest of $\Delta$ is well-formed and that $s_{loc}$ does not occur in it, meaning that $s_{loc}$ is unique (\textsc{WFS-ScopeLoc}).
For instance locations $l$ we also check that the rest of $\Delta$ is well-formed and that $l$ is unique.
Lastly, we check that the scope location $s_{loc}$ used by $l$ is defined in $\Delta$.
\\\\
In \cref{fig:wf-calc} we give the well-formedness rules for the value and computation types.
Well-formedness asserts that the effect scopes in the type are accounted for in $\Delta$.
The rules \textsc{WF-SVar} and \textsc{WF-SLoc} assert that the effect scope variables $s_{var}$ and locations $s_{loc}$ are valid by checking that they are contained in the static environment $\Delta$.
For instance types we check that the mentioned effect scope is valid (\textsc{WF-Inst}).
For function types $\tarr{\ty}{\cty}$ we check that both the parameter and return type is valid.
For universally quantified types $\tforall{s_{var}}{\cty}$ we check that the computation type $\cty$ is valid, after adding the variable $s_{var}$ to the environment.
Lastly, for annotated types $\aty{\ty}{r}$ we first check that that the value type $\ty$ is valid.
Then we check that each effect scope in the annotation $r$ is valid.

\section{Typing rules}
\label{sec:typingrules}

The typing rules for values, computations and handlers are given in \cref{fig:val-typing-calc}, \cref{fig:comp-typing-calc} and \cref{fig:handler-typing-calc}, respectively.
We call the typing rules for the intermediate forms (as given in \cref{sec:syntax}) the \emph{dynamic typing rules}.
As we will discuss in \cref{sec:typesafety} these typing rules are likely incomplete or incorrect.
We color the dynamic typing rules with a gray background.

\begin{figure}[h]
\caption{Value typing rules}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{T-Var}{
	\vdash \Delta \\
	\Gamma[x] = \ty
}{
	\Delta;\Gamma \vdash x : \ty
}
\and
\dynpart{
\inferH{T-Inst}{
	\vdash \Delta \\
	\Delta[\loc] = (s_{loc}, \eff)
}{
	\Delta;\Gamma \vdash \vinst{\loc} : \tinst{s_{loc}}{\eff}
}
}
\and
\inferH{T-Abs}{
	\Delta;\Gamma, x : \ty \vdash \comp : \cty
}{
	\Delta;\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty}{\cty}
}
\and
\inferH{T-SAbs}{
	\Delta,s_{var};\Gamma \vdash \comp : \cty
}{
	\Delta;\Gamma \vdash \vabst{s_{var}}{\comp} : \tforall{s_{var}}{\cty}
}
\and
\inferH{T-SubVal}{
	\Delta;\Gamma \vdash \val : \ty_1 \\
	\Delta \vdash \ty_2 \\
	\subty{\ty_1}{\ty_2}
}{
	\Delta;\Gamma \vdash \val : \ty_2
}
\end{mathpar}
\label{fig:val-typing-calc}
\end{minipage}
}
\end{figure}

The typing rules for the values are given in \cref{fig:val-typing-calc}.
The rules \textsc{T-Var}, \textsc{T-Abs} and \textsc{T-SubVal} are practically unchanged from the corresponding rules in the algebraic effects type system from \cref{sec:theory-algeff}.
Instances $\vinst{l}$ are assigned instance types, with the scope location and effect looked up in the static environment $\Delta$ using the location $l$ (\textsc{T-Inst}).
Similar to abstractions, effect scope abstractions are assigned a universally quantified type $\tforall{s_{var}}{\cty}$, by typing the body with $\cty$ after adding $s_{var}$ to $\Delta$ (\textsc{T-TAbs}).
\\\\
The typing rules for the computations are given in \cref{fig:comp-typing-calc}.
The rules \textsc{T-Return}, \textsc{T-App}, \textsc{T-Seq} and \textsc{T-SubComp} are practically unchanged from the corresponding rules in the algebraic effects type system from \cref{sec:theory-algeff}.
\\\\
The rule for effect scope application (\textsc{T-TApp}) asserts that, in the application $\cappt{\val}{s}$, the scope $s$ is well-formed.
Then we check that $\val$ is a universally quantified type $\tforall{s'}{\cty}$.
Finally we substitute the given scope $s$ for the quantified variable $s'$ in $\cty$.
\\\\
For operation calls (\textsc{T-Op}) $\cop{\val_1}{op}{\val_2}$ we first check that the type of $\val_1$ is an instance type $\tinst{s}{\eff}$.
We then check that the operation $op$ is an operation of the effect of the instance $\eff$ ($op \in \Op{\eff}$).
Lastly, we check that the given value $\val_2$ matches the parameter type of the operation $op$ ($\pty{op}$).
The type given to the operation call is the return type of the operation $\rty{op}$ with the scope of the instance, $s$, in the annotation.

\begin{figure}[H]
\caption{Computation typing rules}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{T-Return}{
	\Delta;\Gamma \vdash \val : \ty
}{
	\Delta;\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}
\and
\inferH{T-App}{
	\Delta;\Gamma \vdash \val_1 : \tarr{\ty}{\cty} \\
	\Delta;\Gamma \vdash \val_2 : \ty \\
}{
	\Delta;\Gamma \vdash \capp{\val_1}{\val_2} : \cty
}
\and
\inferH{T-SApp}{
	\Delta \vdash s \\
	\Delta;\Gamma \vdash \val : \tforall{s'_{var}}{\cty}
}{
	\Delta;\Gamma \vdash \cappt{\val}{s} : \cty[s'_{var} := s]
}
\and
\inferH{T-Seq}{
	\Delta;\Gamma \vdash \comp_1 : \aty{\ty_1}{r} \\
	\Delta;\Gamma,x:\ty_1 \vdash \comp_2 : \aty{\ty_2}{r} \\
}{
	\Delta;\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}
\and
\inferH{T-Op}{
	\Delta;\Gamma \vdash \val_1 : \tinst{s}{\eff} \\
	\op \in \Op{\eff} \\
	\Delta;\Gamma \vdash \val_2 : \pty{\op} \\
}{
	\Delta;\Gamma \vdash \cop{\val_1}{\op}{\val_2} : \aty{\rty{\op}}{\{s\}}
}
\and
\inferH{T-New}{
	\Delta \vdash s \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Gamma,x:\tinst{s}{\eff} \vdash \comp : \aty{\ty_1}{r} \\
	\Delta;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	s \in r \\
	\Delta;\Gamma,y : \ty_2 \vdash \comp' : \aty{\ty_1}{r} \\
}{
	\Delta;\Gamma \vdash \cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp} : \aty{\ty_1}{r}
}
\and
\inferH{T-Runscope}{
	\Delta,s_{var};\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{var} \notin \ty
}{
	\Delta;\Gamma \vdash \chandlen{s_{var}}{\comp} : \aty{\ty}{(r \setminus \{ s_{var} \})}
}
\and
\dynpart{
\inferH{T-RunscopeLoc}{
	s_{loc} \notin \Delta \\
	\Delta,s_{loc};\Gamma \vdash \comp : \aty{\ty}{r} \\
	s_{loc} \notin \ty \\
}{
	\Delta;\Gamma \vdash \chandlec{s_{loc}}{\comp} : \aty{\ty}{(r \setminus \{ s_{loc} \})}
}
}
\and
\dynpart{\inferH{T-Runinst}{
	l \notin \Delta \\
	\Delta \vdash s_{loc} \\
	\Delta,l := (s_{loc}, \eff) ;\Gamma \vdash \comp : \aty{\ty_1}{r} \\
	\op \in \Op{\eff} \iff \op \in \handler \\
	\Delta;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
}{
	\Delta;\Gamma \vdash \chandlei{\loc}{s_{loc},\eff}{\handler}{\comp} : \aty{\ty_2}{r}
}
}
\and
\inferH{T-SubComp}{
	\Delta;\Gamma \vdash \comp : \cty_1 \\
	\Delta \vdash \cty_2 \\
	\subty{\cty_1}{\cty_2}
}{
	\Delta;\Gamma \vdash \comp : \cty_2
}
\end{mathpar}
\label{fig:comp-typing-calc}
\end{minipage}
}
\end{figure}

The rule \textsc{T-New} types the creation of new instance: $\cnew{\eff}{s}{\handler; \hfinally{y}{\comp'}}{x}{\comp}$.
We are creating a new instance $x$ of effect $\eff$ in the effect scope $s$.
First we check that the given effect scope $s$ is valid.
Then we check that the operations in the handler $h$ are exactly the operations of the effect of the new instance $\eff$.
This means it is not valid to either omit operations or to have operations of other effects in the handler.
This way we can ensure that every operation is accounted for.
We then typecheck the computation $\comp$ with the new instance added the to the environment $\Gamma$ as $x$, with the type $\aty{\ty_1}{r}$.
Then we typecheck the handler $h$, passing the type $\ty_1$ of $\comp$ to the handler typing judgement.
The handler can transform the return type $\ty_1$ to another type $\ty_2$, but note that the effects annotation $r$ has to be the same.
We check that the scope $s$ is contained in $r$.
The reason for this is because the creation of an instance in $s$ is also an effect and so we have to account for this effect in the annotation by adding $s$ to $r$.
Lastly, we check the $\mathsf{finally}$ case.
We add $\ty_2$ to the environment as $y$ and typecheck the computation $\comp'$ as $\aty{\ty_1}{r}$.
Note that the $\mathsf{finally}$ case is not allowed to return a different type than the computation $\comp$.
Finally the type of the whole instance creation is $\aty{\ty_1}{r}$.
\\\\
The rule \textsc{T-Handle} types handling computations: $\chandlen{s_{var}}{\comp}$.
We typecheck the body $\comp$ with the effect scope variable $s_{var}$ added to the scope environment.
Then we check that the effects do not escape their scope by checking that that $s_{var}$ is not contained in the return type $\ty$.
We then type the whole computation as $\aty{\ty}{(r \setminus \{ s_{var} \})}$.
Knowing that $s_{var}$ does not escape we can safely remove it from the effect annotation.
\\\\
The rule \textsc{T-HandleScope} deals with the handling of a specific scope $s_{loc}$ and is very similar to the previous rule \textsc{T-Handle}.
Instead of the effect scope \emph{variable} $s_{var}$ we now deal with an effect scope \emph{location} $s_{loc}$.
We first check that $s_{loc}$ is not contained in $\Delta$, if this is the case then we would have duplicate scope locations.
We then proceed like in \textsc{T-Handle}, checking that $s_{loc}$ does not escape.
\\\\
The rule \textsc{T-HandleInst} typechecks the handling of an instance at location $l$ using a handler $h$.
First we check that $l$ is unique by checking it is not contained in $\Delta$.
Then we check that the scope location $s_{loc}$ is well-formed under $\Delta$.
We check that the operations in the handler match the operations of the effect.
We then typecheck the computation $\comp$ and the handler $h$ like in \textsc{T-New}, after adding $l$ to $\Delta$ with the associated scope location $s_{loc}$ and effect $\eff$.

\begin{figure}[h]
\caption{Handler typing rules}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{T-HandlerOp}{
	\Delta;\Gamma \vdash^{\ty_1} \handler : \aty{\ty_2}{r} \\
	\Delta;\Gamma,x:\pty{\op},k:\tarr{\rty{\op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Gamma \vdash^{\ty_1} (\hop{\op}{x}{k}{\comp}{\handler}) : \aty{\ty_2}{r}
}
\and
\inferH{T-HandlerReturn}{
	\Delta;\Gamma,x : \ty_1 \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Delta;\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}
\end{mathpar}
\label{fig:handler-typing-calc}
\end{minipage}
}
\end{figure}

Finally we discuss the typing rules for the handlers, given in \cref{fig:handler-typing-calc}.
\textsc{T-HandlerReturn} types the $\mathsf{return}$ case of a handler.
We typecheck the body $\comp$ after adding the variable $x$ with type $\ty_1$ to the environment.
The type $\ty_1$ is passed with the handler typing judgement in the typing rules \textsc{T-New} and \textsc{T-HandleInst}.
It is the return type of the computation we are handling.
The computation $\comp$ can transform this type to another type $\ty_2$ with some effect annotation $r$, which is the return type of the $\mathsf{return}$ case.
\\\\
The rule \textsc{T-HandlerOp} shows the typing of an operation case.
We first typecheck the rest of handler $h$, passing along the return type $\ty_1$ of the computation we are handling.
We typecheck the rest of the handler as $\aty{\ty_2}{r}$, this is the return type of the whole handler.
Then we typecheck the body of the operation case $\comp$.
We add the operation call argument $x$ with the parameter type $\pty{op}$ of the operation to the environment.
We also add the continuation $k$ to the environment.
This is a function from the return type $\rty{op}$ of the operation, to the return type of the whole handler $\aty{\ty_2}{r}$.
We check that the body of the case $\comp$ returns a computation of the same type.

\section{Semantics}
\label{sec:semantics}

Finally we give a small-step operational semantics for \lang{}
\\\\
The judgment $\comp_1 \opsem{\sigma} \comp_2$ takes a step from the computation $\comp_1$ to $\comp_2$ in the dynamic environment $\sigma$.
The environment $\sigma$ is used as a stack of in-scope scope locations and instance locations, and is also used to generate fresh locations.
$\sigma$ will always be monotically extended by $\rightsquigarrow$.

\begin{figure}[h]
\caption{Semantics}
\centering
\fbox{
\begin{minipage}{13 cm}
\begin{mathpar}
\inferH{S-App}{
}{
	\capp{(\vabs{x}{\comp})}{\val} \opsem{\sigma} \comp[x := \val]
}
\and
\inferH{S-SApp}{
}{
	\cappt{(\vabst{s_{var}}{\comp})}{s'} \opsem{\sigma} \comp[s_{var} := s']
}
\and
\inferH{S-Seq}{
	\comp_1 \opsem{\sigma} \comp'_1
}{
	(\cdo{x}{\comp_1}{\comp_2}) \opsem{\sigma} (\cdo{x}{\comp'_1}{\comp_2})
}
\and
\inferH{S-SeqReturn}{
}{
	(\cdo{x}{(\creturn{\val})}{\comp}) \opsem{\sigma} \comp[x := \val]
}
\and
\inferH{S-Flatten}{
}{
	(\cdo{y}{(\cdo{x}{\comp_1}{\comp_2})}{\comp_3} \opsem{\sigma}
	(\cdo{x}{\comp_1}{\cdo{y}{\comp_2}{\comp_3}})
}
\and
\inferH{S-LiftNew}{
}{
	(\cdo{x}{(\cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{\comp_1})}{\comp_2}) \opsem{\sigma} \\
	 \cnew{\eff}{s}{\handler ; \hfinally{z}{\comp_3}}{y}{(\cdo{x}{\comp_1}{\comp_2})}
}
\and
\inferH{S-Runscope}{
	s_{loc} \notin \sigma \\
	s_{loc} \notin c
}{
	\chandlen{s_{var}}{\comp} \opsem{\sigma} \chandlec{s_{loc}}{\comp[s_{var} := s_{loc}]}
}
\end{mathpar}
\label{fig:semantics1-calc}
\end{minipage}
}
\end{figure}

In \cref{fig:semantics1-calc} we give the semantics for every construct except the effect scope and instance handlers.
The rules \textsc{S-App}, \textsc{S-Seq}, \textsc{S-SeqReturn} and \textsc{S-Flatten} are the same as the corresponding rules in the
algebraic effects system of \cref{sec:theory-algeff}.
The rule \textsc{S-TApp} handles an effect scope application similarly to a normal application, by substituting the effect scope $s'$ for the scope variable $s_{var}$ of the scope abstraction.
\textsc{S-LiftNew} lifts the creation of an instance out and over sequencing.
By repeatedly applying this rule we can bubble up the instance creation until we hit an effect scope handler.
The rule \textsc{S-Runscope} creates a fresh scope location with which to handle instances.
A fresh scope location $s_{loc}$ is created, we aseert that $s_{loc}$ is fresh by checking it is not contained in $\sigma$ or $\comp$.
This new scope location is substituted in the body $\comp$ for $s_{var}$.
We then transform $\chandlen{s_{var}}{...}$ to the intermediate form $\chandlec{s_{loc}}{...}$, which is tagged with the scope location $s_{loc}$ which it will handle.

\begin{figure}[H]
\caption{Semantics of effect scope handlers}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{S-RunscopeCong}{
	\comp \opsem{\sigma,s_{loc}} \comp'
}{
	\chandlec{s_{loc}}{\comp} \opsem{\sigma} \chandlec{s_{loc}}{\comp'}
}
\and
\inferH{S-RunscopeReturn}{
}{
	\chandlec{s_{loc}}{\creturn{\val}} \opsem{\sigma}
	\creturn{\val}
}
\and
\inferH{S-RunscopeOp}{
}{
	\chandlec{s_{loc}}{\cop{\val_1}{\op}{\val_2}} \opsem{\sigma}
	\cop{\val_1}{\op}{\val_2}
}
\and
\inferH{S-RunscopeSeqOp}{
}{
	\chandlec{s_{loc}}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\comp}} \opsem{\sigma}
	(\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\chandlec{s_{loc}}{\comp}})
}
\and
\inferH{S-RunscopeNewSkip}{
	s_{loc} \neq s'_{loc}
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\comp}} \opsem{\sigma} \\
	\cnew{\eff}{s'_{loc}}{\handler ; \hfinally{y}{\comp'}}{x}{\chandlec{s_{loc}}{\comp}}
}
\and
\inferH{S-RunscopeNew}{
	\loc \notin \sigma \\
	\loc \notin \comp \\
	\loc \notin \comp'
}{
	\chandlec{s_{loc}}{\cnew{\eff}{s_{loc}}{\handler; \hfinally{y}{\comp'}}{x}{\comp}} \opsem{\sigma} \\
	\chandlec{s_{loc}}{\cdo{y}{\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp[x := \vinst{\loc}]}}{\comp'}}
}
\end{mathpar}
\label{fig:semantics2-calc}
\end{minipage}
}
\end{figure}

In \cref{fig:semantics2-calc} we give the semantics for the effect scope handlers.
An effect scope handler for a specific effect scope location will create fresh instances when a $\mathsf{new}$ construct is encountered (\textsc{S-RunscopeNew}).
An instance handler with the handler of the $\mathsf{new}$ construct is wrapped around the computation and the $\mathsf{finally}$ case is wrapped around that.
The newly created location $l$ is asserted to be fresh by checking that it is not contained in $\sigma$, $\comp$ and $\comp'$.
If a $\mathsf{new}$ is encountered with a different effect scope we skip it and nest the scope handler inside (\textsc{T-RunscopeNewSkip}).
Using the rule \textsc{S-RunscopeCong} we can reduce a computation inside a scope handler.
We add the scope location $s_{loc}$ to $\sigma$ to ensure newly created scope location are different from $s_{loc}$.
We can remove a scope handler if we encounter either a return or operation call (\textsc{S-RunscopeReturn} and \textsc{S-RunscopeOp}).
Effect scope handlers can be pushed inside sequencing, lifting an operation call over it (\textsc{S-RunscopeSeqOp}).
\\\\
Lastly, in \cref{fig:semantics3-calc} we give the semantics for the instance handlers.
Instance handlers handle operation calls on instances with the same location as the handler.
To be able to handle operation calls with one rule we first have to transform operation calls that are not being sequenced to the sequencing form (\textsc{S-RuninstOpPrepare}).
When an operation call is encountered on an instance with the same location as the instance handler, the operation is handled (\textsc{S-RuninstOp}).
The operation is looked up in the handler $h$ and the computation $c_{op}$ in the operation case is performed.
If a $\mathsf{return}$ is encountered the computation $c_r$ in the $\mathsf{return}$ case is performed (\textsc{S-HandleInstReturn}).
Operation calls on instances with a different location $l'$ are skipped, nesting the instance handler inside (\textsc{S-RuninstOpSkip}).
Similarly $\mathsf{new}$ calls are also skipped, again nesting the instance handler inside (\textsc{S-RuninstNew}).
Lastly, computations inside instance handlers can be reduced further (\textsc{S-RuninstCong}).
Similarly to scope locations, we add the instance location $l$ to $\sigma$ in order to ensure newly created locations are different from $l$.

\begin{figure}[H]
\caption{Semantics of instance handlers}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{mathpar}
\inferH{S-RuninstCong}{
	\comp \opsem{\sigma,\loc} \comp'
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp} \opsem{\sigma} \chandlei{\loc}{s_{loc},\eff}{\handler}{\comp'}
}
\and
\inferH{S-RuninstNew}{
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\comp}} \opsem{\sigma} \\
	\cnew{\eff}{s}{\handler' ; \hfinally{y}{\comp'}}{x}{\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp}}
}
\and
\inferH{S-RuninstOpPrepare}{
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\cop{\val_1}{\op}{\val_2}} \opsem{\sigma} \\
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\cdo{x}{\cop{\val_1}{\op}{\val_2}}{\creturn{x}}}
}
\and
\inferH{S-RuninstOpSkip}{
	\loc \neq \loc'
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\comp}} \opsem{\sigma} \\
	(\cdo{x}{\cop{\vinst{\loc'}}{\op}{\val}}{\chandlei{\loc}{s_{loc},\eff}{\handler}{{\comp}}})
}
\and
\inferH{S-RuninstOp}{
	\handler[\op] = (x, k, \comp_{\op})
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler}{\cdo{y}{\cop{\vinst{\loc}}{\op}{\val}}{\comp}} \opsem{\sigma} \\
	\comp_{\op}[x := \val, k := (\vabs{y}{\chandlei{\loc}{s_{loc},\eff}{\handler}{\comp}})]
}
\and
\inferH{S-RuninstReturn}{
}{
	\chandlei{\loc}{s_{loc},\eff}{\handler; \hreturn{x_r}{\comp_r}}{\creturn{\val}} \opsem{\sigma}
	\comp_r[x_r := \val]
}
\end{mathpar}
\label{fig:semantics3-calc}
\end{minipage}
}
\end{figure}

\paragraph{Example semantics derivation}
We now give an example derivation of a small program creating and manipulating a single $\mathsf{State}$ instance.
The program creates a new $\mathsf{State}$ on the scope $s$ called $r$, retrieves the current value, adds 1 and returns the new value. The instance is handled using the standard $\mathsf{State}$ handler, which we call $h$.
We give the used semantics rules on the right for every step.
When multiple rules are given we mean a nesting of rules.
For example $(\textsc{S-RunscopeCong, S-SeqReturn})$ means we use $\textsc{S-SeqReturn}$ on the computation inside of $\chandlec{s_{loc}}{\comp}$.
\begin{align*}
& \handler = \\
	&\hspace{1cm} \hop{get}{x}{k}{\creturn{(\vabs{st}{\cdo{f}{\capp{k}{st}}{\capp{f}{st}}})}}{\\
	&\hspace{1cm} \hop{put}{x}{k}{\creturn{(\vabs{st}{\cdo{f}{\capp{k}{()}}{\capp{f}{x}}})}}{\\
	&\hspace{1cm} \hreturn{x}{\creturn{(\vabs{st}{\creturn{x}})}}}} \\
\\
&\chandlen{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\\
	&\hspace{1cm} \cdo{x}{\cop{r}{\mathsf{get}}{}}{\cdo{\_}{\cop{r}{\mathsf{put}}{x + 1}}{\cop{r}{\mathsf{get}}{}}}}} \\
\end{align*}

\begin{align*}
&\chandlen{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\\
	&\hspace{1cm} \cdo{x}{\cop{r}{\mathsf{get}}{}}{\cdo{\_}{\cop{r}{\mathsf{put}}{x + 1}}{\cop{r}{\mathsf{get}}{}}}}} \\
& \opsem{} \tag{\textsc{S-Runscope}} \\
& \chandlec{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\\
	&\hspace{1cm} \cdo{x}{\cop{r}{\mathsf{get}}{}}{\cdo{\_}{\cop{r}{\mathsf{put}}{x + 1}}{\cop{r}{\mathsf{get}}{}}}}} \\
& \opsem{} \tag{\textsc{S-RunscopeNew}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cdo{x}{\cop{\vinst{l}}{\mathsf{get}}{}}{\cdo{\_}{\cop{\vinst{l}}{\mathsf{put}}{x + 1}}{\cop{\vinst{l}}{\mathsf{get}}{}}}}}{\capp{f}{0}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstOp}} \\
& \chandlec{s}{\cdo{f}{\creturn{(\vabs{st}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cdo{\_}{\cop{\vinst{l}}{\mathsf{put}}{x + 1}}{\cop{\vinst{l}}{\mathsf{get}}{}}}})}{st}}{\capp{f}{st}}})}}{f 0}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-SeqReturn}} \\
& \chandlec{s}{\capp{(\vabs{st}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cdo{\_}{\cop{\vinst{l}}{\mathsf{put}}{x + 1}}{\cop{\vinst{l}}{\mathsf{get}}{}}}})}{st}}{\capp{f}{st}}})}{0}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-App}} \\
& \chandlec{s}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cdo{\_}{\cop{\vinst{l}}{\mathsf{put}}{x + 1}}{\cop{\vinst{l}}{\mathsf{get}}{}}}})}{0}}{\capp{f}{0}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-App}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cdo{\_}{\cop{\vinst{l}}{\mathsf{put}}{0 + 1}}{\cop{\vinst{l}}{\mathsf{get}}{}}}}{\capp{f}{0}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstOp}} \\
& \chandlec{s}{\cdo{f}{(\creturn{(\vabs{st}{\cdo{f}{\capp{(\vabs{\_}{\chandlei{l}{s,\mathsf{State}}{h}{\\
	&\hspace{1cm} \cop{\vinst{l}}{\mathsf{get}}{}}})}{()}}{\capp{f}{(0 + 1)}}})})}{\capp{f}{0}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-SeqReturn}} \\
& \chandlec{s}{\capp{(\vabs{st}{\cdo{f}{\capp{(\vabs{\_}{\chandlei{l}{s,\mathsf{State}}{h}{\cop{\vinst{l}}{\mathsf{get}}{}}})}{()}}{\capp{f}{(0 + 1)}}})}{0}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-App}} \\
& \chandlec{s}{\cdo{f}{\capp{(\vabs{\_}{\chandlei{l}{s,\mathsf{State}}{h}{\cop{\vinst{l}}{\mathsf{get}}{}}})}{()}}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-App}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{\cop{\vinst{l}}{\mathsf{get}}{}}}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstOpPrepare}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{\cdo{x}{\cop{\vinst{l}}{\mathsf{get}}{}}{\creturn{x}}}}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstOp}} \\
& \chandlec{s}{\cdo{f}{(\creturn{(\vabs{st}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\creturn{x}}})}{st}}{\capp{f}{st}}})})}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-SeqReturn}} \\
& \chandlec{s}{\capp{(\vabs{st}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\creturn{x}}})}{st}}{\capp{f}{st}}})}{(0 + 1)}} \\
\end{align*}
\begin{align*}
& \opsem{} \tag{\textsc{S-RunscopeCong, S-App}} \\
& \chandlec{s}{\cdo{f}{\capp{(\vabs{x}{\chandlei{l}{s,\mathsf{State}}{h}{\creturn{x}}})}{(0 + 1)}}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-App}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{\creturn{(0 + 1)}}}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstReturn}} \\
& \chandlec{s}{\cdo{f}{\creturn (\vabs{st}{\creturn{(0 + 1)}})}{\capp{f}{(0 + 1)}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-SeqReturn}} \\
& \chandlec{s}{\capp{(\vabs{st}{\creturn{(0 + 1)}})}{(0 + 1)}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-App}} \\
& \chandlec{s}{\creturn{(0 + 1)}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-RunscopeReturn}} \\
& \creturn{(0 + 1)}
\end{align*}

One thing to notice from this derivation is that $\chandlec{s_{loc}}{...}$ remains wrapped around at the top until all operation calls on its scope are handled. Similarly $\chandlei{l}{s,\mathsf{State}}{h}{...}$ always remains wrapped around the part of the program that has operation calls on $l$.

\section{The problem with type safety}
\label{sec:typesafety}

Because our initial goal was to give a type safe language with algebraic effects and dynamic instances, it is important to formally proof type safety, in order to gain absolute certainty that our system is actually type safe. 
Like in \cref{sec:theory-algeff} we can give a Type safety theorem and a Preservation lemma:

\begin{theorem}[Type safety]
\[
	\mathsf{if}\;
		(\cdot;\cdot \vdash \comp : \aty{\ty}{\varnothing})
		\;\mathsf{and}\;
		(\comp \opsem{\cdot}^* \comp')
	\;\mathsf{then}\;
		\mathsf{value}(\comp')
		\;\mathsf{or}\;
		(\exists \comp''.\; \comp' \opsem{\cdot} \comp'')
\]
\end{theorem}

\begin{lemma}[Preservation]
\[
	\mathsf{if}\;
		(\Delta;\Gamma \vdash \comp : \cty)
		\;\mathsf{and}\;
		(\comp \opsem{\cdot} \comp')
	\;\mathsf{then}\;
		(\Delta;\Gamma \vdash \comp' : \cty)
\]
\end{lemma}

However because effect instances can escape their effect scope, Preservation does not hold for our given typing rules and semantics.
As a counter-example consider the following program (where $h$ is the handler from the example semantics derivation given earlier):
\[ \chandlen{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\creturn{(\vabs{\_}{\cdo{r'}{\creturn{r}}{\creturn{42}}})}}} \]

This program creates a new scope and creates a $\mathsf{State}$ instance named $r$ in it.
We then return a lambda abstraction which contains but does not use $r$, instead it returns $42$.
We can easily see that this program is of type $\tarr{()}{\aty{\mathsf{Int}}{\varnothing}}$.
We will give the semantics derivation for this program:
\newpage
\begin{align*}
&\chandlen{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\creturn{(\vabs{\_}{\cdo{r'}{\creturn{r}}{\creturn{42}}})}}} \\
& \opsem{} \tag{\textsc{S-Runscope}} \\
&\chandlec{s}{\cnew{\mathsf{State}}{s}{\handler ; \hfinally{f}{\capp{f}{0}}}{r}{\creturn{(\vabs{\_}{\cdo{r'}{\creturn{r}}{\creturn{42}}})}}} \\
& \opsem{} \tag{\textsc{S-RunscopeNew}} \\
& \chandlec{s}{\cdo{f}{\chandlei{l}{s,\mathsf{State}}{h}{
		\creturn{(\vabs{\_}{\cdo{r'}{\creturn{\vinst{l}}}{\creturn{42}}})}}}{\capp{f}{0}}} \\
& \opsem{} \tag{\textsc{S-RunscopeCong, S-Seq, S-RuninstReturn}} \\
& \chandlec{s}{\cdo{f}{\creturn{(\vabs{st}{\creturn{(\vabs{\_}{\cdo{r'}{\creturn{\vinst{l}}}{\creturn{42}}})}})}}{\capp{f}{0}}} \\
\end{align*}

At this point the $\vinst{l}$ is no longer under the $\chandlei{l}{s,\mathsf{State}}{h}{...}$, it has escaped its scope.
Because $\vinst{l}$ is not actually used, this is no problem for the semantics.
However the program does not typecheck anymore.
Once we get to $\vinst{l}$ we would use the typing rule $\textsc{T-Inst}$ to try to type it.
This will not work because $l$ is not in the static environment $\Delta$, because $l$ is only in $\Delta$ under $\chandlei{l}{s,\mathsf{State}}{h}{...}$!
Because of this Preservation does not hold, and we are unable to proof type safety.
This does not mean that type safety does not hold for \lang{}, it only means that the given dynamic typing rules for the intermediate forms are incomplete or incorrect.
\\\\
One possible approach to solving this problem is to look at a type safety proof for the simply-typed lambda calculus with references given in~\autocite{tapl}.
A store $\mu$ for reference assignments is used for the semantics.
The semantics judgment then has the form $t, \mu \rightsquigarrow t', \mu'$, with $\mu'$ being a possibly updated store (and $t$ some term).
For the typing rules a static environment $\Sigma$ is introduced which assign references to types.
The Preservation lemma then has the following form:
 
\begin{lemma}[Preservation]
\[
	\mathsf{if}\;
		(\Sigma;\Gamma \vdash t : \ty)
		\;\mathsf{and}\;
		(\Sigma;\Gamma \vdash \mu)
		\;\mathsf{and}\;
		(t,\mu \opsem{} t',\mu')
	\;\mathsf{then}\; \\
		(\exists \Sigma'.
			(\Sigma \subseteq \Sigma')
			\;\mathsf{and}\;
			(\Sigma';\Gamma \vdash t' : \ty)
			\;\mathsf{and}\;
			(\Sigma';\Gamma \vdash \mu')
		)
\]
\end{lemma}

This states that given a well-typed term $t$ and a well-typed store $\mu$.
If we take a step from $t$ to $t'$ with the store being updated to $\mu$.
Then there exists some static environment $\Sigma'$ that is an extension of $\Sigma$ such that $t$ is still well-typed with the same type under $\Sigma'$ and the updated store is also well-typed under $\Sigma'$.
\\\\
For our dynamic instances we can take a similar approach with our version of $\mu$ storing scope and instance locations. The static environment $\Sigma$ would have to store assignments of instance locations $l$ to scope locations $s_{loc}$ and effects $\eff$, so that we are able to give $\vinst{l}$ the correct instance type $(\tinst{s_{loc}}{\eff})$.
Due to time constraints we are unable to try out this approach but we conjecture it may allow use to prove a Preservation lemma and type safety.

}
