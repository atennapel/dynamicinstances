{
\newcommand\eff[0]{\epsilon}
\newcommand\Eff[0]{E}
\newcommand\Op[1]{O^{#1}}

% types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\thandler[2]{#1 \Rightarrow #2}
\newcommand\tforall[3]{\forall(#1:#2) . #3}
\newcommand\tinst[1]{\mathsf{inst}(#1)}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}
\newcommand\texists[3]{\exists(#1:#2) . #3}
\newcommand\texistss[2]{\exists \overrightarrow{#1} . #2}
% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vinst[0]{\iota}
\newcommand\vabst[3]{\Lambda(#1:#2) . #3}
\newcommand\vabs[2]{\lambda #1 . #2}
\newcommand\vappt[2]{#1 \; [ #2 ]}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\mathsf{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cdo[3]{#1 \leftarrow #2 ; #3}
\newcommand\cop[2]{#1(#2)}
\newcommand\copi[3]{#1 \# #2(#3)}
\newcommand\chandle[2]{\mathsf{handle} (#1) \{ #2 \}}
\newcommand\chandlei[3]{\mathsf{handle}^{#1} (#2) \{ #3 \}}
\newcommand\cnew[1]{\mathsf{new} \; #1}
\newcommand\cunpack[4]{(#1, #2) \leftarrow #3 ; #4}

%handlers
\newcommand\hop[5]{#1 \; #2 \; #3 \rightarrow #4 ; \; #5}
\newcommand\hreturn[2]{\mathsf{return}\; #1 \rightarrow #2}
\newcommand\hopc[4]{#1 \; #2 \; #3 \rightarrow #4}

In this chapter we will show the basics of algebraic effects and handlers. We will start with the simply-typed lambda calculus (\cref{section:stlc}) and add algebraic effects (\cref{section:algeff}) and instances (\cref{section:staticinst}, \cref{section:dynamicinst}) to it. We end with dynamic instances and show why a type system for them is difficult to implement.

\section{Simply-typed lambda calculus} \label{section:stlc}

As our base language we will take the fine-grained call-by-value simply-typed lambda calculus (FG-STLC) \cite{fg-stlc}.
This system is a version of the simply-typed lambda calculus with a syntactic distinction between values and computations.
Because of this distinction there is exactly one evaluation order: call-by-value.
In a system with side effects the evaluation order is very important since a different order could have a different result.
Having the evaluation order be apparent from the syntax is thus a good choice for a system with algebraic effects.
Another way to look at FG-STLC is to see it as a syntax for the lambda calculus that constrains the program to always be in A-normal form \cite{anormalform}.

%\subsection{Syntax}

\begin{figure}
\caption{Syntax of the fine-grained lambda calculus}
\centering
\fbox{
\begin{minipage}{6 cm}
\begin{align*}
& \val \Coloneqq x, y, z, k \;|\; \vabs{x}{\comp} \;|\; \vunit \\
& \comp \Coloneqq \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \\
\end{align*}
\label{fig:syntax-stlc}
\end{minipage}
}
\end{figure}

The terms are shown in Figure \ref{fig:syntax-stlc}.
The terms are split in to values and computations.
Values are pieces of data that have no effects, while computations are terms that may have effects.

\textbf{Values} We have $x$, $y$, $z$, $k$ ranging over variables, where we will use $k$ for variables that denote continuations later on.
Lambda abstractions are denoted as $\vabs{x}{\comp}$, note that the body $\comp$ of the abstraction is restricted to be a computation as opposed to the ordinary lambda calculus where the body can be any expression.
To keep things simple we take unit $\vunit$ as our only base value, this because adding more base values will not complicate the theory.
Using the unit value we can also delay computations by wrapping them in an abstraction that takes a unit value.
\\\\
\textbf{Computations} For any value $\val$ we have $\creturn{\val}$ for the computation that simply returns a value without performing any effects. We have function application $(\capp{\val}{\val})$, where both the function and argument have to be values. Sequencing computations is done with $(\cdo{x}{\comp}{\comp})$. Normally in the lambda calculus the function and the argument in an application could be any term and so a choice would have to be made in what order these have to be evaluated or whether to evaluate the argument at all before substitution. In the fine-grained calculus both the function and argument in $(\capp{\val}{\val})$ are values so there's no choice of evaluation order. The order is made explicit by the sequencing syntax $(\cdo{x}{\comp}{\comp})$.

%\subsection{Semantics}

\begin{figure}
\caption{Semantics of the fine-grained lambda calculus}
\centering
\fbox{
\begin{minipage}{11 cm}
\[\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{STLC-S-App})\]

\[\inferrule{
}{
	(\cdo{x}{\creturn{\val}}{\comp}) \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{STLC-S-SeqReturn})\]

\[\inferrule{
	\comp_1 \rightsquigarrow \comp_1'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \rightsquigarrow (\cdo{x}{\comp_1'}{\comp_2})
}\quad(\footnotesize\textsc{STLC-S-Seq})\]
\label{fig:semantics-stlc}
\end{minipage}
}
\end{figure}

\textbf{Semantics}
The small-step operational semantics is shown in Figure \ref{fig:semantics-stlc}.
The relation $\rightsquigarrow$ is defined on computations, where the $\comp \rightsquigarrow \comp'$ means $\comp$ reduces to $\comp'$ in one step.
These rules are a fine-grained approach to the standard reduction rules of the simply-typed lambda calculus.
In {\footnotesize\textsc{STLC-S-App}} we apply a lambda abstraction to a value argument, by substituting the value for the variable $x$ in the body of the abstraction.
In {\footnotesize\textsc{STLC-S-SeqReturn}} we sequence a computation that just returns a value in another computation by substituting the value for the variable $x$ in the computation.
Lastly, in {\footnotesize\textsc{STLC-S-Seq}} we can reduce a sequence of two computations, $\comp_1$ and $\comp_2$ by reducing the first, $\comp_1$.
\\\\
We define $\rightsquigarrow^*$ as the transitive-reflexive closure of $\rightsquigarrow$.
Meaning that $\comp$ in $\comp \rightsquigarrow^* \comp$ can reach $\comp'$ in zero or more steps, while $\comp$ in $\comp \rightsquigarrow \comp'$ reaches $\comp'$ in exactly on step.

%\subsection{Type system}

\begin{figure}
\caption{Types of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{4 cm}
\begin{align*}
& \ty \Coloneqq \tunit \;|\; \tarr{\ty}{\cty} \\
& \cty \Coloneqq \ty \\
\end{align*}
\label{fig:types-stlc}
\end{minipage}
}
\end{figure}

\textbf{Types}
Next we give the \emph{types} in Figure \ref{fig:types-stlc}.
Similar to the terms we split the syntax into value and computation types.
Values are typed by value types and computations are typed by computation types.
A value type is either the unit type $\tunit$ or a function type with a value type $\ty$ as argument type and a computation type  $\cty$ as return type.
\\\\
For the simply-typed lambda calculus a computation type is simply a value type, but when we add algebraic effects computation types will become more meaningful by recording the effects a computation may use.

\begin{figure}
\caption{Typing rules of the fine-grained simply-typed lambda calculus}
\centering
\fbox{
\begin{minipage}{10 cm}
\[\inferrule{
	\Gamma[x] = \ty
}{
	\Gamma \vdash x : \ty
}\quad(\footnotesize\textsc{STLC-T-Var})\]

\[\inferrule{
}{
	\Gamma \vdash \vunit : \tunit
}\quad(\footnotesize\textsc{STLC-T-Unit})\]

\[\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \cty_2
}{
	\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\cty_2}
}\quad(\footnotesize\textsc{STLC-T-Abs})\]

\[\inferrule{
	\Gamma \vdash \val : \ty
}{
	\Gamma \vdash \creturn{\val} : \cty
}\quad(\footnotesize\textsc{STLC-T-Return})\]

\[\inferrule{
	\Gamma \vdash \val_1 : \tarr{\ty_1}{\cty_2}\\
	\Gamma \vdash \val_2 : \ty_1
}{
	\Gamma \vdash \capp{\val_1}{\val_2} : \cty_2
}\quad(\footnotesize\textsc{STLC-T-App})\]

\[\inferrule{
	\Gamma \vdash \comp_1 : \cty_1\\
	\Gamma, x : \ty_1 \vdash \comp_2 : \cty_2
}{
	\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \cty_2
}\quad(\footnotesize\textsc{STLC-T-Seq})\]
\label{fig:typing-stlc}
\end{minipage}
}
\end{figure}

\textbf{Typing rules}
Finally we give the typing rules in Figure \ref{fig:typing-stlc}.
We have a typing judgment for values $\Gamma \vdash \val : \ty$ and a typing judgment for computations $\Gamma \vdash \comp : \cty$.
In both these judgments the context $\Gamma$ assigns value types to variables.
\\\\
The rules for variables ({\footnotesize\textsc{STLC-T-Var}}), unit ({\footnotesize\textsc{STLC-T-Unit}}), abstractions ({\footnotesize\textsc{STLC-T-Abs}}) and applications ({\footnotesize\textsc{STLC-T-App}}) are the standard typing rules of the simply-typed lambda calculus.
For $\creturn{\val}$ ({\footnotesize\textsc{STLC-T-Return}}) we simply check the type of $\val$.
For the sequencing of two computations $(\cdo{x}{\comp_1}{\comp_2})$ ({\footnotesize\textsc{STLC-T-Seq}}) we first check the type of $\comp_1$ and then check $\comp_2$ with the type of $\comp_1$ added to the context for $x$.

% \subsection{Examples}
\textbf{Examples}
To show the explicit order of evaluation we will translate the following program from the simply-typed lambda calculus into its fine-grained version:\\
\[\capp{\capp{f}{c_1}}{c_2}\]\\
Here we have a choice of whether to first evaluate $c_1$ or $c_2$ and whether to evaluate $(\capp{f}{c_2})$ before evaluating $c_2$.
In the fine-grained system the choice of evaluation order is made explicit by the syntax.
This means we can write down three variants for the above program, each having a different evaluation order.
In the presence of effects all three may have different results.

\begin{enumerate}
\itemsep0em 
\item $c_1$ before $c_2$, $c_2$ before $(\capp{f}{c_1})$ 
\[\cdo{x'}{c_1}{\cdo{y'}{c_2}{\cdo{g}{(\capp{f}{x'})}{(\capp{g}{y'})}}}\]
\item $c_2$ before $c_1$, $c_2$ before $(\capp{f}{c_1})$
\[\cdo{y'}{c_2}{\cdo{x'}{c_1}{\cdo{g}{(\capp{f}{x'})}{(\capp{g}{y'})}}}\]
\item $c_1$ before $c_2$, $(\capp{f}{c_1})$ before $c_2$
\[\cdo{x'}{c_1}{\cdo{g}{(\capp{f}{x'})}{\cdo{y'}{c_2}{(\capp{g}{y'})}}}\]
\end{enumerate}

To give a more concrete example, take a programming language based on the call-by-value lambda calculus that has arbitrary side-effects. Given a function $\mathsf{print}$ that takes an integer and prints it to the screen, we can define the following function $\mathsf{printRange}$ that prints a range of integers:
\begin{minted}[tabsize=2]{haskell}
-- given print : Int -> ()
printRange : Int -> Int -> ()
printRange a b =
	if a > b then
		()
	else
		(\a b -> ()) (print a) (printRange (a + 1) b)
\end{minted}
Here we use a lambda abstraction (\mintinline{haskell}{(\a b -> ())}) in order to simulate sequencing.
Knowing the evaluation order is very important when evaluating the call \mintinline{haskell}{(printRange 1 10)}.
In the expression \mintinline{haskell}{(\a b -> ()) (print a) (printRange (a + 1) b)} the arguments can be either evaluated left-to-right or right-to-left, corresponding to (1) and (2) in the list above respectively.
This makes a big difference in the output of the program, in left-to-right order the numbers 1 to 10 will be printed in increasing order while using a right-to-left evaluation strategy will print the numbers 10 to 1 in decreasing order.
A third option is to first evaluation \mintinline{haskell}{(print a)} then the call \mintinline{haskell}{(\a b -> ()) (print a)}, resulting in \mintinline{haskell}{(\b -> ()) (printRange (a + 1) b)}, after which this application is reduced. This corresponds to (3) in the list above, but has the same result as (1) in this example.
From the syntax of the language we are not able to deduce which evaluation order will be used, even worse it may be left undefined in the language definition.
\\\\
Translating the evaluation order corresponding to (1) to a language that uses a fine-grain style syntax results in:
\begin{minted}[tabsize=2]{haskell}
-- given print : Int -> ()
printRange : Int -> Int -> ()
printRange a b =
	if a > b then
		()
	else
		_ <- print a;
		printRange (a + 1) b
\end{minted}
Here from the syntax it is made clear that \mintinline{haskell}{print a} should be evaluated before \mintinline{haskell}{printRange (a + 1) b}, meaning a left-to-right evaluation order. Because the fine-grained lambda calculus has explicit sequencing syntax we do not have to use lambda abstraction (\mintinline{haskell}{(\a b -> ())}) for this purpose.
\\\\
Alternatively a translation that corresponds to evaluation order (2) results in:
\begin{minted}[tabsize=2]{haskell}
-- given print : Int -> ()
printRange : Int -> Int -> ()
printRange a b =
	if a > b then
		()
	else
		_ <- printRange (a + 1) b;
		print a
\end{minted}
Making clear we want a right-to-left evaluation order, printing the numbers in decreasing order.
\\\\
Because we have eliminated the lambda abstraction there is no translation corresponding to (3), but semantically it would be identical to the first (left-to-right) translation.

% \subsection{Theorems}
\textbf{Type soundness}
In order to prove type soundness for the previously defined calculus we first have define what it means for a computation to be a value.
We define a computation $\comp$ to be a value if $\comp$ is of the form $\creturn{\val}$ for some value $\val$.
	\[ \mathsf{value}(\comp) \;\mathsf{if}\; \exists \val. \comp = \creturn{\val} \]
Using this definition we can state the following type soundness theorem for the fine-grained simply typed lambda calculus.

\begin{theorem}[Type soundness]
\[
	\mathsf{if}\;
		\cdot \vdash \comp : \cty
		\;\land\;
		\comp \rightsquigarrow^* \comp'
	\;\mathsf{then}\;
		\mathsf{value}(\comp')
		\lor
		(\exists \comp''.\; \comp' \rightsquigarrow \comp'')
\]
\end{theorem}

This states that given a well-typed computation $\comp$ and taking some amount of steps then the resulting computation $\comp'$ will be of either a value or another step can be taken.
In other words the term will not get ``stuck''.
Note that this is only true if the computation $\comp$ is typed in the empty context.
If the context is not empty then the computation could get stuck on free variables.
\\\\
We can prove this theorem using the following lemmas:

\begin{lemma}[Progress]
\[
	\mathsf{if}\;
		\cdot \vdash \comp : \cty
	\;\mathsf{then}\;
		\mathsf{value}(\comp)
		\lor
		(\exists \comp'.\; \comp \rightsquigarrow \comp')
\]
\end{lemma}

\begin{lemma}[Preservation]
\[
	\mathsf{if}\;
		\Gamma \vdash \comp : \cty
		\;\land\;
		\comp \rightsquigarrow \comp'
	\;\mathsf{then}\;
		\Gamma \vdash \comp' : \cty
\]
\end{lemma}

Where the progress lemma states that given a well-typed computation $\comp$ then either $\comp$ is a value or $\comp$ can take a  step. The preservation lemma states that given a well-typed computation $\comp$ and if $\comp$ can take a step to $\comp'$ then $\comp'$ is also well-typed. We can prove both these by induction on the typing derivations. Note again that the context has to be empty for the Progress lemma, again because the computation could get stuck on free variables. For the Preservation lemma the context can be anything however, since the operational semantics will not introduce any new free variables that are not already in the context.

\newpage
\section{Algebraic effects} \label{section:algeff}

We now extend the previous calculus with algebraic effects and handlers.
We assume there is a set of effect names $\Eff = \{ \mathsf{Flip}, \mathsf{State}, ... \}$ and for each effect $\eff$ a set of operations $\Op{\eff}$.
For example $\Op{\mathsf{Flip}} = \{ \mathsf{flip} \}$ and $\Op{\mathsf{State}} = \{ \mathsf{get}, \mathsf{put} \}$.

\begin{figure}
\caption{Syntax of algebraic effects}
\centering
\fbox{
\begin{minipage}{10 cm}
\begin{align*}
& \val \Coloneqq x, y, z, k \;|\; \vabs{x}{\comp}	\;|\; \vunit \\
& \comp \Coloneqq \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \;|\; \cop{op}{\val} \;|\; \chandle{\comp}{h} \\
& h \Coloneqq \hop{op}{x}{k}{\comp}{h} \;|\; \hreturn{x}{\comp} \\
\end{align*}
\label{fig:syntax-algeff}
\end{minipage}
}
\end{figure}

\textbf{Syntax}
The syntax for the extended system is shown in figure \ref{fig:syntax-algeff}.
Values stay the same. We add two forms of computations, operation calls $\cop{op}{\val}$ where $op \in \Op{\eff}$ for some effect $\eff$ and
we can handle computations using $\chandle{\comp}{h}$.
Handlers $h$ are linked lists of operation cases $\hop{op}{x}{k}{\comp}{h}$ ending in the return case $\hreturn{x}{\comp}$.

\begin{figure}
\caption{Semantics of algebraic effects}
\centering
\fbox{
\begin{minipage}{16 cm}
\[\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{AlgEff-S-App})\]

\[\inferrule{
}{
	(\cdo{x}{\creturn{\val}}{\comp}) \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{AlgEff-S-SeqReturn})\]

\[\inferrule{
	\comp_1 \rightsquigarrow \comp_1'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \rightsquigarrow (\cdo{x}{\comp_1'}{\comp_2})
}\quad(\footnotesize\textsc{AlgEff-S-Seq})\]

\[\inferrule{
}{
	(\cdo{x}{(\cdo{y}{\comp_1}{\comp_2})}{\comp_3}) \rightsquigarrow (\cdo{y}{\comp_1}{(\cdo{x}{\comp_2}{\comp_3})})
}\quad(\footnotesize\textsc{AlgEff-S-Flatten})\]

\[\inferrule{
}{
	\cop{op}{\val} \rightsquigarrow (\cdo{x}{\cop{op}{\val}}{\creturn{x}})
}\quad(\footnotesize\textsc{AlgEff-S-Op})\]

\[\inferrule{
}{
	\chandle{\creturn{\val}}{h; \hreturn{x}{\comp}} \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{AlgEff-S-HandleReturn})\]

\[\inferrule{
	\hopc{op}{x}{k}{\comp'} \in h
}{
	\chandle{\cdo{y}{\cop{op}{\val}}{\comp}}{h} \rightsquigarrow \comp'[x := \val, k := (\vabs{y}{\chandle{\comp}{h}})]
}\quad(\footnotesize\textsc{AlgEff-S-HandleOp})\]

\[\inferrule{
	op \notin h
}{
	\chandle{\cdo{x}{\cop{op}{\val}}{\comp}}{h} \rightsquigarrow (\cdo{x}{\cop{op}{\val}}{\chandle{\comp}{h}})
}\quad(\footnotesize\textsc{AlgEff-S-HandleOpSkip})\]

\[\inferrule{
	\comp \rightsquigarrow \comp'
}{
	\chandle{\comp}{h} \rightsquigarrow \chandle{\comp'}{h}
}\quad(\footnotesize\textsc{AlgEff-S-Handle})\]
\label{fig:semantics-algeff}
\end{minipage}
}
\end{figure}

\textbf{Semantics}
We give a small-step operational semantics in figure \ref{fig:semantics-algeff}.
\textsc{AlgEff-S-App}, \textsc{AlgEff-S-SeqReturn} and \textsc{AlgEff-S-Seq} are the same as the \textsc{STLC-S-App}, \textsc{STLC-S-SeqReturn} and \
\textsc{STLC-S-Seq} in the fine-grained system.
To be able to handle a computation we first transform the computation to the form $\creturn{\val}$ or $(\cdo{x}{\cop{op}{\val}}{\comp})$.
\textsc{AlgEff-S-Flatten} and \textsc{AlgEff-S-Op} are used to get a computation to those forms.
The last four rules are used to handle a computation.
\textsc{AlgEff-S-HandleReturn} handles a computation of the form $\creturn{\val}$ by substituting $\val$ in the body of the return case of the handler.
\textsc{AlgEff-S-HandleOp} and \textsc{AlgEff-S-HandleOpSkip} handle computations of the form $(\cdo{x}{\cop{op}{\val}}{\comp})$.
If the operation $op$ is contained in the handler $h$ then the rule \textsc{AlgEff-S-HandleOp} substitutes the value $\val$ of the operation call in the body of the matching operation case $\comp'$.
We also substitute a continuation in $\comp'$, which continues with the computation $\comp$ wrapped by the same handler $h$.
If the operation $op$ is not contained in the handler then we float out the operation call $\cop{op}{\val}$ and wrap the handler $h$ around the continuing computation $\comp$.
Lastly \textsc{AlgEff-S-Handle} is able to reduce a computation in the handle computation.

\begin{figure}
\caption{Types of algebraic effects}
\centering
\fbox{
\begin{minipage}{6 cm}
\begin{align*}
& \ty \Coloneqq \tunit \;|\; \tarr{\ty}{\cty}	\\
& \cty \Coloneqq 	\aty{\ty}{r} \\
& r \Coloneqq \{ \eff_1, ..., \eff_n \} \\
\end{align*}
\label{fig:types-algeff}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Subtyping rules of algebraic effects}
\centering
\fbox{
\begin{minipage}{10 cm}
\[\inferrule{
}{
	\tunit <: \tunit
}\quad(\footnotesize\textsc{AlgEff-Sub-Unit})\]

\[\inferrule{
	\ty_3 <: \ty_1 \\
	\cty_2 <: \cty_4
}{
	\tarr{\ty_1}{\cty_2} <: \tarr{\ty_3}{\cty_4}
}\quad(\footnotesize\textsc{AlgEff-Sub-Arr})\]

\[\inferrule{
	\ty_1 <: \ty_2 \\
	r_1 \subseteq r_2
}{
	\aty{\ty_1}{r_1} <: \aty{\ty_2}{r_2}
}\quad(\footnotesize\textsc{AlgEff-Sub-Annot})\]
\label{fig:subtyping-algeff}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Typing rules of algebraic effects}
\centering
\fbox{
\begin{minipage}{14 cm}
\[\inferrule{
	\Gamma[x] = \ty
}{
	\Gamma \vdash x : \ty
}\quad(\footnotesize\textsc{AlgEff-T-Var})\]

\[\inferrule{
}{
	\Gamma \vdash \vunit : \tunit
}\quad(\footnotesize\textsc{AlgEff-T-Unit})\]

\[\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \cty_2
}{
	\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\cty_2}
}\quad(\footnotesize\textsc{AlgEff-T-Abs})\]

\[\inferrule{
	\Gamma \vdash \val : \ty_1 \\
	\ty_1 <: \ty_2
}{
	\Gamma \vdash \val : \ty_2
}\quad(\footnotesize\textsc{AlgEff-T-SubVal})\]

\[\inferrule{
	\Gamma \vdash \val : \ty
}{
	\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}\quad(\footnotesize\textsc{AlgEff-T-Return})\]

\[\inferrule{
	\Gamma \vdash \val_1 : \tarr{\ty_1}{\cty_2}\\
	\Gamma \vdash \val_2 : \ty_1
}{
	\Gamma \vdash \capp{\val_1}{\val_2} : \cty_2
}\quad(\footnotesize\textsc{AlgEff-T-App})\]

\[\inferrule{
	\Gamma \vdash \comp_1 : \aty{\ty_1}{r}\\
	\Gamma, x : \ty_1 \vdash \comp_2 : \aty{\ty_2}{r}
}{
	\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{AlgEff-T-Seq})\]

\[\inferrule{
	\Gamma[op] = (\eff, \ty^1_{op}, \ty^2_{op}) \\
	\Gamma \vdash \val : \ty^1_{op} \\
}{
	\Gamma \vdash \cop{op}{\val} : \aty{\ty^2_{op}}{\{ \eff \}}
}\quad(\footnotesize\textsc{AlgEff-T-Op})\]

\[\inferrule{
	\Gamma \vdash \comp : \aty{\ty_1}{r_1} \\
	op \in h \Leftrightarrow op \in O^\eff \\
	\Gamma \vdash^{\ty_1} h : \aty{\ty_2}{r_2}
}{
	\Gamma \vdash \chandle{\comp}{h} :\aty{\ty_2}{((r_1 \setminus \{\eff\}) \cup r_2)}
}\quad(\footnotesize\textsc{AlgEff-T-Handle})\]

\[\inferrule{
	\Gamma \vdash \comp : \cty_1 \\
	\cty_1 <: \cty_2
}{
	\Gamma \vdash \comp : \cty_2
}\quad(\footnotesize\textsc{AlgEff-T-SubComp})\]

\[\inferrule{
	\Gamma \vdash^{\ty_1} h : \aty{\ty_2}{r} \\
	\Gamma[op] = (\eff, \ty^1_{op}, \ty^2_{op}) \\
	\Gamma, x : \ty^1_{op}, k : \tarr{\ty^2_{op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Gamma \vdash^{\ty_1} (\hop{op}{x}{k}{\comp}{h}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{AlgEff-T-HOp})\]

\[\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \aty{\ty_2}{r}
}{
	\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{AlgEff-T-HReturn})\]
\label{fig:typing-algeff}
\end{minipage}
}
\end{figure}

\textbf{Type syntax}
We now give a type system which ensures that a program reduced by the given semantics will not get ``stuck'' meaning that the result will be a computation of the form $\creturn{\val}$ for some value $\val$.
In figure \ref{fig:types-algeff} we give the syntax of the types.
Value types $\ty$ are the same as in the fine-grained system.
Computation types $\cty$ are now of the form $\aty{\ty}{r}$ for some value type $\ty$.
An annotation $r$ is a set of effect names.

\textbf{Subtyping}
It is always valid in the system to weaken a type by adding more effects to an annotation.
This is done using subtyping judgments $\ty <: \ty$ and $\cty <: \cty$.
In figure \ref{fig:subtyping-algeff} we give the subtyping rules for the system.
Subtyping proceeds structurally on the value and computation types.
In \textsc{AlgEff-Sub-Arr} we compare function arguments contravariantly.
To compare two annotated types we compare the value types and then check that the annotation on the left is a subset of the annotation on the right.

\textbf{Typing rules}
Finally we give the typing rules in figure \ref{fig:typing-algeff}.
We have three judgements:
\begin{enumerate}
\item $\Gamma \vdash \val : \ty$, which types the value $\val$ with the value type $\ty$
\item $\Gamma \vdash \comp : \cty$, which types the computation $\comp$ with the computation type $\cty$
\item $\Gamma \vdash^{\ty} h : \cty$ which types the handler $h$ with the computation type $\cty$ given some value type $\ty$
\end{enumerate}
We can get the type of a variable from the context using $\Gamma[x] = \ty$.
For each operation $op$ we have a parameter type $\ty^1_{op}$ and a return type $\ty^2_{op}$.
We can retrieve the effect, parameter and return types of an operation from the context using $\Gamma[op] = (\eff, \ty^1_{op}, \ty^2_{op})$.
\\\\
\textsc{AlgEff-T-Var}, \textsc{AlgEff-T-Unit}, \textsc{AlgEff-T-Abs}, \textsc{AlgEff-T-App}, and \textsc{AlgEff-T-Seq} are the same as in the fine-grained system.
We can weaken the type of values and computations using subtyping using the rules \textsc{AlgEff-T-SubVal} and \textsc{AlgEff-T-SubComp}.
For return computations $\creturn{\val}$ we type the value and annotate it with the empty effect set using the rule \textsc{AlgEff-T-Return}.
\textsc{AlgEff-T-Op} shows that for operation calls we first lookup the operation in the context to find the effect, parameter and return types.
We then check that the argument of the operation call is of the same type as the paramter type of the operation.
Finally we type the operation call as an annotated type of the return type and a singleton effect set of the effect of the operation.
\\\\
For handling we use the rule \textsc{AlgEff-T-Handle}.
First we typecheck the type of the computation we are handling as having the computation type $\aty{\ty_1}{r_1}$.
Then we check that all operations in the handler $h$ are in the set of operations of some effect $\eff$, this means that handlers always have to contain exactly the operations of some effect.
We then typecheck the handler $h$, giving it the type of the computation we are handling $\ty_1$  and getting the return type $\aty{\ty_2}{r_2}$.
The return type of the handling computation is then $\ty_2$ annotated with the effects from the handled computation minus the effect $\eff$ we handled together with the effects from the handler.
\\\\
Finally the rules \textsc{AlgEff-T-HOp} and \textsc{AlgEff-T-HReturn} type the two cases of a handler.
\textsc{AlgEff-T-HReturn} checks that the computation $\comp$ of the return case types as $\aty{\ty_2}{r}$ after adding $x$ to $\Gamma$ with the given type $\ty_1$. $\aty{\ty_2}{r}$ is the return type of the handler.
\textsc{AlgEff-T-HOp} first checks the rest of the handler. Then the parameter and return types of the operation $op$ are retrieved.
Finally we add the parameter $x$ of the operation and the continuation $k$ to $\Gamma$ and check that the type of the computation $\comp$ agrees with the return type of the rest of the handler.

\textbf{Type soundness}
TODO \\
We define a computation $\comp$ to be a value if $\comp$ is of the form $\creturn{\val}$ for some value $\val$.
	\[ \mathsf{value}(\comp) \;\mathsf{if}\; \exists \val. \comp = \creturn{\val} \]

\begin{theorem}[Type soundness]
\[
	\mathsf{if}\;
		\cdot \vdash \comp : \aty{\ty}{\varnothing}
		\;\land\;
		\comp \rightsquigarrow^* \comp'
	\;\mathsf{then}\;
		\mathsf{value}(\comp')
		\lor
		(\exists \comp''.\; \comp' \rightsquigarrow \comp'')
\]
\end{theorem}

\begin{lemma}[Progress]
\[
	\mathsf{if}\;
		\cdot \vdash \comp : \aty{\ty}{\varnothing}
	\;\mathsf{then}\;
		\mathsf{value}(\comp)
		\lor
		(\exists \comp'.\; \comp \rightsquigarrow \comp')
\]
\end{lemma}

\begin{lemma}[Preservation]
\[
	\mathsf{if}\;
		\Gamma \vdash \comp : \cty
		\;\land\;
		\comp \rightsquigarrow \comp'
	\;\mathsf{then}\;
		\Gamma \vdash \comp' : \cty
\]
\end{lemma}

\newpage
\section{Static instances} \label{section:staticinst}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show problems with wanting to use multiple state instances
	\item What are static instances
	\item Show that static instances partially solve the problem
\end{itemize}

\subsection{Syntax}
\begin{figure}
\caption{Syntax of algebraic effects with static instances}
\centering
\fbox{
\begin{minipage}{12 cm}
\begin{align*}
& \val \Coloneqq x, y, z, k \;|\; \vabs{x}{\comp} \;|\; \vunit \;|\; \vinst \\
& \comp \Coloneqq \creturn{\val} \;|\; \capp{\val}{\val} \;|\; \cdo{x}{\comp}{\comp} \;|\;
		\copi{\val}{op}{\val} \;|\; \chandlei{\val}{\comp}{h} \\	\tag{handle} \\
& h \Coloneqq \hop{op}{x}{k}{\comp}{h} \;|\; \hreturn{x}{\comp} \\
\end{align*}
\label{fig:syntax-static}
\end{minipage}
}
\end{figure}

\subsection{Semantics}

\begin{figure}
\caption{Semantics of algebraic effects with static instances}
\centering
\fbox{
\begin{minipage}{18 cm}
\[\inferrule{
}{
	\capp{(\vabs{x}{\comp})}{\val} \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{Static-S-App})\]

\[\inferrule{
}{
	(\cdo{x}{\creturn{\val}}{\comp}) \rightsquigarrow \comp[x := \val]
}\quad(\footnotesize\textsc{Static-S-SeqReturn})\]

\[\inferrule{
}{
	(\cdo{x}{(\cdo{y}{\comp_1}{\comp_2})}{\comp_3}) \rightsquigarrow (\cdo{y}{\comp_1}{(\cdo{x}{\comp_2}{\comp_3})})
}\quad(\footnotesize\textsc{Static-S-Flatten})\]

\[\inferrule{
	\comp_1 \rightsquigarrow \comp_1'
}{
	(\cdo{x}{\comp_1}{\comp_2}) \rightsquigarrow (\cdo{x}{\comp_1'}{\comp_2})
}\quad(\footnotesize\textsc{Static-S-Seq})\]

\[\inferrule{
}{
	\copi{\val_1}{op}{\val_2} \rightsquigarrow (\cdo{x}{\copi{\val_1}{op}{\val_2}}{\creturn{x}})
}\quad(\footnotesize\textsc{Static-S-Op})\]

\[\inferrule{
}{
	\chandlei{\val_1}{\creturn{\val_2}}{h; \hreturn{x}{\comp}} \rightsquigarrow \comp[x := \val_2]
}\quad(\footnotesize\textsc{Static-S-HandleReturn})\]

\[\inferrule{
	\hopc{op}{x}{k}{\comp'} \in h
}{
	\chandlei{\vinst}{\cdo{y}{\copi{\vinst}{op}{\val}}{\comp}}{h} \rightsquigarrow \comp'[x := \val, k := (\vabs{y}{\chandlei{\vinst}{\comp}{h}})]
}\quad(\footnotesize\textsc{Static-S-HandleOp})\]

\[\inferrule{
	op \notin h \land \vinst_1 \neq \vinst_2
}{
	\chandlei{\vinst_1}{\cdo{x}{\copi{\vinst_2}{op}{\val}}{\comp}}{h} \rightsquigarrow (\cdo{x}{\copi{\vinst_2}{op}{\val}}{\chandlei{\vinst_1}{\comp}{h}})
}\quad(\footnotesize\textsc{Static-S-HandleOpSkip})\]

\[\inferrule{
	\comp \rightsquigarrow \comp'
}{
	\chandlei{\val}{\comp}{h} \rightsquigarrow \chandlei{\val}{\comp'}{h}
}\quad(\footnotesize\textsc{Static-S-Handle})\]
\label{fig:semantics-static}
\end{minipage}
}
\end{figure}

\subsection{Type system}

\begin{figure}
\caption{Types of algebraic effects with static instances}
\centering
\fbox{
\begin{minipage}{8 cm}
\begin{align*}
& \ty \Coloneqq \tunit \;|\; \tinst{\vinst} \;|\; \tarr{\ty}{\cty} \\
& \cty \Coloneqq \aty{\ty}{r} \\
& r \Coloneqq \{ \vinst_1, ..., \vinst_n \} \\
\end{align*}
\label{fig:types-static}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Subtyping rules of algebraic effects with static instances}
\centering
\fbox{
\begin{minipage}{10 cm}
\[\inferrule{
}{
	\tunit <: \tunit
}\quad(\footnotesize\textsc{Static-Sub-Unit})\]

\[\inferrule{
}{
	\tinst{\vinst} <: \tinst{\vinst}
}\quad(\footnotesize\textsc{Static-Sub-Unit})\]

\[\inferrule{
	\ty_3 <: \ty_1 \\
	\cty_2 <: \cty_4
}{
	\tarr{\ty_1}{\cty_2} <: \tarr{\ty_3}{\cty_4}
}\quad(\footnotesize\textsc{Static-Sub-Arr})\]

\[\inferrule{
	\ty_1 <: \ty_2 \\
	r_1 \subseteq r_2
}{
	\aty{\ty_1}{r_1} <: \aty{\ty_2}{r_2}
}\quad(\footnotesize\textsc{Static-Sub-Annot})\]
\label{fig:subtyping-algeff}
\end{minipage}
}
\end{figure}

\begin{figure}
\caption{Typing rules of algebraic effects with static instances}
\centering
\fbox{
\begin{minipage}{13 cm}
\[\inferrule{
	\Gamma[x] = \ty
}{
	\Gamma \vdash x : \ty
}\quad(\footnotesize\textsc{Static-T-Var})\]

\[\inferrule{
}{
	\Gamma \vdash \vunit : \tunit
}\quad(\footnotesize\textsc{Static-T-Unit})\]

\[\inferrule{
}{
	\Gamma \vdash \vinst : \tinst{\vinst}
}\quad(\footnotesize\textsc{Static-T-Inst})\]

\[\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \cty_2
}{
	\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\cty_2}
}\quad(\footnotesize\textsc{Static-T-Abs})\]

\[\inferrule{
	\Gamma \vdash \val : \ty_1 \\
	\ty_1 <: \ty_2
}{
	\Gamma \vdash \val : \ty_2
}\quad(\footnotesize\textsc{Static-T-SubVal})\]

\[\inferrule{
	\Gamma \vdash \val : \ty
}{
	\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}\quad(\footnotesize\textsc{Static-T-Return})\]

\[\inferrule{
	\Gamma \vdash \val_1 : \tarr{\ty_1}{\cty_2}\\
	\Gamma \vdash \val_2 : \ty_1
}{
	\Gamma \vdash \capp{\val_1}{\val_2} : \cty_2
}\quad(\footnotesize\textsc{Static-T-App})\]

\[\inferrule{
	\Gamma \vdash \comp_1 : \aty{\ty_1}{r}\\
	\Gamma, x : \ty_1 \vdash \comp_2 : \aty{\ty_2}{r}
}{
	\Gamma \vdash (\cdo{x}{\comp_1}{\comp_2}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{Static-T-Seq})\]

\[\inferrule{
	\Gamma \vdash \val_1 : \tinst{\vinst} \\
	\Gamma[\vinst] = \eff \\
	\Gamma[op] = (\eff, \ty^1_{op}, \ty^2_{op}) \\
	\Gamma \vdash \val_2 : \ty^1_{op} \\
}{
	\Gamma \vdash \copi{\val_1}{op}{\val_2} : \aty{\ty^2_{op}}{\{ \vinst \}}
}\quad(\footnotesize\textsc{Static-T-Op})\]

\[\inferrule{
	\Gamma \vdash \val : \tinst{\vinst} \\
	\Gamma[\vinst] = \eff \\
	\Gamma \vdash \comp : \aty{\ty_1}{r_1} \\
	op \in h \Leftrightarrow op \in O^\eff \\
	\Gamma \vdash^{\ty_1} h : \aty{\ty_2}{r_2}
}{
	\Gamma \vdash \chandlei{\val}{\comp}{h} :\aty{\ty_2}{((r_1 \setminus \{\vinst\}) \cup r_2)}
}\quad(\footnotesize\textsc{Static-T-Handle})\]

\[\inferrule{
	\Gamma \vdash \comp : \cty_1 \\
	\cty_1 <: \cty_2
}{
	\Gamma \vdash \comp : \cty_2
}\quad(\footnotesize\textsc{Static-T-SubComp})\]

\[\inferrule{
	\Gamma \vdash^{\ty_1} h : \aty{\ty_2}{r} \\
	\Gamma[op] = (\eff, \ty^1_{op}, \ty^2_{op}) \\
	\Gamma, x : \ty^1_{op}, k : \tarr{\ty^2_{op}}{\aty{\ty_2}{r}} \vdash \comp : \aty{\ty_2}{r} \\
}{
	\Gamma \vdash^{\ty_1} (\hop{op}{x}{k}{\comp}{h}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{Static-T-HOp})\]

\[\inferrule{
	\Gamma, x : \ty_1 \vdash \comp : \aty{\ty_2}{r}
}{
	\Gamma \vdash^{\ty_1} (\hreturn{x}{\comp}) : \aty{\ty_2}{r}
}\quad(\footnotesize\textsc{Static-T-HReturn})\]
\label{fig:typing-algeff}
\end{minipage}
}
\end{figure}

\subsection{Examples}
Show state with multiple static instances (references).

\newpage
\section{Dynamic instances (untyped)} \label{section:dynamicinst}

\subsection{Intro}
Explain:
\begin{itemize}
	\item Show that static instances require pre-defining all instances on the top-level.
	\item Static instances not sufficient to implement references.
	\item Show that dynamic instances are required to truly implement references.
	\item Show more uses of dynamic instances (file system stuff, local exceptions)
	\item No type system yet.
\end{itemize}

\subsection{Syntax}

\subsection{Semantics}

\subsection{Examples}
Show untyped examples.
\begin{itemize}
	\item Local exceptions
	\item ML-style references
\end{itemize}

\subsection{Type system (discussion, problems)}
Show difficulty of implementing a type system for this.
}