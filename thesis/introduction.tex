\iffalse
\begin{enumerate}
\item Side-effects are omnipresent
\item Give examples
\item Make programs hard to understand, test, debug, hard to compile
\item many parts are pure
\item give benefits for pure parts
\item we want presice control over pure/non-pure parts
\item want to keep track of effects
\item want to use certain effects locally and encapsulated
\end{enumerate}

\textbf{Explain side-effects generally}
- side-effects
- pure, non-pure
- pros, cons
\textbf{Desires for a language}
- factor non-pure from pure
- precise control
- track effects
- encapsulation
\textbf{Algebraic effects}
- brief explanation
- pros
- cons
\textbf{Our system}
- why
\fi

Side-effects are ubiquitous in programming.
Examples include mutable state, exceptions, nondeterminism, and user input.
Side-effects often make functions hard to understand, test and debug.
This is because that every invocation of the function with the same arguments may yield different results.
Furthermore side-effectful programs can also be difficult to optimize, since the compiler does not have much freedom in rearranging parts of the program.
\\\\
Any function that includes such effects is called impure, while functions whose only effect is computing a result are called pure.
Pure functions on the other hand do not rely on any global state and thus can be reasoned about in isolation of the rest of the program.
Every time a pure function is called with the same input, it will return the same output.
This means those functions are easier to understand, test and debug.
\\\\
There has been a lot of work on programming languages that allow more control over the pure and impure parts of a program.
Examples include Haskell\cite{haskell}, Eff\cite{eff1}, Koka\cite{koka2}, and Links\cite{links}.
These languages, in one way or another, give the programmer more control over which parts of their program are pure and which parts are impure.
By factoring out the pure parts from the impure parts, we can still gain the benefits of pure functions for many parts of our programs.
In addition it would be even better to be able to keep track of which effects exactly are used by which function.
They also allow some side-effects to be encapsulated, meaning that the use of a particular side-effect can be completely hidden such that the function still appears to be pure to the outside world.
\\\\
Type systems play an essential role in enforcing the distinction between pure and impure code.
By extending type systems to also show which effects a function may use, we can statically enfore which functions are pure and which are not.
This gives insight to the user to what a function may do when called, and also allows a compiler to do more interesting optimizations.
For example pure function calls may be reordered in any way that the compiler sees fit, while impure function calls may not, since the effects may interact.
Type systems that also keep track of effects are called type-and-effects systems.
Type-and-effects systems can have different levels of granularity.
For example one system could only keep track of a single bit per function, whether the function is impure or not.
More fine-grained systems are also possible, where each function is annotated with a set of effects that is used, where the set of possible effects is defined by the language.
For example in Koka a function which prints something to the console may be given the type:
\begin{minted}[tabsize=2]{haskell}
string -> <console> () 
\end{minted}
Where \textsc{console} shows the use of the console.
User-defined effects are also supported in languages such as Koka and Eff.
Users, in those systems, can define the effects with which the functions are annotated.
Type-and-effects systems can also allow for effect polymorphism.
For example a map function over lists takes a function and applies it to every element of the list, producing a new list with the transformed elements.
Systems with effect polymorphism will be able to give a type to this function by allowing the effects in the mapping function to be left abstract, represented by a type variable.
\\\\
Algebraic effects and handlers\cite{algeff} are an approach to programming with side-effects that has many of the desirable properties previously described.
Algebraic effects provide a way to factor out the pure parts, the operation calls, from the impure parts.
Users can define effects and easily use them in functions, with different effects composing without any extra effort.
Algebraic effects also easily admit typing, with different type-and-effect already proposed\cite{eff2}\cite{koka}\cite{links}.
Each effect is defined as a set of operations, for example nondeterminism can be represented by an operation which takes to values and chooses one.
Similarly, state can be defined as two operations, get and put, where get is meant to return the current value of the state and put is meant to change this value.
Functions are tagged by the set of effects they may use.
These operations can then be called anywhere in a function.
Handlers take a program that calls operations and for each operation call defines how to proceed.
For example the following piece of code defines an effect called \textit{State} which simulates a single mutable state cell.
The function \mintinline{haskell}{postInc} increments the current value in the state cell and returns the previous value.
\begin{minted}[tabsize=2]{haskell}
effect State {
	get : () -> Int
	put : Int -> ()
}

postInc : Int!{State}
postInc =
	x <- get ();
	put (x + 1);
	return x
\end{minted}

While algebraic effects and handlers have many of the desirable properties we would like, it is unable to express multiple mutable state cells.
In the previous example it can be seen that \mintinline{haskell}{postInc} does not refer to any variables, but instead can only manipulate the mutable state using the get and put operations.
In Haskell the the so-called ``ST monad''\cite{runst} can be used to safely implement multiple mutable state cells in such a way that stateful computations can be encapsulated and that the references to the mutable objects are not leaked outside of the function. 
A feature called dynamic instances was introduced by the Eff programming language\cite{eff1}.
With dynamic instances multiple different instances of the same effect can be dynamically created.
Using this multiple state cells can be implemented.
Unfortunately there is no type-and-effect for dynamic instances, using them can results in runtime errors when instances do not have an associated handler.
\\\\
In this thesis we define a calculus based on algebraic effects and handlers which allows for the definition of side-effects such as local references, local exceptions, and the dynamic opening of channels.
Using this system we can implement a system similar to the ``ST monad'' in Haskell.
This system gives full control of which parts of a program are pure and impure.
Functions also compose easily, irrelevant of which side-effects they use.
Using a type-and-effect system we every function keeps track of which effects it may use.
We also statically ensure that side-effects are encapsulated.
We give examples of programs using these side-effects in our system and show how to implement local mutable references in this system.
We give a formal description of the syntax, typing rules and semantics of the system.

\section*{Contributions}
\begin{itemize}

\item \textbf{Language}
We define a language based on algebraic effects and handlers that can handle a form of dynamic effect instances.
We give examples in our language that would be difficult or impossible to express with just algebraic effects.

\item \textbf{Operational semantics and type system}
We define a core calculus of our language together with a small-step operational semantics and a type system.

\item \textbf{Type soundness}
We prove type soundness of our type system with respect to the operational semantics via type preservation and progress for the core calculus.

\end{itemize}

\section*{Thesis structure}
The thesis is structured as follows.
Chapter 2 gives an introduction to algebraic effects and handlers, and static and dynamic instances.
Chapter 3 gives an introduction to our proposed language.
Chapter 4 gives formal definitions of systems with algebraic effecst and handlers, and static instances.
Chapter 5 gives a formal account of X.
Chapter 6 discusses related work.
Chapter 7 concludes the thesis and discusses future work.
