\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{minted}
\usepackage{fitch}

\usepackage[parfill]{parskip}

% effects
\newcommand\Eff[0]{E}
\newcommand\eff[0]{\varepsilon}
\newcommand\Op[0]{O}
\newcommand\op[0]{op}
\newcommand\inst[0]{\iota}

\newcommand\pty[1]{\ty^1_{#1}}
\newcommand\rty[1]{\ty^2_{#1}}

% types
\newcommand\ty[0]{\tau}
\newcommand\tunit[0]{()}
\newcommand\tarr[2]{#1 \rightarrow #2}
\newcommand\thandler[2]{#1 \Rightarrow #2}

% computation type
\newcommand\cty[0]{\underline{\ty}}
\newcommand\aty[2]{#1 \; ! \; #2}
\newcommand\texists[3]{\exists(#1:#2) . #3}
\newcommand\texistss[2]{\exists \overrightarrow{#1} . #2}

% values
\newcommand\val[0]{\nu}
\newcommand\vunit[0]{()}
\newcommand\vabs[2]{\lambda #1 . #2}
\newcommand\vhandler[1]{\textit{handler} \; \{#1\}}
\newcommand\vhandleri[2]{\textit{handler} ( #1 ) \; \{#2\}}
\newcommand\vhandlerc[0]{\vhandler{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}
\newcommand\vhandlerci[1]{\vhandleri{#1}{
	\textit{return} \; x \rightarrow \comp,
	\op_1(x ; k) \rightarrow \comp,
	...,
	\op_n(x ; k) \rightarrow \comp
}}

% computations
\newcommand\comp[0]{c}
\newcommand\creturn[1]{\textit{return} \; #1}
\newcommand\capp[2]{#1 \; #2}
\newcommand\cdo[3]{#1 \leftarrow #2 ; #3}
\newcommand\cop[4]{#1(#2 ; #3 . #4)}
\newcommand\copi[5]{#1 \# #2(#3 ; #4 . #5)}
\newcommand\chandle[2]{\textit{with} \; #1 \; \textit{handle} \; #2}
\newcommand\cnew[1]{\textit{new} \; #1}

% misc
\newcommand\subty[2]{#1 <: #2}
\newcommand\sep[0]{\;;\;}

\lstset{
	frame = single,
	basicstyle=\ttfamily\footnotesize,
	breaklines=true
}

\title{An effect system for dynamic instances}
\author{Albert ten Napel}
\date{}

\begin{document}
\maketitle

\section{Effect handler effect system}

\subsection{Introduction}
We extend a simplified version of the type system described by Bauer and Pretnar in \cite{effectsystem}.
We simplify the system from that paper by removing static instances and always having handlers contain all operations from a single effect.
We extend the system with instance type variables,  existential computation types and a computation to dynamically create instances.
For the effect annotations on the computation types (called the dirt in \cite{effectsystem}) we will take sets of instance variables. 

\newpage
\subsection{Syntax}
We assume there is set of effect names $\Eff = \{ \eff_1, ..., \eff_n \}$.
Each effect has a set of operation names $\Op_\eff = \{ \op_1, ..., \op_n \}$.
We every operation name only corresponds to a single effect.
Each operation has a parameter type $\pty{\op}$ and a return type $\rty{\op}$.
Annotations $r$ are sets of instance variables.
\\
\begin{align*}
	\ty \Coloneqq 				& 											\tag{value types} \\
									& i, j, k									\tag{instance variables} \\
									& \tunit									\tag{unit type} \\
									& \tarr{\ty}{\cty}						\tag{type of functions} \\
									& \thandler{\cty}{\cty}				\tag{type of handlers} \\
	\cty \Coloneqq 			& 											\tag{computation types} \\
									& \aty{\ty}{r}							\tag{annotated type} \\
									& \texists{i}{\eff}{\cty}				\tag{existential} \\
	\val \Coloneqq			&											\tag{values} \\
									& x, y, z, k								\tag{variables} \\
									& \vunit									\tag{unit value} \\
									& \iota^\mathbb{N}						\tag{instances} \\
									& \vabs{x}{\comp}					\tag{abstraction} \\
									& \vhandlerci{\val}						\tag{handler} \\
	\comp \Coloneqq		&											\tag{computations} \\
									& \creturn{\val}						\tag{return value as computation} \\
									& \capp{\val}{\val}					\tag{application} \\
									& \cdo{x}{\comp}{\comp}			\tag{sequencing} \\
									& \chandle{\val}{\comp}			\tag{handler application} \\
									& \copi{\val}{\op}{\val}{y}{\comp}	\tag{operation call} \\
									& \cnew{\eff}							\tag{instance creation} \\
\end{align*}

\newpage
\subsection{Subtyping rules}

The subtyping rules are mostly the same as the rules described in \cite{effectsystem}, but we add two rules for the instance variables and the existential types.
These are as you would expect.

\begin{minipage}{0.5\textwidth}
\[\frac{
}{
	\subty{\tunit}{\tunit}
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\subty{a'}{a} \\
	\subty{b}{b'}
	\end{array}
}{
	\subty{\tarr{a}{b}}{\tarr{a'}{b'}}
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\subty{a'}{a} \\
	\subty{b}{b'}
	\end{array}
}{
	\subty{\thandler{a}{b}}{\thandler{a'}{b'}}
}\]\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\subty{a}{a'} \\
	e \subseteq e'
	\end{array}
}{
	\subty{\aty{a}{e}}{\aty{a'}{e'}}
}\]\vspace{10pt}
\end{minipage}

\begin{minipage}{0.5\textwidth}
\[\frac{
}{
	\subty{i}{i}
}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\subty{a}{b}
}{
	\subty{\texists{i}{\eff}{a}}{\texists{i}{\eff}{b}}
}\]
\end{minipage}

\subsection{Well-formedness judgement}
We have a well-formedness judgement for both value and computation types $\Delta \vdash \ty$ and $\Delta \vdash \cty$.
Where $\Delta$ stores bindings of instance variables to effects.
For instance variables we simply check that they occur in $\Delta$.
For computation types we check that all the variables in the annotation occur in $\Delta$.
\\

\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	\end{array}
}{
	\Delta \vdash \tunit
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	(i : \eff) \in \Delta \\
	\end{array}
}{
	\Delta \vdash i
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta \vdash a  \\
	\Delta \vdash b
	\end{array}
}{
	\Delta \vdash \tarr{a}{b}
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta \vdash a  \\
	\Delta \vdash b
	\end{array}
}{
	\Delta \vdash \thandler{a}{b}
}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta \vdash a  \\
	\Delta \vdash j_i
	\end{array}
}{
	\Delta \vdash \aty{a}{\{ j_0, ..., j_n \}}
}\]
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta , i : \eff \vdash a  \\
	\end{array}
}{
	\Delta \vdash \texists{i}{\eff}{a}
}\]
\end{minipage}

\newpage
\subsection{Typing rules}
For the typing rules there are two judgments,
$\Delta;\Gamma \vdash \val : \ty$ for assigning types to values and $\Delta;\Gamma \vdash \comp : \cty$ for assigning computation types to computations. $\Gamma$ stores bindings of variables to types and $\Delta$ stores bindings of instance variables to effects $\eff$.
In the sub-typing and abstraction rules we check that the introduced types are well-formed, so that we don't introduce ill-formed types in the context.

\begin{minipage}{0.25\textwidth}
\textbf{T-SubVal}
\end{minipage}
\begin{minipage}{0.25\textwidth}
\textbf{T-Var}
\end{minipage}
\begin{minipage}{0.25\textwidth}
\textbf{T-Unit}
\end{minipage}
\begin{minipage}{0.25\textwidth}
\textbf{T-Abs}
\end{minipage}

\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash \val : \ty_1 \\
	\Delta \vdash \ty_2 \\
	\subty{\ty_1}{\ty_2}
	\end{array}
}{
	\Delta;\Gamma \vdash \val : \ty_2
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
	(x:\ty) \in \Gamma
}{
	\Delta;\Gamma \vdash x : \ty
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
}{
	\Delta;\Gamma \vdash \vunit : \tunit
}\]
\end{minipage}
\begin{minipage}{0.25\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta \vdash \ty_1 \\
	\Delta;\Gamma, x : \ty_1 \vdash \comp : \cty_2
	\end{array}
}{
	\Delta;\Gamma \vdash \vabs{x}{\comp} : \tarr{\ty_1}{\cty_2}
}\]
\end{minipage}

\vspace{10pt}
In the following rule \\$h = 
	\vhandleri{\val}{
		\textit{return} \; x_r \rightarrow \comp_r,
		\op_1(x_1 ; k_1) \rightarrow \comp_1,
		...,
		\op_n(x_n ; k_n) \rightarrow \comp_n
	}$.\\
For the handlers we first check that value $\val$ is bound to an instance variable $i$ of effect $\eff$.
We check that the operations in the handlers are exactly the operations belonging to $\eff$.
After we check that all the cases in the handler agree on the return type and annotations.
We have the condition $r_1 \backslash \{ i \} \subseteq r_2$ to make sure that any extra effects before the handler remain unhandled after the handler is evaluated.
We check that the types on the left and right sides of the handler type are well-formed to make sure that no instance variables are introduced that are not in the context $\Delta$.
\\\textbf{T-Handler}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash \val : i \\
	(i:\eff)\in\Delta \\
	\Op_\eff = \{ op_1, ..., op_n \} \\
	\Delta \vdash \ty_1 \\
	\Delta;\Gamma, x_r : \ty_1 \vdash \comp_r : \aty{\ty_2}{r_2} \\
	\Delta;\Gamma, x_i : \pty{\op_i}, k_i : \tarr{\rty{\op_i}}{\aty{\ty_2}{r_2}} \vdash \comp_i : \aty{\ty_2}{r_2} \\
	r_1 \backslash \{ i \} \subseteq r_2 \\
	\end{array}
}{
	\Delta;\Gamma \vdash h :
	\thandler{\aty{\ty_1}{r_1}}{\aty{\ty_2}{r_2}}
}\]

\newpage
%%%
Explain...\\
\begin{minipage}{0.5\textwidth}
\textbf{T-SubComp}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\textbf{T-Return}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash \comp : \cty_1 \\
	\Delta \vdash \cty_2 \\
	\subty{\cty_1}{\cty_2}
	\end{array}
}{
	\Delta;\Gamma \vdash \comp : \cty_2
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\Delta;\Gamma \vdash \val : \ty
}{
	\Delta;\Gamma \vdash \creturn{\val} : \aty{\ty}{\varnothing}
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\textbf{T-App}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\textbf{T-Handle}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash \val_1 : \tarr{\ty_1}{\cty_2} \\
	\Delta;\Gamma \vdash \val_2 : \ty_1
	\end{array}
}{
	\Delta;\Gamma \vdash \capp{\val_1}{\val_2} : \cty_2
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta,\overrightarrow{i};\Gamma \vdash \val : \thandler{\cty_1}{\cty_2} \\
	\Delta;\Gamma \vdash \comp : \texistss{i}{\cty_1} \\
	\end{array}
}{
	\Delta;\Gamma \vdash \chandle{\val}{\comp} : \texistss{i}{\cty_2}
}\]
\vspace{10pt}
\end{minipage}
\\


Instances are checked to be in $\Delta$.\\
\textbf{T-Instance}
\[\frac{
	\begin{array}{l}
	(i:\eff)\in\Delta \\
	\end{array}
}{
	\Delta;\Gamma \vdash \iota^i : i
}\]



For the operation calls we check that the value $\val_1$ is bound to an instance variable $i$ of effect $\eff$.
We check that the operation belongs to $\eff$ and that the value $\val_2$ is of the parameter type of the operation.
We then typecheck the continuation $c$ and make sure that the instance variable $i$ is in the annotation on the type of $c$. \\
For the creation of instances we return an existential type to account for the newly created instance. \\
\begin{minipage}{0.5\textwidth}
\textbf{T-Op}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\textbf{T-New}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash \val_1 : i \\
	(i:\eff)\in\Delta \\
	\op \in \Op_\eff\\
	\Delta;\Gamma \vdash \val_2 : \pty{\op} \\
	\Delta;\Gamma , y : \rty{\op} \vdash \comp : \texistss{j}{\aty{\ty}{r}} \\
	i \in r
	\end{array}
}{
	\Delta;\Gamma \vdash \copi{\val_1}{\op}{\val_2}{y}{\comp} : \texistss{j}{\aty{\ty}{r}}
}\]
\vspace{10pt}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\[\frac{
}{
	\Delta;\Gamma \vdash \cnew{\eff} : \texists{i}{\eff}{\aty{i}{\varnothing}}
}\]
\vspace{10pt}
\end{minipage}
\newpage
We can remove existential quantifiers at any point so long as the instance variable is not contained in the free instance variable of the type. \\
\textbf{T-ExistsRemove}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash c : \texists{i}{\eff}{\cty} \\
	i \notin FIV(\cty)
	\end{array}
}{
	\Delta;\Gamma \vdash c : \cty
}\]

For sequencing we want both $c_1$ and $c_2$ to have existential types, where $\overrightarrow{i}$ and $\overrightarrow{j}$ are sequenced of bindings. If either $c_1$ or $c_2$ do not have existential types we can introduce them with the previous rule.
To typecheck $c_2$ with all the bindings $\overrightarrow{i}$ introduced in the context $\Delta$. For the return type we concatenate all the bindings $\overrightarrow{i}$ and $\overrightarrow{j}$ and we take the union of the annotations $r_1$ of $c_1$ and the annotations $r_2$ of $c_2$. \\
\textbf{T-Do}
\[\frac{
	\begin{array}{l}
	\Delta;\Gamma \vdash c_1 : \texistss{i}{\aty{\ty_1}{r_1}} \\
	\Delta,\overrightarrow{i} ; \Gamma, x : \ty_1 \vdash c_2 : \texistss{j}{\aty{\ty_2}{r_2}}
	\end{array}
}{
	\Delta;\Gamma \vdash \cdo{x}{c_1}{c_2} : \texistss{i}{\texistss{j}{\aty{\ty_2}{(r_1 \cup r_2)}}}
}\]

\subsection{Semantics}
We give the small-step operational semantics for the system.
We have the relation $\comp; \mathbb{N} \rightsquigarrow \comp;\mathbb{N}$ where $\comp$ is the current computation and $\mathbb{N}$ the id of the next instance that will be created. \\
For abstractions we have the usual beta-reduction rule.\\
\[\frac{
}{
	\capp{(\vabs{x}{\comp})}{\val}\sep i \rightsquigarrow \comp[\val/x]\sep i
}\]
For instance creation we replace the call to $new$ with the instance constant and we increase the instance id counter.\\
\[\frac{
}{
	\cnew{E}\sep i \rightsquigarrow \creturn{\iota^i}\sep i + 1
}\]
\newpage
For sequencing we have three rules. The first rule reduces the first computation.
The second rule substitutes the value of a return computation in the second computation.
The last rule floats an operation call over the sequencing, this makes the handle computation easier, since we won't have to think about sequencing inside of a handle computation.\\
\[\frac{
	\comp_1\sep i \rightsquigarrow \comp'_1\sep i'
}{
	(\cdo{x}{\comp_1}{\comp_2})\sep i \rightsquigarrow (\cdo{x}{\comp'_1}{\comp_2})\sep i'
}\]
\[\frac{
}{
	(\cdo{x}{\creturn{\val}}{\comp})\sep i \rightsquigarrow \comp[\val/x]\sep i
}\]
\[\frac{
}{
	(\cdo{x}{\copi{j}{\op}{\val}{y}{\comp_1}}{\comp_2})\sep i \rightsquigarrow \copi{j}{\op}{\val}{y}{(\cdo{x}{\comp_1}{\comp_2})}\sep i
}\]

In the following rules \\$h = 
	\vhandleri{j}{
		\textit{return} \; x_r \rightarrow \comp_r,
		\op_1(x_1 ; k_1) \rightarrow \comp_1,
		...,
		\op_n(x_n ; k_n) \rightarrow \comp_n
	}$.\\
We can reduce the computation that we want to handle.\\
\[\frac{
	\comp\sep i \rightsquigarrow \comp'\sep i'
}{
	\chandle{h}{\comp}\sep i \rightsquigarrow \chandle{h}{\comp'}\sep i'
}\]
If we are handling a return computation we simply substitute the value in the return case of the handler.\\
\[\frac{
}{
\chandle{h}{(\creturn{\val})}\sep i \rightsquigarrow \comp_r[\val/x_r]\sep i
}\]
If we are handling an operation call where the instance matches the instance of the handler and the operation is in the handler then we can reduce to the corresponding operation clause with the parameter value and the continuation substituted.
Note that we nest the handle computation inside of the continuation, this describes deep handlers.\\
\[\frac{
	\op_i \in \{\op_1, ..., \op_n \}
}{
	\chandle{h}{(\copi{j}{\op_i}{\val}{x}{\comp})}\sep i \rightsquigarrow \comp_i[\val/x_i, (\vabs{x}{\chandle{h}{\comp}})/k_i]\sep i
}\]
If the instance is different from the instance in the handler or the operation is not in the handler then we float the operation
call over the handling computation.\\
\[\frac{
	\op \notin \{\op_1, ..., \op_n \} \lor k \neq j
}{
	\chandle{h}{(\copi{k}{\op}{\val}{x}{\comp})}\sep i \rightsquigarrow \copi{k}{\op}{\val}{x}{\chandle{h}{\comp}}\sep i
}\]

\subsection{Theorems}

(Preservation) If $\Delta;\Gamma \vdash \comp : \cty$ and $\comp \rightsquigarrow \comp'$ then $\Delta;\Gamma \vdash \comp' : \cty$ \\

(Progress effectful) If $\cdot;\cdot \vdash \comp : \cty$ then either:
\begin{itemize}
\item $\comp \rightsquigarrow \comp'$ for some $\comp'$
\item $\comp = \creturn{\val}$ for some $\val$
\item $\comp = \copi{\iota^i}{\op}{\val}{x}{\comp}$ for some $i, \op, \val$ and $\comp$
\end{itemize}

(Progress) If $\cdot;\cdot \vdash \comp : \texistss{i}{\aty{\ty}{\varnothing}}$ then either:
\begin{itemize}
\item $\comp \rightsquigarrow \comp'$ for some $\comp'$
\item $\comp = \creturn{\val}$ for some $\val$
\end{itemize}

(Determinism) If $\comp \rightsquigarrow \comp'$ and $\comp \rightsquigarrow \comp''$ then $\comp' = \comp''$  \\

(Type soundness) If $\cdot;\cdot \vdash \comp : \texistss{i}{\aty{\ty}{\varnothing}}$ and $\comp \rightsquigarrow^* \comp'$ then $\comp' = \creturn{\val}$ for some $\val$ (where $\rightsquigarrow^*$ is the reflexive-transitive closure of $\rightsquigarrow$)

\subsection{Examples}
We will show some examples together with the types that the discussed type system will assign to them.
After each example is a fitch-style type derivation.
For the examples we will assume that the following effect is in the context.
\begin{minted}[tabsize=2]{haskell}
effect Flip {
	flip : () -> Bool
}
\end{minted}

The following function $f$ creates a new instances and calls an operation on it, but does not return the instance itself.
In the type we have an existential but we see that the instance does not appear in the value type, but only in the effect annotation. This way we know that we do not have access to the instance and so are unable to handle the effect.
\begin{minted}[tabsize=2]{haskell}
f : () -> exists (i:Flip). Bool!{i}
f _ =
	inst <- new Flip;
	inst#flip ()
\end{minted}

\makebox[\textwidth]{$
\begin{nd}
  \open
  \hypo {1} {\;|\; \_ : \tunit}
  \have {2} {\cnew{Flip} : \texists{j}{Flip}{\aty{i}{\varnothing}}}
  \open
  \hypo {3} {i : E \;|\; inst : i}
  \open
  \hypo {4} {\;|\; x : Bool}
  \have {5} {\creturn{x} : \aty{Bool}{\varnothing}} \by{T-Return}{4}
  \have {6} {\creturn{x} : \aty{Bool}{\{i\}}} \by{T-SubComp}{3, 5}
  \close
  \have {7} {\copi{inst}{flip}{\vunit}{x}{\creturn{x}} : \aty{Bool}{\{i\}}} \by{T-Op}{6}
  \close
  \have {8} {\cdo{inst}{\cnew{Flip}}{\copi{inst}{flip}{\vunit}{x}{\creturn{x}}} : \texists{i}{Flip}{\aty{Bool}{\{i\}}}} \by{T-Do}{2, 7}
  \close
  \have {9} {\vabs{\_}{\cdo{inst}{\cnew{Flip}}{\copi{inst}{flip}{\vunit}{x}{\creturn{x}}}} : \tarr{\tunit}{\texists{i}{Flip}{\aty{Bool}{\{i\}}}}} \by{T-Abs}{8}
\end{nd}
$}\\

In the following function $g$ we create a new instance, call an operation on it and then immediately handle this effect.
The type of this function is pure, since the effect is immediately handled.
\begin{minted}[tabsize=2]{haskell}
g : () -> Bool!{}
g _ =
	inst <- new Flip;
	with handler(inst) {
		flip _ k -> k True
	} handle inst#flip ()
\end{minted}

The following function is also pure because although an instance is created, this instance is never used or returned.
\begin{minted}[tabsize=2]{haskell}
g' : () -> ()!{}
g' _ =
	inst <- new Flip;
	return ()
\end{minted}

\makebox[\textwidth]{$
\begin{nd}
  \open
  \hypo {1} {\;|\; \_ : \tunit}
  \have {2} {\cnew{Flip} : \texists{j}{Flip}{\aty{i}{\varnothing}}}
  \open
  \hypo {3} {i : E \;|\; inst : i}
  \have {4} {\vunit : \tunit}
  \have {5} {\creturn{\vunit} : \aty{\tunit}{\varnothing}} \by{T-Return}{4}
  \close
  \have {6} {\cdo{inst}{\cnew{Flip}}{\creturn{\vunit}} : \texists{i}{Flip}{\aty{\tunit}{\varnothing}}} \by{T-Do}{2, 5}
  \have {7} {\cdo{inst}{\cnew{Flip}}{\creturn{\vunit}} : \aty{\tunit}{\varnothing}} \by{T-ExistsRemove}{6}
  \close
  \have {8} {\vabs{\_}{\cdo{inst}{\cnew{Flip}}{\creturn{\vunit}}} : \tarr{\tunit}{\aty{\tunit}{\varnothing}}} \by{T-Abs}{7}
\end{nd}
$}\\

The following function simply wraps the creation of a $Flip$ instance.
\begin{minted}[tabsize=2]{haskell}
h' : () -> exists (i:Flip). i!{}
h' _ =
	inst <- new Flip;
	return inst
\end{minted}

In $h''$ we use $h'$ twice. This means that we create two distinct $Flip$ instances and we also expect two instance variables bound in the type.
\begin{minted}[tabsize=2]{haskell}
h'' : () -> exists (i:Flip) (j:Flip). (i, j)!{}
h'' _ =
	i1 <- h' ();
	i2 <- h' ();
	return (i1, i2)
\end{minted}

In the following function $nested$ we create a new instance and handle it, but in the computation we want to handle another instance is created and used. Only one operation call will be handled by the handler, the one called on $i1$. The operation call made on $i2$ is unhandled and so we are left with one existential quantifier.
\begin{minted}[tabsize=2]{haskell}
nested : () -> exists (i:Flip). Bool!{i}
nested _ =
	i1 <- new Flip;
	with handler(i1) {
		flip _ k -> k True
	} handle (
		i2 <- new Flip;
		x <- i1#flip ();
		y <- i2#flip ();
		return (x && y)
	)
\end{minted}

\begin{thebibliography}{9}
\bibitem{effectsystem}
Bauer, Andrej, and Matija Pretnar. ``An effect system for algebraic effects and handlers.'' International Conference on Algebra and Coalgebra in Computer Science. Springer, Berlin, Heidelberg, 2013.
\end{thebibliography}

\end{document}
