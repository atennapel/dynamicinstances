- Clean up problem statement and proposed solution in Chapter 1
- Better introduction for background
  / mention pros of pure functions
  / mention what effects I am talking about
  / more about static and dynamic instances
- Maybe no exception comparison
/ Specify language more precisely (inspired by Koka)
- Mention that we are using deep handlers
- Explain commute better
- Different color for return in the handler case
- One more fancy example for dynamic instances (ST example) (ST paper)
- Introduction:
	- contributions
	- side-effects stuff in introduction
	- mention monads as alternative or not at all
	- precise control over non-pure part
	- Write outline first
	- Assume no knowledge of pure programming
	- 3-5 pages
	- Have objective.
	- make sure relations between sentences are there
	- many programs need side-effects
	- side-effects hard for compilers
	- leave out hard to reason
	- ways of distinguising pure from non-pure
	- we focus on algebraic effects
	- Start with outline
	- essence of the problem, build up to it
	- effect encapsulation, address specific kind
	- problem more general than algebraic effects
- related work about monad/monad transformers/free

- notes introduction
- update 2.1
- safety in storyline (koka for example) (can connect to dynamic instances)
- ST in algebraic effects
- a lot of work on language that allow more control
	- control
	- separation
	- encapsulatio
	- cite actual languages
	- algebraic effects gives most things
	- and then limitations
- put in algebraic effecst example (small)
	- State example
	- see only 1 cell, limitations
	- only give handler signature
	- connect to the ST monad
	- cite
- introduce type systems generally

- update introduction chapter 2
- connect more to ST monad
- safety guaruantees of the different systems
- type system are everywhere, but often do not do much, we can do more with effect system, more control/guaruantees
- type systems appear in all kinds of languages
- dynamic instances connect to my system with st example, forces you to program in this way

- ask Casper to send pdf
- just make bullet list maybe in 2.3, explain them after.

- update contributions
- oxford comma everywhere
- ~ to avoid linebreak word~\ref
- use named references (google it)
- storyline sentences do not follow each other well enough
	- side effects tricky
	- type system appear out of the blue
		- type system play essential role in achieve stratification
		- type system allow to enforece these things
	- then zoom in to algebraic effects and handlers
	- start algebraic effects section with arguments
		- 
- rename background to introduciton to algebraic effects
- think about name for system
- use background to show syntax extensions
- put rule name above type rules
- hyperref rule names

- in conclusion future work what can dynamic instances do more

- rules in greenlight (takes months probably)

- green light in month

TODO:
- write type soundness sections
/ one more pass over introduction
/ come up with ST example
X omit dynamic instances in theory background

week after
- introduction to our system

- Eind juli deadline scriptie af
- begin september verdediging


Introductie notes
- Check oxford comma, CTRL-f spatie and
- "in addition" weg in Introductie
- \emph bij nieuwe notie
- polymorphism weg bij effects
- er zijn een hoops type systemen die dit doen, wij kijken naar algebraic effects
- terminologie
- uitleg code na code zelf
- refers to one implicit reference cell, we want more and we want to dynamically allocate them
- dynamic instances nieuwe paragraaf, link met ST
- begin met bridge om te verbinden
- contributie: we can model dynamically allocated references etc.

- "previous example" specifieke referentie
- replace variables with references

- maybe reference big ST example without giving.
- gives strong example in introduction as well.

- ask on IRC

- "previous calculus" give name
- figure met hoofdletter!
- maak macro
- hyperref, cref
- static instances give names
- short chapter names in header

2019-04-17
- cite logic variables, starrays example papers
- lose type inference example
- no type polymorphism

- write text for the examples 

2019-05-02
X work on calculus in parralel
X do not need to explain unit type
X start chapter with listing of new features
X First example should be figure of all features
X novel ideas/concepts, stress that
X be explicit that the state implementation is dumb
X "in section 3.1 we are going to..."
	X " insection 3.3 we are going to show scale ..."
X always show explicit effect scope variables

/ syntax text X done
- examples text done

2019-05-09
X untyped -> now typed in introduction
	- effect scopes allows for typing
	- effects are handled in one go
	- some things need to change, list but in abstract terms
	- explain what it was before and what it is now
X line numbers
X move vlength to vector figure
X give diferent handlers different names (handle and handler)
X process Caspers feedback (smaller stylistic stuff)

X merge state explanations
	X show multiple s-es in page 31 (actual example instead of twoScopes)
	X update explanation to match
X show that types of creating/using references similar to ST
X actually implement RNG (use dumb RNG generation) (using State again)

X rename handle everywhere to runscope
/ update calculus to correct text mention handle instead of runscope

2019-05-23
X In "intro to alg effect" put long code on it's own (not inline)
X try to get rule name above rule instead of to the right
	X write a good macro for this
	X use \begin{array} with @
- try to get rule references to have links
- in Chapter 5 introduction remind where "stuff" comes from
- scope location and instance location (not just location)
- no store with values needed
	- sigma needed for type system
	- operational semantics for fresh generation
- as usual we have Gamma and now we also have
- theorem for Sigma extension
	- operational semantics will do a valid extension (monotonic extensions)
- theorem:
	if G;S |- e : t and S <= S' then G;S' |- e : t
- fix theorem with non-empty annotation
	- operation call is possible if non-empty
- maybe mention that I formalize some stuff
- point of type soundness
	- point of lemmas
- fix theorems in background theory

X categorize future work
X related work
	X categorize related work
	X compare and contrast
	X is lifting relevant

- add "default handlers" as future work (global scope?)

2019-06-04
- conclusion short, 1 page
	- revise on thesis
- related work:
	- start with "wide field, lots of areas"
	- we focus on dynamic effects
	- zoom in at the start
	- use \paragraph{Eff}, \paragraph{Koka}, ...
	- better explain local effects
	- "in our system this is also true" refer better
	- change first line, better scope on what system
	- code examples of Eff and Koka
	- With eff say up front it is not typed
		- however untyped, can do more, fewer static guaruantees
		- first high-level then details
	- Eff: say what eff has and we don't (point to future work)
		- then discuss the resources
	- future work: global top scope (would need extra semantics)
	- OCaml: variant of eff is implemented in OCAml also supports dynamic effects
		- high level differences and then detail
		- add the New code piece
		- "very tedious to work with", remove very explain (require boilerplate, ...)
	- "you are" -> "one is"
	- Helium -> "paper shows no evidence of heaps..." (if not found) 
- add bibtex (use DBLP)
- future work:
	- intro text
	- theory section say something brief about formalization (we used this, debruijn that, resulted in)
		- labeled subsection
			- paragraph of detail (mention in contribution)
	- there all all kinds of other features, and then list of possible extensions
	- type annotations: "more usefull" more static guaruantees
		- remove over approximation
	
- introduction: mention Eff resources
	- mentioned delimeted continuations
- "this" is bad
- add summary to Examples chapter 3
	- what have we seen
	- conclude
	- whats next
